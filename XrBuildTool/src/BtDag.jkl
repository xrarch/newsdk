//
// Build the update DAG for the project.
//

#INCLUDE "Bt.hjk"

EXTERN BtSelectedTarget : ^BtTarget
EXTERN BtSdkBase : UBYTE[FE_PATH_BUFFER_SIZE]
EXTERN BtCHost : UWORD
EXTERN BtArchHasSuffix : UWORD
EXTERN BtCleanUp : UWORD
EXTERN BtKeepTmp : UWORD

EXTERN BtArchNameSuffix : UBYTE[FE_PATH_BUFFER_SIZE]

BtPathToJklCompiler : TlDynamicBuffer
BtPathToAssembler : TlDynamicBuffer
BtPathToLinker : TlDynamicBuffer
BtPathToDiskTool : TlDynamicBuffer
BtDiskToolUpdateBuffer : TlDynamicBuffer
BtLeafListHead : TlListEntry
BtCreatedPathHashTable : TlHashTable

BtCreatedPathMutex := NULLPTR
BtLeafListMutex := NULLPTR
BtLeafSemaphore := NULLPTR
BtPrintMutex := NULLPTR
BtActionMutex := NULLPTR
BtDiskToolBufferMutex := NULLPTR
BtLeafCount := 0
BtNodeCount := 0

BtTerminateWorkers := FALSE
BtCreatedDiskImage := FALSE

FN BtConnectDagNodes (
    IN fromnode : ^BtDagNode,
    IN tonode : ^BtDagNode,
)

    // Allocate a DAG edge and connect the nodes.

    dagedge : ^BtDagEdge

    status := TlBumpAlloc (
        SIZEOF BtDagEdge, // bytes
        OUT dagedge, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate DAG edge", 0, 0, 0 )
    END

    dagedge^.From = fromnode
    dagedge^.To = tonode

    IF fromnode^.OutEdgeListHead.Next == &fromnode^.OutEdgeListHead THEN
        // If the out-edge list was empty, it was a leaf node.
        // Decrement the leaf count and remove it from the list.

        BtLeafCount -= 1

        TlRemoveEntryList ( &fromnode^.LeafListEntry )
    END

    // Add to the in-edge list of the TO node, and the out-edge list of the
    // FROM node.

    TlInsertAtTailList (
        &tonode^.InEdgeListHead, // head
        &dagedge^.InEdgeListEntry, // entry
    )

    TlInsertAtTailList (
        &fromnode^.OutEdgeListHead, // head
        &dagedge^.OutEdgeListEntry, // entry
    )
END

FN BtCreateDagNode (
    IN target : ^BtTarget,
    IN type : BtDagNodeType,
) : ^BtDagNode

    // Build a DAG node.

    dagnode : ^BtDagNode

    status := TlBumpAlloc (
        SIZEOF BtDagNode, // bytes
        OUT dagnode, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate DAG node", 0, 0, 0 )
    END

    TlInitializeList ( &dagnode^.InEdgeListHead )
    TlInitializeList ( &dagnode^.OutEdgeListHead )

    dagnode^.Target = target
    dagnode^.Type = type

    // Optimistically place on the leaf list.

    TlInsertAtTailList (
        &BtLeafListHead, // head
        &dagnode^.LeafListEntry, // entry
    )

    BtLeafCount += 1
    BtNodeCount += 1

    RETURN dagnode
END

FN BtRemoveDagNode (
    IN node : ^BtDagNode,
) : UWORD

    // Remove the DAG node from the DAG.
    // Assumes this is a leaf node. Also assumes it has been removed from the
    // leaf list.
    // Assumes the leaf list mutex is held if called from worker threads.

    // Every in-edge must be removed.

    head := &node^.InEdgeListHead
    listentry := head^.Next

    WHILE head != listentry DO
        edge := CONTAINEROF listentry TO BtDagEdge.InEdgeListEntry
        fromnode := edge^.From

        // Remove this node from the in-node's out-edge list.

        TlRemoveEntryList ( &edge^.OutEdgeListEntry )

        // Check if the in-node just became a leaf.

        IF fromnode^.OutEdgeListHead.Next == &fromnode^.OutEdgeListHead THEN
            // Out-edge list just became empty. It's a leaf now.

            BtLeafCount += 1

            IF BtLeafCount == 1 THEN
                // Leaf list just became non-empty. Signal the semaphore.

                TlReleaseSemaphore ( BtLeafSemaphore )
            END

            TlInsertAtTailList (
                &BtLeafListHead, // head
                &fromnode^.LeafListEntry, // entry
            )
        END

        listentry = listentry^.Next
    END

    // Decrement DAG node count.

    BtNodeCount -= 1

    IF NOT BtNodeCount THEN
        // The DAG has become empty. Signal the semaphore to ensure that nobody
        // gets hung waiting for a leaf node.

        TlReleaseSemaphore ( BtLeafSemaphore )
    END
END

BtDepsLineBuffer : UBYTE[FE_PATH_BUFFER_SIZE]

FN BtAnyDepsLater (
    IN srctime : ULONG,
    IN depspath : ^UBYTE,
) : UWORD

    // Open the deps cache file. It's delineated by lines.
    // For each line, stat the header file and compare it with the srctime.
    // If it was modified later, return TRUE. If none were modified later, then
    // return FALSE.

    handle : ^VOID

    status := TlOpenSource (
        depspath, // filename
        OUT handle, // handle
    )

    IF status THEN
        TlInternalError ( "Failed to open deps file", 0, 0, 0 )
    END

    stat := BtStatFile ( depspath )

    IF NOT stat THEN
        TlClose ( handle )

        RETURN TRUE
    END

    ptr : ^UBYTE

    status = TlAlloc (
        stat^.SizeInBytes + 1, // bytes
        OUT ptr, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate deps buffer", 0, 0, 0 )
    END

    TlReadFile (
        handle, // handle
        stat^.SizeInBytes, // bytes
        ptr, // buffer
    )

    ptr[stat^.SizeInBytes] = 0

    tokptr := ptr

    WHILE TRUE DO
        tokptr = TlTokenize (
            tokptr, // buffer
            &BtDepsLineBuffer[0], // tokenbuffer
            FE_PATH_BUFFER_SIZE, // bufsize
            '\n', // delimiter
        )

        IF NOT tokptr THEN
            BREAK
        END

        // Stat the dependent header file.

        depstat := BtStatFile ( &BtDepsLineBuffer[0] )

        IF NOT depstat THEN
            TlPrint ( "%s: NOTE: Failed to stat header %s\n", TlProgramName,
                &BtDepsLineBuffer[0] )

            TlFree ( ptr )

            TlClose ( handle )

            RETURN TRUE
        END

        IF depstat^.ModificationTime >= srctime THEN
            // Modified more recently than the source file. We have to rebuild.

            TlFree ( ptr )

            TlClose ( handle )

            RETURN TRUE
        END
    END

    TlFree ( ptr )

    TlClose ( handle )

    RETURN FALSE
END

FN BtRunCommand (
    IN str : ^UBYTE,
) : UWORD

    IF BtVerbose THEN
        TlPrint ( "%s\n", str )
    END

    status := TlSystem ( str )

    IF status THEN
        TlPrint ( "%s: %u\n", str, status )
    END

    RETURN status
END

FN BtCleanUpFile (
    IN path : ^UBYTE,
)

    // Delete the given file if it exists.

    cmdline : TlDynamicBuffer

    TlInitializeDynamicBuffer ( &cmdline )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        "rm -f ", // srcbuf
        6, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        path, // srcbuf
        TlMeasureString ( path ) + 1, // length
    )

    BtRunCommand ( cmdline.Buffer )
END

STRUCT BtProcessDirectoryContext
    Target : ^BtTarget,
    DagNode : ^BtDagNode,
    SourceDirPath : ^TlDynamicBuffer,
    ModificationTime : UWORD,
    ObjectsOnly : UBYTE,
    HasFileName : UBYTE,
END

FN (TlIterateDirectoryCallbackF) BtProcessDirectoryEntry (
    IN fullpath : ^UBYTE,
    IN filename : ^UBYTE,
    IN context : ^VOID,
)

    // This callback is provided the full path from the current directory to
    // the file in the directory, along with just its name; the context
    // structure also provides the path for the source directory.
    //
    // What we really need to do here is:
    //
    //   1. Check that the file name ends with .jkl, .s, or .c. If it doesn't,
    //      we don't care about this file.
    //
    //   2. Look up the file in our stat cache. Check that it's a file (not a
    //      directory). If it's not, we don't care.
    //
    // Now we know that we care about it, that it's a file, and we have access
    // to the status information, we need to figure out if it needs to be
    // updated. Any of the following situations mean it does:
    //
    //   1. If the corresponding object file doesn't exist OR
    //   2. If the corresponding header dep file doesn't exist OR
    //   3. If the source file was modified more recently than the object OR
    //   4. If any of the header files were modified more recently than the
    //      source file.
    //
    // The object file is located at [srcdir]/obj/[arch]/[filename].o
    // The header dep file is located at [srcdir]/obj/[arch]/[filename].dep
    //
    // Note: We should also create the obj/ and obj/[arch]/ directories if they
    //       don't exist yet; this is the most convenient place to do that.

    pdc := CAST context TO ^BtProcessDirectoryContext

    ext := TlGetPathExtension ( filename )

    nodetype : BtDagNodeType

    IF TlCompareString ( ext, "jkl" ) == 0 THEN
        nodetype = DAG_JKL_OBJECT

    ELSEIF TlCompareString ( ext, "s" ) == 0 THEN
        nodetype = DAG_S_OBJECT

    ELSEIF TlCompareString ( ext, "c" ) == 0 THEN
        nodetype = DAG_C_OBJECT

    ELSE
        // Don't care.

        LEAVE
    END

    stat := BtStatFile ( fullpath )

    IF NOT stat THEN
        TlInternalError ( "Failed to stat file", 0, 0, 0 )
    END

    IF stat^.FileType != TL_FT_FILE THEN
        // Don't care.

        LEAVE
    END

    // Allocate a DAG node. We might not need it but we need the dynamic buffers
    // within.

    dagnode := BtCreateDagNode (
        pdc^.Target, // target
        nodetype, // type
    )

    TlInitializeDynamicBuffer ( &dagnode^.SrcPath )

    TlCopyIntoDynamicBuffer (
        &dagnode^.SrcPath, // array
        fullpath, // srcbuf
        TlMeasureString ( fullpath ) + 1, // length
    )

    objectpath := &dagnode^.ObjectPath
    depspath := &dagnode^.DepsPath
    tmppath := &dagnode^.TmpPath

    TlInitializeDynamicBuffer ( objectpath )
    TlInitializeDynamicBuffer ( depspath )
    TlInitializeDynamicBuffer ( tmppath )

    TlCopyIntoDynamicBuffer (
        objectpath, // array
        pdc^.SourceDirPath^.Buffer, // srcbuf
        pdc^.SourceDirPath^.Count - 1, // length
    )

    IF objectpath^.Buffer[objectpath^.Count - 1] != '/' THEN
        TlInsertDynamicBuffer (
            objectpath, // array
            '/', // byte
        )
    END

    TlCopyIntoDynamicBuffer (
        objectpath, // array
        "obj/", // srcbuf
        5, // length
    )

    // Create the object directory if it doesn't exist.

    TlCreateDirectory ( objectpath^.Buffer )

    // Pop the null terminator.

    TlPopDynamicBuffer ( objectpath )

    // Now add the architecture part.

    TlCopyIntoDynamicBuffer (
        objectpath, // array
        &BtTargetArchitectureName[0], // srcbuf
        TlMeasureString ( &BtTargetArchitectureName[0] ), // length
    )

    IF BtArchHasSuffix THEN
        // Add user-specified suffix to architecture name.

        TlCopyIntoDynamicBuffer (
            objectpath, // array
            &BtArchNameSuffix[0], // srcbuf
            TlMeasureString ( &BtArchNameSuffix[0] ), // length
        )
    END

    TlInsertDynamicBuffer (
        objectpath, // array
        0, // byte
    )

    // Create the architecture directory if it doesn't exist.

    TlCreateDirectory ( objectpath^.Buffer )

    // Pop the null terminator.

    TlPopDynamicBuffer ( objectpath )

    // Now add the object name.

    TlInsertDynamicBuffer (
        objectpath, // array
        '/', // byte
    )

    TlCopyIntoDynamicBuffer (
        objectpath, // array
        filename, // srcbuf
        TlMeasureString ( filename ), // length
    )

    // Copy what we have into the tmp path.

    TlCopyIntoDynamicBuffer (
        tmppath, // array
        objectpath^.Buffer, // srcbuf
        objectpath^.Count, // length
    )

    // And into the deps path.

    TlCopyIntoDynamicBuffer (
        depspath, // array
        objectpath^.Buffer, // srcbuf
        objectpath^.Count, // length
    )

    // Now add the .o extension and null terminator to the object path.

    TlCopyIntoDynamicBuffer (
        objectpath, // array
        ".o", // srcbuf
        3, // length
    )

    // Add the deps extension to the deps path.

    TlCopyIntoDynamicBuffer (
        depspath, // array
        ".dep", // srcbuf
        5, // length
    )

    // Add the tmp extension to the tmp path.

    TlCopyIntoDynamicBuffer (
        tmppath, // array
        ".tmp", // srcbuf
        5, // length
    )

    IF BtCleanUp THEN
        // This is actually just a clean-up operation.
        // Delete those 3 files if they exist.

        IF NOT pdc^.ObjectsOnly THEN
            BtCleanUpFile ( objectpath^.Buffer )
            BtCleanUpFile ( depspath^.Buffer )
            BtCleanUpFile ( tmppath^.Buffer )
        END

        LEAVE
    END

    // Add this to the target's object list.

    IF filename[0] == '_' THEN
        // Insert at the front if it starts with an underscore.

        TlInsertAtHeadList (
            &pdc^.Target^.ObjectListHead, // head
            &dagnode^.ObjectListEntry, // entry
        )

    ELSE
        TlInsertAtTailList (
            &pdc^.Target^.ObjectListHead, // head
            &dagnode^.ObjectListEntry, // entry
        )
    END

    IF NOT pdc^.ObjectsOnly THEN
        // Now we have these paths, check the existence of the dep file.

        IF nodetype == DAG_JKL_OBJECT AND
            NOT TlPathExists ( depspath^.Buffer ) THEN

            GOTO AddToDag 
        END

        // Stat the object file and check the modification times.

        objstat := BtStatFile ( objectpath^.Buffer )

        IF NOT objstat THEN
            // Doesn't exist.

            GOTO AddToDag
        END

        IF stat^.ModificationTime >= objstat^.ModificationTime THEN
            // Source file modified later than object file.

            GOTO AddToDag
        END

        // Now we have to open and read the deps file.

        IF nodetype == DAG_JKL_OBJECT AND
            BtAnyDepsLater (
                objstat^.ModificationTime, // srctime
                depspath^.Buffer, // depspath
            ) THEN

            GOTO AddToDag
        END

    ELSEIF NOT pdc^.DagNode AND pdc^.HasFileName THEN
        // Stat the object file and check the modification times.

        objstat := BtStatFile ( objectpath^.Buffer )

        IF objstat AND objstat^.ModificationTime > pdc^.ModificationTime THEN
            // Object file modified later than executable file.
            // Cause re-link.

            pdc^.DagNode = BtCreateDagNode (
                pdc^.Target, // target
                DAG_EXECUTABLE, // type
            )
        END
    END

    // We didn't need to add it to the DAG, so uninitialize all we can.

    // TlUninitializeDynamicBuffer ( objectpath )
    TlUninitializeDynamicBuffer ( depspath )
    TlUninitializeDynamicBuffer ( tmppath )
    TlUninitializeDynamicBuffer ( &dagnode^.SrcPath )

    TlRemoveEntryList ( &dagnode^.LeafListEntry )
    BtNodeCount -= 1
    BtLeafCount -= 1

    LEAVE

    @AddToDag

    IF NOT pdc^.DagNode THEN
        // Gotta make it.

        type := DAG_EXECUTABLE

        IF NOT pdc^.HasFileName THEN
            type = DAG_NULL
        END

        pdc^.DagNode = BtCreateDagNode (
            pdc^.Target, // target
            type, // type
        )
    END

    BtConnectDagNodes (
        pdc^.DagNode, // fromnode
        dagnode, // tonode
    )
END

FN BtBuildDagForTarget (
    IN target : ^BtTarget,
) : ^BtDagNode

    // Build the update sub-DAG for a target. If the target is up to date, we
    // return a NULLPTR.

    IF target^.CheckedForUpdate THEN
        RETURN target^.DagNode
    END

    // Create the prebuilt copies directory.

    IF target^.HasPrebuiltCopies THEN
        TlCreateDirectory ( target^.PrebuiltCopiesPath.Buffer )
    END

    dagnode : ^BtDagNode = NULLPTR

    dagtype : BtDagNodeType

    IF target^.HasFileName THEN
        dagtype = DAG_EXECUTABLE

    ELSE
        dagtype = DAG_NULL
    END

    // We have to recursively build DAG nodes for all of the targets depended
    // upon by this target. Any that return non-NULLPTR need to be added as out-
    // edges to this node (plus, we need to create the node if it hasn't been
    // created yet).

    dependhead := &target^.DependsOnListHead
    dependentry := dependhead^.Next

    WHILE dependentry != dependhead DO
        dependnode := BtBuildDagForTarget (
            (CONTAINEROF dependentry TO BtDependsListEntry.Entry)^.Target,
        )

        IF dependnode THEN
            IF NOT dagnode THEN
                dagnode = BtCreateDagNode (
                    target, // target
                    dagtype, // type
                )
            END

            BtConnectDagNodes (
                dagnode, // fromnode
                dependnode, // tonode
            )
        END

        dependentry = dependentry^.Next
    END

    // For all SOURCES subdirectories specified, we need to iterate their
    // contents. Each *.jkl and *.s file represent an object file in the
    // build cache that must exist and have a modification date later than
    // the source file, and later than that of all header files upon which
    // the source file depends (which are themselves cached). If this
    // invariant is violated, we have to create a node in the DAG and add an
    // out-edge from ourselves to it.

    // Note: Also check for *.c files when building for the C transpilation
    //       host.

    sourceshead := &target^.SourcesListHead
    sourcesentry := sourceshead^.Next

    context : BtProcessDirectoryContext

    context.Target = target
    context.HasFileName = target^.HasFileName
    context.ModificationTime = 0

    // If there still isn't a DAG node, check to make sure that the
    // executable actually does exist. If it doesn't, we need to create a
    // node for relinking.

    IF target^.HasFileName THEN
        execstat := BtStatFile ( target^.FileName.Buffer )

        IF NOT execstat THEN
            IF NOT BtCleanUp AND NOT dagnode THEN
                dagnode = BtCreateDagNode (
                    target, // target
                    dagtype, // type
                )
            END
        ELSE
            context.ModificationTime = execstat^.ModificationTime
        END
    END

    context.DagNode = dagnode

    WHILE sourcesentry != sourceshead DO
        sourcesrcrd := CONTAINEROF sourcesentry TO BtSourcesRecord.Entry

        context.SourceDirPath = &sourcesrcrd^.FilePathBuffer
        context.ObjectsOnly = sourcesrcrd^.ObjectsOnly

        status := TlIterateDirectory (
            sourcesrcrd^.FilePathBuffer.Buffer, // path
            &BtProcessDirectoryEntry, // callback
            &context, // context
        )

        IF status THEN
            TlInternalError ( "Failed to iterate directory", 0, 0, 0 )
        END

        sourcesentry = sourcesentry^.Next
    END

    dagnode = context.DagNode

    IF NOT dagnode AND target^.ImageAction AND BtCreatedDiskImage THEN
        // This target has image actions. Make sure they run.

        dagnode = BtCreateDagNode (
            target, // target
            DAG_NULL, // type
        )
    END

    IF NOT dagnode AND target^.Always THEN
        dagnode = BtCreateDagNode (
            target, // target
            DAG_NULL, // type
        )
    END

    // Now cache the DAG node and return.

    target^.DagNode = dagnode
    target^.CheckedForUpdate = TRUE

    RETURN dagnode
END

FNPTR BtDagActionF (
    IN dagnode : ^BtDagNode,
)

FN BtRunActions (
    IN target : ^BtTarget,
) : UWORD

    // Run the action commands if any.

    listhead := &target^.ActionListHead
    listentry := listhead^.Next

    WHILE listhead != listentry DO
        action := CONTAINEROF listentry TO BtActionRecord.Entry

        // Serialize all ACTIONs with respect to eachother.

        TlAcquireMutex ( BtActionMutex )

        IF BtRunCommand ( action^.ActionBuffer ) THEN
            TlReleaseMutex ( BtActionMutex )

            RETURN TRUE
        END

        TlReleaseMutex ( BtActionMutex )

        listentry = listentry^.Next
    END

    RETURN FALSE
END

FN (BtDagActionF) BtBuildNull (
    IN dagnode : ^BtDagNode,
)

    IF BtRunActions ( dagnode^.Target ) THEN
        BtTerminateWorkers = TRUE
    END
END

FN (BtDagActionF) BtBuildJkl (
    IN dagnode : ^BtDagNode,
)

    // Build the JKL file.

    TlAcquireMutex ( BtPrintMutex )

    TlPrint ( "Building %s\n", TlGetFileName ( dagnode^.SrcPath.Buffer ) )

    TlReleaseMutex ( BtPrintMutex )

    // First we have to build the command line.

    cmdline : TlDynamicBuffer

    TlInitializeDynamicBuffer ( &cmdline )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        BtPathToJklCompiler.Buffer, // srcbuf
        BtPathToJklCompiler.Count, // length
    )

    TlInsertDynamicBuffer (
        &cmdline, // array
        ' ', // byte
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        dagnode^.SrcPath.Buffer, // srcbuf
        dagnode^.SrcPath.Count - 1, // length
    )

    TlInsertDynamicBuffer (
        &cmdline, // array
        ' ', // byte
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        dagnode^.TmpPath.Buffer, // srcbuf
        dagnode^.TmpPath.Count - 1, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        " header=", // srcbuf
        8, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        dagnode^.DepsPath.Buffer, // srcbuf
        dagnode^.DepsPath.Count - 1, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        " incdir=", // srcbuf
        8, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        dagnode^.Target^.IncludePaths.Buffer, // srcbuf
        dagnode^.Target^.IncludePaths.Count, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        " libdir=", // srcbuf
        8, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        dagnode^.Target^.LibPaths.Buffer, // srcbuf
        dagnode^.Target^.LibPaths.Count, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        " target=", // srcbuf
        8, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        &BtTargetArchitectureName[0], // srcbuf
        TlMeasureString ( &BtTargetArchitectureName[0] ), // length
    )

    IF dagnode^.Target^.JklOptions.Count THEN
        TlInsertDynamicBuffer (
            &cmdline, // array
            ' '
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            dagnode^.Target^.JklOptions.Buffer, // srcbuf
            dagnode^.Target^.JklOptions.Count, // length
        )
    END

    head := &dagnode^.Target^.ExposedMacroListHead
    listentry := head^.Next

    WHILE listentry != head DO
        exprec := CONTAINEROF listentry TO BtExposedMacroRecord.Entry
        macro := exprec^.Macro

        TlInsertDynamicBuffer (
            &cmdline, // array
            ' ', // byte
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            &macro^.Name[0], // srcbuf
            TlMeasureString ( &macro^.Name[0] ), // length
        )

        TlInsertDynamicBuffer (
            &cmdline, // array
            '=', // byte
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            macro^.Contents.Buffer, // srcbuf
            macro^.Contents.Count - 1, // length
        )

        listentry = listentry^.Next
    END

    TlInsertDynamicBuffer (
        &cmdline, // array
        0, // byte
    )

    // Now do the command.

    IF BtRunCommand ( cmdline.Buffer ) THEN
        BtTerminateWorkers = TRUE

        LEAVE
    END

    IF dagnode^.Target^.HasPrebuiltCopies THEN
        // Copy the .tmp file to the prebuilt copies directory.

        TlUninitializeDynamicBuffer ( &cmdline )
        TlInitializeDynamicBuffer ( &cmdline )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            "cp ", // srcbuf
            3, // length
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            dagnode^.TmpPath.Buffer, // srcbuf
            dagnode^.TmpPath.Count - 1, // length
        )

        TlInsertDynamicBuffer (
            &cmdline, // array
            ' ', // byte
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            dagnode^.Target^.PrebuiltCopiesPath.Buffer, // srcbuf
            dagnode^.Target^.PrebuiltCopiesPath.Count, // length
        )

        IF BtRunCommand ( cmdline.Buffer ) THEN
            BtTerminateWorkers = TRUE

            LEAVE
        END
    END

    // Uninit and reinit the cmdline dynamic buffer to reuse it.

    TlUninitializeDynamicBuffer ( &cmdline )
    TlInitializeDynamicBuffer ( &cmdline )

    // Now we have to build the secondary command line.
    // If this is the C host, it's the C compiler. Otherwise, it's the
    // assembler.

    IF BtCHost THEN
        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            "cc -O3 -x c -c ", // srcbuf
            15, // length
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            dagnode^.TmpPath.Buffer, // srcbuf
            dagnode^.TmpPath.Count - 1, // length
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            " -o ", // srcbuf
            4, // length
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            dagnode^.ObjectPath.Buffer, // srcbuf
            dagnode^.ObjectPath.Count, // length
        )
    
    ELSE
        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            BtPathToAssembler.Buffer, // srcbuf
            BtPathToAssembler.Count, // length
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            " target=", // srcbuf
            8, // length
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            &BtTargetArchitectureName[0], // srcbuf
            TlMeasureString ( &BtTargetArchitectureName[0] ), // length
        )

        TlInsertDynamicBuffer (
            &cmdline, // array
            ' ', // byte
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            dagnode^.TmpPath.Buffer, // srcbuf
            dagnode^.TmpPath.Count - 1, // length
        )

        TlInsertDynamicBuffer (
            &cmdline, // array
            ' ', // byte
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            dagnode^.ObjectPath.Buffer, // srcbuf
            dagnode^.ObjectPath.Count, // length
        )
    END

    // Now do the command.

    IF BtRunCommand ( cmdline.Buffer ) THEN
        BtTerminateWorkers = TRUE
    END

    IF NOT BtKeepTmp THEN
        // Delete the tmp file.

        BtCleanUpFile ( dagnode^.TmpPath.Buffer )
    END

    TlUninitializeDynamicBuffer ( &cmdline )
END

FN (BtDagActionF) BtBuildC (
    IN dagnode : ^BtDagNode,
)

    // Build the C file.

    TlAcquireMutex ( BtPrintMutex )

    TlPrint ( "Building %s\n", TlGetFileName ( dagnode^.SrcPath.Buffer ) )

    TlReleaseMutex ( BtPrintMutex )

    cmdline : TlDynamicBuffer

    TlInitializeDynamicBuffer ( &cmdline )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        "cc -O3 -c ", // srcbuf
        10, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        dagnode^.SrcPath.Buffer, // srcbuf
        dagnode^.SrcPath.Count - 1, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        " -o ", // srcbuf
        4, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        dagnode^.ObjectPath.Buffer, // srcbuf
        dagnode^.ObjectPath.Count, // length
    )

    // Now do the command.

    IF BtRunCommand ( cmdline.Buffer ) THEN
        BtTerminateWorkers = TRUE

        LEAVE
    END

    IF dagnode^.Target^.HasPrebuiltCopies THEN
        // Copy the .c file to the prebuilt copies directory.

        TlUninitializeDynamicBuffer ( &cmdline )
        TlInitializeDynamicBuffer ( &cmdline )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            "cp ", // srcbuf
            3, // length
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            dagnode^.SrcPath.Buffer, // srcbuf
            dagnode^.SrcPath.Count - 1, // length
        )

        TlInsertDynamicBuffer (
            &cmdline, // array
            ' ', // byte
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            dagnode^.Target^.PrebuiltCopiesPath.Buffer, // srcbuf
            dagnode^.Target^.PrebuiltCopiesPath.Count, // length
        )

        IF BtRunCommand ( cmdline.Buffer ) THEN
            BtTerminateWorkers = TRUE
        END
    END
END

FN (BtDagActionF) BtBuildS (
    IN dagnode : ^BtDagNode,
)

    // Assemble the file.

    TlAcquireMutex ( BtPrintMutex )

    TlPrint ( "Assembling %s\n", TlGetFileName ( dagnode^.SrcPath.Buffer ) )

    TlReleaseMutex ( BtPrintMutex )

    cmdline : TlDynamicBuffer

    TlInitializeDynamicBuffer ( &cmdline )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        BtPathToAssembler.Buffer, // srcbuf
        BtPathToAssembler.Count, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        " target=", // srcbuf
        8, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        &BtTargetArchitectureName[0], // srcbuf
        TlMeasureString ( &BtTargetArchitectureName[0] ), // length
    )

    TlInsertDynamicBuffer (
        &cmdline, // array
        ' ', // byte
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        dagnode^.SrcPath.Buffer, // srcbuf
        dagnode^.SrcPath.Count - 1, // length
    )

    TlInsertDynamicBuffer (
        &cmdline, // array
        ' ', // byte
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        dagnode^.ObjectPath.Buffer, // srcbuf
        dagnode^.ObjectPath.Count - 1, // length
    )

    head := &dagnode^.Target^.ExposedMacroListHead
    listentry := head^.Next

    WHILE listentry != head DO
        exprec := CONTAINEROF listentry TO BtExposedMacroRecord.Entry
        macro := exprec^.Macro

        TlInsertDynamicBuffer (
            &cmdline, // array
            ' ', // byte
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            &macro^.Name[0], // srcbuf
            TlMeasureString ( &macro^.Name[0] ), // length
        )

        TlInsertDynamicBuffer (
            &cmdline, // array
            '=', // byte
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            macro^.Contents.Buffer, // srcbuf
            macro^.Contents.Count - 1, // length
        )

        listentry = listentry^.Next
    END

    TlInsertDynamicBuffer (
        &cmdline, // array
        0, // byte
    )

    // Now do the command.

    IF BtRunCommand ( cmdline.Buffer ) THEN
        BtTerminateWorkers = TRUE
    END
END

STRUCT BtCreatedPathEntry
    Entry : TlHashTableEntry,
END

FN BtPathIsNothing (
    IN path : ^UBYTE,
) : UWORD

    // Return TRUE if all the path components are . or ..
    // Otherwise return FALSE.

    len := 0

    WHILE path^ DO
        IF path^ == '/' THEN
            // Reset component length.

            len = 0

        ELSEIF len == 2 THEN
            // Component is over 2 characters. Not . or ..

            RETURN FALSE

        ELSEIF path^ != '.' THEN
            // Character isn't a dot. Not . or ..

            RETURN FALSE

        ELSE
            // Increment dot count for this component.

            len += 1
        END

        path += 1
    END

    RETURN TRUE
END

FN (BtDagActionF) BtLinkExecutable (
    IN dagnode : ^BtDagNode,
)

    // Link the executable.

    TlAcquireMutex ( BtPrintMutex )

    TlPrint ( "Linking %s\n", dagnode^.Target^.FileName.Buffer )

    TlReleaseMutex ( BtPrintMutex )

    // Delete the file if it already exists.

    BtCleanUpFile ( dagnode^.Target^.FileName.Buffer )

    // Try to create all the directories that will be required in the path
    // to this file.

    parentpath : TlDynamicBuffer

    TlInitializeDynamicBuffer ( &parentpath )

    TlCopyParentPath (
        dagnode^.Target^.FileName.Buffer, // srcpath
        &parentpath, // destpath
    )

    i := 0
    buf := parentpath.Buffer

    inslash := buf[0] == '/'

    WHILE i < parentpath.Count DO
        IF buf[i] == '/' THEN
            IF NOT inslash THEN
                // Found the end of a component. Write a null terminator.

                buf[i] = 0

                // Now create the path as a directory.
                // We will tend to recreate directories a lot (which is a no-op)
                // but to reduce syscall overhead we avoid doing it for "nothing
                // paths" (those that consist only of . and .. components) and
                // also use a hash set to try to avoid multiple attempts to
                // create the same directories in a single invocation of the
                // build tool.
                //
                // We will, again, still sometimes try to create the same
                // directories multiple times, but this is harmless (just some
                // wasted CPU cycles which are dwarfed by compilation times
                // anyway).

                IF NOT BtPathIsNothing ( buf ) THEN
                    created : UBYTE

                    TlAcquireMutex ( BtCreatedPathMutex )

                    createdpath := CAST TlLookupOrAllocateEntryHashTable (
                        &BtCreatedPathHashTable, // hashtable
                        SIZEOF BtCreatedPathEntry + i + 1, // entrysize
                        buf, // key
                        OUT created, // created
                    ) TO ^BtCreatedPathEntry

                    IF created THEN
                        key := CAST createdpath +
                            SIZEOF BtCreatedPathEntry TO ^UBYTE

                        TlCopyString (
                            key, // dest
                            buf, // src
                            -1, // bufsize
                        )

                        createdpath^.Entry.Key = key

                        TlCreateDirectory ( buf )
                    END

                    TlReleaseMutex ( BtCreatedPathMutex )
                END

                buf[i] = '/'
            END

            inslash = TRUE

        ELSE
            inslash = FALSE
        END

        i += 1
    END

    TlUninitializeDynamicBuffer ( &parentpath )

    cmdline : TlDynamicBuffer

    TlInitializeDynamicBuffer ( &cmdline )

    IF BtCHost THEN
        // Use CC to link.

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            "cc -O3 -o ", // srcbuf
            10, // length
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            dagnode^.Target^.FileName.Buffer, // srcbuf
            dagnode^.Target^.FileName.Count - 1, // length
        )

        IF dagnode^.Target^.LinkOptions.Count THEN
            TlInsertDynamicBuffer (
                &cmdline, // array
                ' ', // byte
            )

            TlCopyIntoDynamicBuffer (
                &cmdline, // array
                dagnode^.Target^.LinkOptions.Buffer, // srcbuf
                dagnode^.Target^.LinkOptions.Count, // length
            )
        END

        head := &dagnode^.Target^.ObjectListHead
        listentry := head^.Next

        WHILE listentry != head DO
            node := CONTAINEROF listentry TO BtDagNode.ObjectListEntry

            TlInsertDynamicBuffer (
                &cmdline, // array
                ' ', // byte
            )

            TlCopyIntoDynamicBuffer (
                &cmdline, // array
                node^.ObjectPath.Buffer, // srcbuf
                node^.ObjectPath.Count - 1, // length
            )

            // TlPrintString ( node^.ObjectPath.Buffer )

            listentry = listentry^.Next
        END

        TlInsertDynamicBuffer (
            &cmdline, // array
            0, // byte
        )

    ELSE
        // Use the linker.

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            BtPathToLinker.Buffer, // srcbuf
            BtPathToLinker.Count, // length
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            " link ", // srcbuf
            6, // length
        )

        TlCopyIntoDynamicBuffer (
            &cmdline, // array
            dagnode^.Target^.FileName.Buffer, // srcbuf
            dagnode^.Target^.FileName.Count - 1, // length
        )

        IF dagnode^.Target^.LinkOptions.Count THEN
            TlInsertDynamicBuffer (
                &cmdline, // array
                ' '
            )

            TlCopyIntoDynamicBuffer (
                &cmdline, // array
                dagnode^.Target^.LinkOptions.Buffer, // srcbuf
                dagnode^.Target^.LinkOptions.Count, // length
            )
        END

        head := &dagnode^.Target^.ObjectListHead
        listentry := head^.Next

        WHILE listentry != head DO
            node := CONTAINEROF listentry TO BtDagNode.ObjectListEntry

            TlInsertDynamicBuffer (
                &cmdline, // array
                ' ', // byte
            )

            TlCopyIntoDynamicBuffer (
                &cmdline, // array
                node^.ObjectPath.Buffer, // srcbuf
                node^.ObjectPath.Count - 1, // length
            )

            listentry = listentry^.Next
        END

        IF dagnode^.Target^.LinkPaths.Count THEN
            TlInsertDynamicBuffer (
                &cmdline, // array
                ' '
            )

            TlCopyIntoDynamicBuffer (
                &cmdline, // array
                dagnode^.Target^.LinkPaths.Buffer, // srcbuf
                dagnode^.Target^.LinkPaths.Count, // length
            )
        END

        IF dagnode^.Target^.DyLinkPaths.Count THEN
            TlCopyIntoDynamicBuffer (
                &cmdline, // array
                " -d ", // srcbuf
                4, // length
            )

            TlCopyIntoDynamicBuffer (
                &cmdline, // array
                dagnode^.Target^.DyLinkPaths.Buffer, // srcbuf
                dagnode^.Target^.DyLinkPaths.Count, // length
            )
        END

        TlInsertDynamicBuffer (
            &cmdline, // array
            0, // byte
        )
    END

    // Now do the command.

    IF BtRunCommand ( cmdline.Buffer ) THEN
        BtTerminateWorkers = TRUE

        LEAVE
    END

    IF BtRunActions ( dagnode^.Target ) THEN
        BtTerminateWorkers = TRUE

        LEAVE
    END

    IF BtUseDiskTool AND dagnode^.Target^.RelFileName.Count != 0 THEN
        // Should be updated in the disk image.
        // Create a line in the disk tool updatefiles buffer.

        TlAcquireMutex ( BtDiskToolBufferMutex )

        TlCopyIntoDynamicBuffer (
            &BtDiskToolUpdateBuffer, // array
            dagnode^.Target^.RelFileName.Buffer, // srcbuf
            dagnode^.Target^.RelFileName.Count - 1, // length
        )

        TlInsertDynamicBuffer (
            &BtDiskToolUpdateBuffer, // array
            ' ', // byte
        )

        TlCopyIntoDynamicBuffer (
            &BtDiskToolUpdateBuffer, // array
            dagnode^.Target^.FileName.Buffer, // srcbuf
            dagnode^.Target^.FileName.Count - 1, // length
        )

        TlInsertDynamicBuffer (
            &BtDiskToolUpdateBuffer, // array
            '\n', // byte
        )

        TlReleaseMutex ( BtDiskToolBufferMutex )
    END
END

BtDagAction : BtDagActionF[DAG_MAX] = {
    [DAG_NULL] = &BtBuildNull,
    [DAG_JKL_OBJECT] = &BtBuildJkl,
    [DAG_C_OBJECT] = &BtBuildC,
    [DAG_S_OBJECT] = &BtBuildS,
    [DAG_EXECUTABLE] = &BtLinkExecutable,
}

FN (TlThreadStartRoutineF) BtWorkerThread (
    IN arg : ^VOID,
)

    WHILE BtNodeCount AND NOT BtTerminateWorkers DO
        TlAcquireMutex ( BtLeafListMutex )

        IF NOT BtNodeCount THEN
            TlReleaseMutex ( BtLeafListMutex )

            BREAK
        END

        IF BtTerminateWorkers THEN
            TlReleaseMutex ( BtLeafListMutex )

            BREAK
        END

        IF NOT BtLeafCount THEN
            // Release the list mutex and wait for a leaf node.

            TlReleaseMutex ( BtLeafListMutex )

            TlAcquireSemaphore ( BtLeafSemaphore )
            TlReleaseSemaphore ( BtLeafSemaphore )

            // Continue to try again.

            CONTINUE
        END

        // Remove a leaf node from the head of the list.

        leafnode := CONTAINEROF BtLeafListHead.Next TO BtDagNode.LeafListEntry

        TlRemoveEntryList ( &leafnode^.LeafListEntry )

        BtLeafCount -= 1

        IF NOT BtLeafCount THEN
            // The list is now empty. Consume the semaphore count.

            TlAcquireSemaphore ( BtLeafSemaphore )
        END

        TlReleaseMutex ( BtLeafListMutex )

        // We now have this leaf node in our custody. Do whatever type-specific
        // action is warranted to bring it up to date.

        BtDagAction[leafnode^.Type] ( leafnode )

        // Now remove the leaf node from the DAG.

        TlAcquireMutex ( BtLeafListMutex )

        BtRemoveDagNode ( leafnode )

        TlReleaseMutex ( BtLeafListMutex )
    END
END

FN (TlTerminationHandlerF) BtTerminationHandler ()

    // Some host-specific user action occurred to terminate the build process
    // (such as ctrl-C on *nix hosts). All we do is set a flag which will cause
    // the worker threads to break out of their loops.

    TlPrint ( "BREAK. Waiting for jobs to complete.\n" )

    BtTerminateWorkers = TRUE
END

FN BtCreateDiskImage ()

    IF TlPathExists ( BtDiskImageName ) THEN
        // Already exists.

        LEAVE
    END

    // Create it.

    TlPrint ( "Creating image %s...\n", BtDiskImageName )

    cmdline : TlDynamicBuffer

    TlInitializeDynamicBuffer ( &cmdline )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        BtPathToDiskTool.Buffer, // srcbuf
        BtPathToDiskTool.Count, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        " create ", // srcbuf
        8, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        BtDiskImageName, // srcbuf
        TlMeasureString ( BtDiskImageName ), // length
    )

    TlInsertDynamicBuffer (
        &cmdline, // array
        ' ', // byte
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        BtDiskImageCreationOptions, // srcbuf
        TlMeasureString ( BtDiskImageCreationOptions ) + 1, // length
    )

    IF BtRunCommand ( cmdline.Buffer ) THEN
        TlError ( "%s: Failed to create disk image\n", BtDiskImageName )
    END

    TlUninitializeDynamicBuffer ( &cmdline )

    BtCreatedDiskImage = TRUE
END

FN BtUpdateDiskImage ()

    // Write out the update buffer.

    handle : ^VOID

    status := TlOpenDestination (
        "_DELTA.ful", // filename
        OUT handle, // handle
    )

    IF status THEN
        TlError ( "Failed to open DELTA file to update disk image\n" )
    END

    TlWriteFile (
        handle, // handle
        BtDiskToolUpdateBuffer.Count, // bytes
        BtDiskToolUpdateBuffer.Buffer, // buffer
    )

    TlClose ( handle )

    // Construct update command line.

    cmdline : TlDynamicBuffer

    TlInitializeDynamicBuffer ( &cmdline )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        BtPathToDiskTool.Buffer, // srcbuf
        BtPathToDiskTool.Count, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        " updatefiles ", // srcbuf
        13, // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        BtDiskImageName, // srcbuf
        TlMeasureString ( BtDiskImageName ), // length
    )

    TlInsertDynamicBuffer (
        &cmdline, // array
        ' ', // byte
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        BtDiskImageUpdatePartition, // srcbuf
        TlMeasureString ( BtDiskImageUpdatePartition ), // length
    )

    TlCopyIntoDynamicBuffer (
        &cmdline, // array
        " _DELTA.ful", // srcbuf
        12, // length
    )

    // Update.

    IF BtRunCommand ( cmdline.Buffer ) THEN
        TlError ( "%s: Failed to update disk image\n", BtDiskImageName )
    END

    TlUninitializeDynamicBuffer ( &cmdline )

    // Delete delta file.

    BtCleanUpFile ( "_DELTA.ful" )
END

FN BtBuildDag ()

    // Build some paths.

    TlInitializeDynamicBuffer ( &BtPathToJklCompiler )
    TlInitializeDynamicBuffer ( &BtPathToAssembler )
    TlInitializeDynamicBuffer ( &BtPathToLinker )

    // Build a path to the Jackal compiler.

    TlCopyIntoDynamicBuffer (
        &BtPathToJklCompiler, // array
        &BtSdkBase[0], // srcbuf
        TlMeasureString ( &BtSdkBase[0] ), // length
    )

    IF BtPathToJklCompiler.Buffer[BtPathToJklCompiler.Count - 1] != '/' THEN
        TlInsertDynamicBuffer (
            &BtPathToJklCompiler, // array
            '/', // byte
        )
    END

    TlCopyIntoDynamicBuffer (
        &BtPathToJklCompiler, // array
        "bin/jkl.exe", // srcbuf
        11, // length
    )

    // Build a path to the assembler.

    TlCopyIntoDynamicBuffer (
        &BtPathToAssembler, // array
        &BtSdkBase[0], // srcbuf
        TlMeasureString ( &BtSdkBase[0] ), // length
    )

    IF BtPathToAssembler.Buffer[BtPathToAssembler.Count - 1] != '/' THEN
        TlInsertDynamicBuffer (
            &BtPathToAssembler, // array
            '/', // byte
        )
    END

    TlCopyIntoDynamicBuffer (
        &BtPathToAssembler, // array
        "bin/xrasm.exe", // srcbuf
        13, // length
    )

    // Build a path to the linker.

    TlCopyIntoDynamicBuffer (
        &BtPathToLinker, // array
        &BtSdkBase[0], // srcbuf
        TlMeasureString ( &BtSdkBase[0] ), // length
    )

    IF BtPathToLinker.Buffer[BtPathToLinker.Count - 1] != '/' THEN
        TlInsertDynamicBuffer (
            &BtPathToLinker, // array
            '/', // byte
        )
    END

    TlCopyIntoDynamicBuffer (
        &BtPathToLinker, // array
        "bin/xrlink.exe", // srcbuf
        14, // length
    )

    // Create the image if needed.

    IF BtUseDiskTool THEN
        // Build a path to the disk tool.

        BtDiskToolBufferMutex = TlCreateMutex ()

        TlInitializeDynamicBuffer ( &BtPathToDiskTool )
        TlInitializeDynamicBuffer ( &BtDiskToolUpdateBuffer )

        TlCopyIntoDynamicBuffer (
            &BtPathToDiskTool, // array
            &BtSdkBase[0], // srcbuf
            TlMeasureString ( &BtSdkBase[0] ), // length
        )

        IF BtPathToDiskTool.Buffer[BtPathToDiskTool.Count - 1] != '/' THEN
            TlInsertDynamicBuffer (
                &BtPathToDiskTool, // array
                '/', // byte
            )
        END

        TlCopyIntoDynamicBuffer (
            &BtPathToDiskTool, // array
            "bin/xrdut.exe", // srcbuf
            13, // length
        )

        BtCreateDiskImage ()
    END

    // The update DAG represents all of the 'objects' that need to be updated to
    // bring the selected target up to date. A node represents one of these
    // objects, and a directed edge leads FROM an object TO an object that must
    // be updated first.
    //
    // If an object is added to the DAG, all objects that depend upon it will
    // also be added to the DAG.
    //
    // An exhaustive list of objects and their associated actions are:
    //
    //   o An object code file is added to the DAG if:
    //      1. The object code file does not exist OR
    //      2. The associated source file was modified more recently than the
    //         object code file OR
    //      3. One of the source file's headers was modified more recently OR
    //      4. The header cache file for the source file does not exist.
    //
    //     The action to be taken is to recompile the source file, regenerating
    //     the header cache file in the process.
    //
    //   o An executable file is added to the DAG if one of its object files
    //     are, or if a target upon which it depends is added to the DAG.
    //
    //     The action to be taken is to relink the executable file.
    //
    //   o A null node is added to the DAG if a target without an output file
    //     must be updated. There is no action taken.

    // Initialize the leaf list first.

    TlInitializeList ( &BtLeafListHead )

    // Initialize the created path hash set.

    TlInitializeHashTable ( &BtCreatedPathHashTable )

    BtCreatedPathMutex = TlCreateMutex ()

    BtActionMutex = TlCreateMutex ()

    dagroot := BtBuildDagForTarget ( BtSelectedTarget )

    IF BtCleanUp THEN
        // Just cleaning up. We're done already.

        LEAVE
    END

    IF NOT dagroot THEN
        TlPrint ( "The target is already up to date.\n" )

        LEAVE
    END

    // Now we have a dependency DAG, and a list of leaf nodes (i.e., nodes that
    // have zero out-edges). In order to process this DAG, we need to spawn the
    // maximum number of worker threads specified by the jobs= argument. These
    // worker threads will spin a loop popping items from the leaf list and
    // processing them. After processing, the leaf node will be removed from the
    // DAG, thereby creating more leaf nodes. This is repeated until the DAG is
    // emptied.

    // Set the termination handler.

    TlSetTerminationHandler ( &BtTerminationHandler )

    // Set up the leaf list mutex.

    BtLeafListMutex = TlCreateMutex ()

    // Set up the leaf count semaphore.

    BtLeafSemaphore = TlCreateSemaphore ( 1 )

    // Set up the printing mutex.

    BtPrintMutex = TlCreateMutex ()

    IF BtJobCount == 1 THEN
        // Directly call the worker thread entrypoint in the context of this
        // thread.

        BtWorkerThread ( NULLPTR )
    
    ELSE
        // Create each worker thread and then wait for termination for each.

        table : ^^VOID

        status := TlBumpAlloc (
            SIZEOF ^VOID * BtJobCount, // bytes
            OUT table, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate job table", 0, 0, 0 )
        END

        i := 0

        WHILE i < BtJobCount DO
            status = TlCreateThread (
                &BtWorkerThread, // startroutine
                NULLPTR, // arg
                OUT table[i], // thread
            )

            IF status THEN
                TlInternalError ( "Failed to create worker thread", 0, 0, 0 )
            END

            i += 1
        END

        // Now wait for termination.

        i = 0

        WHILE i < BtJobCount DO
            TlJoinThread ( table[i] )

            i += 1
        END
    END

    IF BtUseDiskTool AND BtDiskToolUpdateBuffer.Count THEN
        BtUpdateDiskImage ()
    END
END