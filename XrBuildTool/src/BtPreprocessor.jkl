//
// Inline preprocessor for the lexer. Invoked when the tokenizer stumbles on a
// '#' character inbetween tokens.
//

#INCLUDE "Bt.hjk"

PUBLIC LexExposedMacroListHead : TlListEntry

#INCLUDE "../../Cf/CfLexPreprocessor.jkl"

FN (LexDirectiveParseF) LexParseDepend ()

    // Same as include, but we create a new macro scope for the duration of the
    // included file. This allows it to overlay the macros created in the outer
    // scope if it wants to override them.
    //
    // Note: Added for Build Tool support.

    oldstream := LexCurrentStream

    LexParseInclude ()

    stream := LexCurrentStream

    IF stream == oldstream THEN
        // The include directive didn't bother to actually include the file.

        LEAVE
    END

    stream^.LastMacroScope = LexCurrentMacroScope

    LexCurrentMacroScope = LexCreateMacroTable ( LexCurrentMacroScope )
END

FN (LexDirectiveParseF) LexParseExpose ()

    // Parse an EXPOSE keyword.

    // Note: Added for Build Tool support.

    buffer : UBYTE[LEX_DIRECTIVE_MAX]
    token : LexToken

    LexCollectDirectiveToken (
        &token, // token
        &buffer[0], // buffer
    )

    IF LexFalseCount THEN
        // We're being compiled out, just return.

        LEAVE
    END

    macro := CAST TlLookupSymbolTable (
        LexCurrentMacroScope, // symboltable
        &buffer[0], // name
    ) TO ^LexMacro

    IF NOT macro THEN
        // Wasn't defined anyway.

        LEAVE
    END

    IF macro^.IsExposed OR NOT macro^.CanBeExposed THEN
        // Already exposed.

        LEAVE
    END

    macro^.IsExposed = TRUE

    TlInsertAtTailList (
        &LexExposedMacroListHead, // head
        &macro^.ExposedMacroEntry, // entry
    )
END

FN LexInitializePreprocessorConsumer ()

    // Perform consumer-specific part of initialization.

    // Initialize the exposed macro list head.

    TlInitializeList ( &LexExposedMacroListHead )

    LexInsertDirective ( "DEPEND", &LexParseDepend )
    LexInsertDirective ( "EXPOSE", &LexParseExpose )
END