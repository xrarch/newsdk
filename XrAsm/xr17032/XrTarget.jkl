//
// Implements target-specific code for XR/17032 assembly.
//

#INCLUDE "<inc>/Asm.hjk"

// FORWARD
EXTERN FN (AsmTargetKeywordsF) XrRegisterKeywords ()

// FORWARD
EXTERN FN (AsmTargetParseF) XrParseInstruction (
    IN token : ^LexToken,
)

// FORWARD
EXTERN FN (AsmTargetEncodeF) XrEncodeInstruction (
    IN instruction : ^AsmElement,
    IN section : ^AsmSection,
    IN dataptr : ^UBYTE,
)

PUBLIC XrTargetInfo : AsmTargetInfoRecord = {
    [Name] = "xr17032",
    [KeywordsFunc] = &XrRegisterKeywords,
    [ParseFunc] = &XrParseInstruction,
    [EncodeFunc] = &XrEncodeInstruction,
    [ConstantMask] = 0xFFFFFFFF,
    [PointerSize] = 4,
    [ObjectFileAlignment] = 4,
    [ArchitectureCode] = XLO_ARCHITECTURE_XR17032,
}

ENUM XrInstructionSubtype : LexTokenSubtype
    // Real instructions

    XR_JAL,
    XR_J,

    XR_BEQ,
    XR_BNE,
    XR_BLT,
    XR_BGT,
    XR_BLE,
    XR_BGE,
    XR_BPE,
    XR_BPO,

    XR_ADDI,
    XR_SUBI,
    XR_SLTI,
    XR_ANDI,
    XR_XORI,
    XR_ORI,
    XR_LUI,

    XR_MOV,
    XR_JALR,
    XR_ADR,

    XR_LSH,
    XR_RSH,
    XR_ASH,
    XR_ROR,
    
    XR_ADD,
    XR_SUB,
    XR_SLT,
    XR_AND,
    XR_XOR,
    XR_OR,
    XR_NOR,

    XR_MUL,
    XR_DIV,
    XR_MOD,

    XR_LL,
    XR_SC,

    XR_PAUSE,

    XR_MB,
    XR_WMB,
    XR_BRK,
    XR_SYS,

    XR_MFCR,
    XR_MTCR,

    XR_HLT,
    XR_RFE,

    // Pseudo-instructions

    XR_B,
    XR_RET,
    XR_JR,
    XR_LI,
    XR_LA,
    XR_NOP,

    XR_LSHI,
    XR_RSHI,
    XR_ASHI,
    XR_RORI,

    // "Virtual" instruction codes

    XR_SLTI_SIGNED,
    XR_SLT_SIGNED,
    XR_DIV_SIGNED,

    XR_INSTRUCTION_MAX,
END

ENUM XrAuxSubtype : LexTokenSubtype
    XR_AUX_TMP,

    XR_AUX_BYTE,
    XR_AUX_INT,
    XR_AUX_LONG,

    XR_AUX_SIGNED,

    XR_AUX_SHIFT,

    XR_AUX_MAX,
END

FN (AsmTargetKeywordsF) XrRegisterKeywords ()

    // Register all of the instruction keywords.
    // These are keywords that cause the target independent parser to dispatch
    // to us.

    LexInsertKeyword ( "jal", TOKEN_INSTRUCTION, XR_JAL, 0 )
    LexInsertKeyword ( "j", TOKEN_INSTRUCTION, XR_J, 0 )

    LexInsertKeyword ( "beq", TOKEN_INSTRUCTION, XR_BEQ, 0 )
    LexInsertKeyword ( "bne", TOKEN_INSTRUCTION, XR_BNE, 0 )
    LexInsertKeyword ( "blt", TOKEN_INSTRUCTION, XR_BLT, 0 )
    LexInsertKeyword ( "bgt", TOKEN_INSTRUCTION, XR_BGT, 0 )
    LexInsertKeyword ( "ble", TOKEN_INSTRUCTION, XR_BLE, 0 )
    LexInsertKeyword ( "bge", TOKEN_INSTRUCTION, XR_BGE, 0 )
    LexInsertKeyword ( "bpe", TOKEN_INSTRUCTION, XR_BPE, 0 )
    LexInsertKeyword ( "bpo", TOKEN_INSTRUCTION, XR_BPO, 0 )

    LexInsertKeyword ( "addi", TOKEN_INSTRUCTION, XR_ADDI, 0 )
    LexInsertKeyword ( "subi", TOKEN_INSTRUCTION, XR_SUBI, 0 )
    LexInsertKeyword ( "slti", TOKEN_INSTRUCTION, XR_SLTI, 0 )
    LexInsertKeyword ( "andi", TOKEN_INSTRUCTION, XR_ANDI, 0 )
    LexInsertKeyword ( "xori", TOKEN_INSTRUCTION, XR_XORI, 0 )
    LexInsertKeyword ( "ori", TOKEN_INSTRUCTION, XR_ORI, 0 )
    LexInsertKeyword ( "lui", TOKEN_INSTRUCTION, XR_LUI, 0 )

    LexInsertKeyword ( "mov", TOKEN_INSTRUCTION, XR_MOV, 0 )
    LexInsertKeyword ( "jalr", TOKEN_INSTRUCTION, XR_JALR, 0 )
    LexInsertKeyword ( "adr", TOKEN_INSTRUCTION, XR_ADR, 0 )

    LexInsertKeyword ( "lsh", TOKEN_INSTRUCTION, XR_LSH, 0 )
    LexInsertKeyword ( "rsh", TOKEN_INSTRUCTION, XR_RSH, 1 )
    LexInsertKeyword ( "ash", TOKEN_INSTRUCTION, XR_ASH, 2 )
    LexInsertKeyword ( "ror", TOKEN_INSTRUCTION, XR_ROR, 3 )

    LexInsertKeyword ( "add", TOKEN_INSTRUCTION, XR_ADD, 0 )
    LexInsertKeyword ( "sub", TOKEN_INSTRUCTION, XR_SUB, 0 )
    LexInsertKeyword ( "slt", TOKEN_INSTRUCTION, XR_SLT, 0 )
    LexInsertKeyword ( "and", TOKEN_INSTRUCTION, XR_AND, 0 )
    LexInsertKeyword ( "xor", TOKEN_INSTRUCTION, XR_XOR, 0 )
    LexInsertKeyword ( "or", TOKEN_INSTRUCTION, XR_OR, 0 )
    LexInsertKeyword ( "nor", TOKEN_INSTRUCTION, XR_NOR, 0 )

    LexInsertKeyword ( "mul", TOKEN_INSTRUCTION, XR_MUL, 0 )
    LexInsertKeyword ( "div", TOKEN_INSTRUCTION, XR_DIV, 0 )
    LexInsertKeyword ( "mod", TOKEN_INSTRUCTION, XR_MOD, 0 )

    LexInsertKeyword ( "ll", TOKEN_INSTRUCTION, XR_LL, 0 )
    LexInsertKeyword ( "sc", TOKEN_INSTRUCTION, XR_SC, 0 )

    LexInsertKeyword ( "pause", TOKEN_INSTRUCTION, XR_PAUSE, 0 )

    LexInsertKeyword ( "mb", TOKEN_INSTRUCTION, XR_MB, 0 )
    LexInsertKeyword ( "wmb", TOKEN_INSTRUCTION, XR_WMB, 0 )
    LexInsertKeyword ( "brk", TOKEN_INSTRUCTION, XR_BRK, 0 )
    LexInsertKeyword ( "sys", TOKEN_INSTRUCTION, XR_SYS, 0 )

    LexInsertKeyword ( "mfcr", TOKEN_INSTRUCTION, XR_MFCR, 0 )
    LexInsertKeyword ( "mtcr", TOKEN_INSTRUCTION, XR_MTCR, 0 )

    LexInsertKeyword ( "hlt", TOKEN_INSTRUCTION, XR_HLT, 0 )
    LexInsertKeyword ( "rfe", TOKEN_INSTRUCTION, XR_RFE, 0 )

    // Pseudo-instructions

    LexInsertKeyword ( "b", TOKEN_INSTRUCTION, XR_B, 0 )
    LexInsertKeyword ( "ret", TOKEN_INSTRUCTION, XR_RET, 0 )
    LexInsertKeyword ( "jr", TOKEN_INSTRUCTION, XR_JR, 0 )
    LexInsertKeyword ( "li", TOKEN_INSTRUCTION, XR_LI, 0 )
    LexInsertKeyword ( "la", TOKEN_INSTRUCTION, XR_LA, 0 )
    LexInsertKeyword ( "nop", TOKEN_INSTRUCTION, XR_NOP, 0 )

    LexInsertKeyword ( "lshi", TOKEN_INSTRUCTION, XR_LSHI, 0 )
    LexInsertKeyword ( "rshi", TOKEN_INSTRUCTION, XR_RSHI, 1 )
    LexInsertKeyword ( "ashi", TOKEN_INSTRUCTION, XR_ASHI, 2 )
    LexInsertKeyword ( "rori", TOKEN_INSTRUCTION, XR_RORI, 3 )

    // Registers

    LexInsertKeyword ( "zero", TOKEN_REGISTER, 0, 0 )
    LexInsertKeyword ( "t0", TOKEN_REGISTER, 0, 1 )
    LexInsertKeyword ( "t1", TOKEN_REGISTER, 0, 2 )
    LexInsertKeyword ( "t2", TOKEN_REGISTER, 0, 3 )
    LexInsertKeyword ( "t3", TOKEN_REGISTER, 0, 4 )
    LexInsertKeyword ( "t4", TOKEN_REGISTER, 0, 5 )
    LexInsertKeyword ( "t5", TOKEN_REGISTER, 0, 6 )
    LexInsertKeyword ( "a0", TOKEN_REGISTER, 0, 7 )
    LexInsertKeyword ( "a1", TOKEN_REGISTER, 0, 8 )
    LexInsertKeyword ( "a2", TOKEN_REGISTER, 0, 9 )
    LexInsertKeyword ( "a3", TOKEN_REGISTER, 0, 10 )
    LexInsertKeyword ( "s0", TOKEN_REGISTER, 0, 11 )
    LexInsertKeyword ( "s1", TOKEN_REGISTER, 0, 12 )
    LexInsertKeyword ( "s2", TOKEN_REGISTER, 0, 13 )
    LexInsertKeyword ( "s3", TOKEN_REGISTER, 0, 14 )
    LexInsertKeyword ( "s4", TOKEN_REGISTER, 0, 15 )
    LexInsertKeyword ( "s5", TOKEN_REGISTER, 0, 16 )
    LexInsertKeyword ( "s6", TOKEN_REGISTER, 0, 17 )
    LexInsertKeyword ( "s7", TOKEN_REGISTER, 0, 18 )
    LexInsertKeyword ( "s8", TOKEN_REGISTER, 0, 19 )
    LexInsertKeyword ( "s9", TOKEN_REGISTER, 0, 20 )
    LexInsertKeyword ( "s10", TOKEN_REGISTER, 0, 21 )
    LexInsertKeyword ( "s11", TOKEN_REGISTER, 0, 22 )
    LexInsertKeyword ( "s12", TOKEN_REGISTER, 0, 23 )
    LexInsertKeyword ( "s13", TOKEN_REGISTER, 0, 24 )
    LexInsertKeyword ( "s14", TOKEN_REGISTER, 0, 25 )
    LexInsertKeyword ( "s15", TOKEN_REGISTER, 0, 26 )
    LexInsertKeyword ( "s16", TOKEN_REGISTER, 0, 27 )
    LexInsertKeyword ( "s17", TOKEN_REGISTER, 0, 28 )
    LexInsertKeyword ( "tp", TOKEN_REGISTER, 0, 29 )
    LexInsertKeyword ( "sp", TOKEN_REGISTER, 0, 30 )
    LexInsertKeyword ( "lr", TOKEN_REGISTER, 0, 31 )

    // Control registers

    LexInsertKeyword ( "rs", TOKEN_CONTROL_REGISTER, 0, 0 )
    LexInsertKeyword ( "whami", TOKEN_CONTROL_REGISTER, 0, 1 )

    LexInsertKeyword ( "eb", TOKEN_CONTROL_REGISTER, 0, 5 )
    LexInsertKeyword ( "epc", TOKEN_CONTROL_REGISTER, 0, 6 )
    LexInsertKeyword ( "ebadaddr", TOKEN_CONTROL_REGISTER, 0, 7 )

    LexInsertKeyword ( "tbmissaddr", TOKEN_CONTROL_REGISTER, 0, 9 )
    LexInsertKeyword ( "tbpc", TOKEN_CONTROL_REGISTER, 0, 10 )

    LexInsertKeyword ( "scratch0", TOKEN_CONTROL_REGISTER, 0, 11 )
    LexInsertKeyword ( "scratch1", TOKEN_CONTROL_REGISTER, 0, 12 )
    LexInsertKeyword ( "scratch2", TOKEN_CONTROL_REGISTER, 0, 13 )
    LexInsertKeyword ( "scratch3", TOKEN_CONTROL_REGISTER, 0, 14 )
    LexInsertKeyword ( "scratch4", TOKEN_CONTROL_REGISTER, 0, 15 )

    LexInsertKeyword ( "itbpte", TOKEN_CONTROL_REGISTER, 0, 16 )
    LexInsertKeyword ( "itbtag", TOKEN_CONTROL_REGISTER, 0, 17 )
    LexInsertKeyword ( "itbindex", TOKEN_CONTROL_REGISTER, 0, 18 )
    LexInsertKeyword ( "itbctrl", TOKEN_CONTROL_REGISTER, 0, 19 )
    LexInsertKeyword ( "icachectrl", TOKEN_CONTROL_REGISTER, 0, 20 )
    LexInsertKeyword ( "itbaddr", TOKEN_CONTROL_REGISTER, 0, 21 )

    LexInsertKeyword ( "dtbpte", TOKEN_CONTROL_REGISTER, 0, 24 )
    LexInsertKeyword ( "dtbtag", TOKEN_CONTROL_REGISTER, 0, 25 )
    LexInsertKeyword ( "dtbindex", TOKEN_CONTROL_REGISTER, 0, 26 )
    LexInsertKeyword ( "dtbctrl", TOKEN_CONTROL_REGISTER, 0, 27 )
    LexInsertKeyword ( "dcachectrl", TOKEN_CONTROL_REGISTER, 0, 28 )
    LexInsertKeyword ( "dtbaddr", TOKEN_CONTROL_REGISTER, 0, 29 )

    // Syntactic junk

    LexInsertKeyword ( "tmp", TOKEN_AUX, XR_AUX_TMP, 0 )

    LexInsertKeyword ( "byte", TOKEN_SIZE_SPECIFIER, XR_AUX_BYTE, 0 )
    LexInsertKeyword ( "int", TOKEN_SIZE_SPECIFIER, XR_AUX_INT, 0 )
    LexInsertKeyword ( "long", TOKEN_SIZE_SPECIFIER, XR_AUX_LONG, 0 )

    LexInsertKeyword ( "signed", TOKEN_AUX, XR_AUX_SIGNED, 0 )

    LexInsertKeyword ( "LSH", TOKEN_AUX, XR_AUX_SHIFT, 0 )
    LexInsertKeyword ( "RSH", TOKEN_AUX, XR_AUX_SHIFT, 1 )
    LexInsertKeyword ( "ASH", TOKEN_AUX, XR_AUX_SHIFT, 2 )
    LexInsertKeyword ( "ROR", TOKEN_AUX, XR_AUX_SHIFT, 3 )
END

XrImmLoadOpcode : UBYTE[XR_AUX_MAX] = {
    [XR_AUX_BYTE] = 0x3B,
    [XR_AUX_INT] = 0x33,
    [XR_AUX_LONG] = 0x2B,
}

XrImmStoreOpcode : UBYTE[XR_AUX_MAX] = {
    [XR_AUX_BYTE] = 0x3A,
    [XR_AUX_INT] = 0x32,
    [XR_AUX_LONG] = 0x2A,
}

XrImmStoreImmOpcode : UBYTE[XR_AUX_MAX] = {
    [XR_AUX_BYTE] = 0x1A,
    [XR_AUX_INT] = 0x12,
    [XR_AUX_LONG] = 0x0A,
}

XrRegLoadFunctionCode : UBYTE[XR_AUX_MAX] = {
    [XR_AUX_BYTE] = 0xF,
    [XR_AUX_INT] = 0xE,
    [XR_AUX_LONG] = 0xD,
}

XrRegStoreFunctionCode : UBYTE[XR_AUX_MAX] = {
    [XR_AUX_BYTE] = 0xB,
    [XR_AUX_INT] = 0xA,
    [XR_AUX_LONG] = 0x9,
}

XrSubtypeToOpcode : UBYTE[XR_INSTRUCTION_MAX] = {
    [XR_JAL] = 0x07,
    [XR_J] = 0x06,

    [XR_BEQ] = 0x3D,
    [XR_BNE] = 0x35,
    [XR_BLT] = 0x2D,
    [XR_BGT] = 0x25,
    [XR_BLE] = 0x1D,
    [XR_BGE] = 0x15,
    [XR_BPE] = 0x0D,
    [XR_BPO] = 0x05,

    [XR_ADDI] = 0x3C,
    [XR_SUBI] = 0x34,
    [XR_SLTI] = 0x2C,
    [XR_SLTI_SIGNED] = 0x24,
    [XR_ANDI] = 0x1C,
    [XR_XORI] = 0x14,
    [XR_ORI] = 0x0C,
    [XR_LUI] = 0x04,

    [XR_JALR] = 0x38,
    [XR_ADR] = 0x30,

    [XR_LSH] = 0x39,
    [XR_RSH] = 0x39,
    [XR_ASH] = 0x39,
    [XR_ROR] = 0x39,

    [XR_ADD] = 0x39,
    [XR_SUB] = 0x39,
    [XR_SLT] = 0x39,
    [XR_SLT_SIGNED] = 0x39,
    [XR_AND] = 0x39,
    [XR_XOR] = 0x39,
    [XR_OR] = 0x39,
    [XR_NOR] = 0x39,

    [XR_MUL] = 0x31,
    [XR_DIV] = 0x31,
    [XR_DIV_SIGNED] = 0x31,
    [XR_MOD] = 0x31,

    [XR_SC] = 0x31,

    [XR_PAUSE] = 0x31,
    
    [XR_MB] = 0x31,
    [XR_WMB] = 0x31,
    [XR_BRK] = 0x31,
    [XR_SYS] = 0x31,

    [XR_HLT] = 0x29,
    [XR_RFE] = 0x29,

    // Pseudo-instructions

    [XR_NOP] = 0x39,
}

XrSubtypeToFunctionCode : UBYTE[XR_INSTRUCTION_MAX] = {
    // Note that LSH, RSH, ASH, ROR share a function code of 0x8.

    [XR_ADD] = 0x7,
    [XR_SUB] = 0x6,
    [XR_SLT] = 0x5,
    [XR_SLT_SIGNED] = 0x4,
    [XR_AND] = 0x3,
    [XR_XOR] = 0x2,
    [XR_OR] = 0x1,
    [XR_NOR] = 0x0,

    [XR_MUL] = 0xF,
    [XR_DIV] = 0xD,
    [XR_DIV_SIGNED] = 0xC,
    [XR_MOD] = 0xB,

    [XR_SC] = 0x8,
    
    [XR_PAUSE] = 0x6,

    [XR_MB] = 0x3,
    [XR_WMB] = 0x2,
    [XR_BRK] = 0x1,
    [XR_SYS] = 0x0,

    [XR_HLT] = 0xC,
    [XR_RFE] = 0xB,

    // Pseudo-instructions

    [XR_NOP] = 0x1, // OR
}

FN XrCollectShiftAmount () : UWORD

    // Collect and return a 5-bit shift amount.

    shiftamt := AsmParseAtom ()

    dumpster : ^VOID

    val : UWORD

    AsmEvaluateNodeMustWork (
        shiftamt, // node
        OUT val, // value
        OUT dumpster, // refsymbol
    )

    IF val > 31 THEN
        LexError ( &shiftamt^.Token, "Shift amount must be 0-31\n", )
    END

    RETURN val
END

FNPTR XrInstructionMnemonicF (
    IN token : ^LexToken,
) : ^AsmElement

FN (XrInstructionMnemonicF) XrParseJumpFormat (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse an absolute jump format instruction.

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    immexpr := AsmParseAtom ()

    elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
        TOKEN_RIGHTSHIFT, // operator
        immexpr, // left
        2, // constant
        EVAL_ERROR, // warnlevel
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_JUMP
    elem^.Body.Xr.Opcode = XrSubtypeToOpcode[token^.Subtype]

    // Could cause a relocation, so note that.

    elem^.RelocationType = XLO_RELOC_XR17032_ABSJ

    RETURN elem
END

FN (XrInstructionMnemonicF) XrParseBranchFormat (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse a branch format instruction.

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_BRANCH
    elem^.Body.Xr.Opcode = XrSubtypeToOpcode[token^.Subtype]

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegA = reg.TypeContext

    AsmConsumeComma ()

    // Note that here we store the expression in an "absolute" form, but
    // the encoding stage is sure to turn it into a relative branch offset.

    elem^.Body.Xr.ImmExpr = AsmParseAtom ()

    RETURN elem
END

FN (XrInstructionMnemonicF) XrParseImmFormat (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse an imm format instruction.

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_IMM
    elem^.Body.Xr.Opcode = XrSubtypeToOpcode[token^.Subtype]

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegA = reg.TypeContext

    AsmConsumeComma ()

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegB = reg.TypeContext

    AsmConsumeComma ()

    elem^.Body.Xr.ImmExpr = AsmParseAtom ()

    RETURN elem
END

FN (XrInstructionMnemonicF) XrParseSlti (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse an SLTI [SIGNED] instruction.

    IF LexMatchToken (
        NULLPTR, // token
        TOKEN_AUX, // type
        XR_AUX_SIGNED, // subtype
    ) THEN
        // It's the signed variant, so fiddle the subtype.

        token^.Subtype = XR_SLTI_SIGNED
    END

    RETURN XrParseImmFormat ( token )
END

FN (XrInstructionMnemonicF) XrParseLui (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse an LUI instruction.

    elem := XrParseImmFormat ( token )

    // Wrap the immediate in a right shift by 16 bits.

    elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
        TOKEN_RIGHTSHIFT, // operator
        elem^.Body.Xr.ImmExpr, // left
        16, // constant
        EVAL_ERROR, // warnlevel
    )
END

FN (XrInstructionMnemonicF) XrParseJalr (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse a JALR instruction.

    elem := XrParseImmFormat ( token )

    // Wrap the immediate in a right shift by 2 bits.

    elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
        TOKEN_RIGHTSHIFT, // operator
        elem^.Body.Xr.ImmExpr, // left
        2, // constant
        EVAL_ERROR, // warnlevel
    )
END

FN (XrInstructionMnemonicF) XrParseAdr (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse ADR.

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_IMM
    elem^.Body.Xr.Opcode = XrSubtypeToOpcode[token^.Subtype]

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegA = reg.TypeContext

    elem^.Body.Xr.RegB = 0

    AsmConsumeComma ()

    elem^.Body.Xr.ImmExpr = AsmParseAtom ()

    // Wrap the immediate in a right shift by 16 bits.

    elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
        TOKEN_RIGHTSHIFT, // operator
        elem^.Body.Xr.ImmExpr, // left
        16, // constant
        EVAL_ERROR, // warnlevel
    )

    RETURN elem
END

FN XrParseMovLoad (
    IN elem : ^AsmElement,
    IN token : ^LexToken,
)

    // Parse the load cases of MOV.

    elem^.Body.Xr.RegA = token^.TypeContext

    sizetok : LexToken

    LexGetToken ( &sizetok )

    IF sizetok.Type == TOKEN_REGISTER THEN
        // Actually a reg-to-reg MOV.
        // Turn this into ADDI RA, RB, 0.

        elem^.Body.Xr.ImmExpr = NULLPTR
        elem^.Body.Xr.Opcode = 0x3C // ADDI
        elem^.Body.Xr.RegB = sizetok.TypeContext
        elem^.Body.Xr.FormatType = XR_FORMAT_IMM

        LEAVE
    END

    IF sizetok.Type != TOKEN_SIZE_SPECIFIER THEN
        LexError ( &sizetok, "Expected register or size specifier\n", )
    END

    rbtoken : LexToken

    IF NOT LexMatchToken (
        &rbtoken, // token
        TOKEN_LBRACKET, // type
        0, // subtype
    ) THEN
        LexError ( &rbtoken, "Expected left bracket\n", )
    END

    IF LexMatchToken (
        &rbtoken, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        elem^.Body.Xr.RegB = rbtoken.TypeContext

        // This is an offsetted load from a register.
        // If there's no plus, then this is an offset by an immediate value of
        // zero. If there is, and it is followed by a register, then it is an
        // offset by a register. If there's no shift type after the register,
        // then it's a left shift by zero. Otherwise, there's some type of shift
        // by a small immediate.

        IF LexMatchToken (
            &rbtoken, // token
            TOKEN_OPER, // type
            TOKEN_PLUS, // subtype
        ) THEN
            // Offset by something.

            IF LexMatchToken (
                &rbtoken, // token
                TOKEN_REGISTER, // type
                0, // subtype
            ) THEN
                // Offset by register.

                elem^.Body.Xr.FormatType = XR_FORMAT_REG
                elem^.Body.Xr.RegC = rbtoken.TypeContext
                elem^.Body.Xr.ShiftType = 0
                elem^.Body.Xr.ShiftAmount = 0

                // Check if there's a shift.

                IF LexMatchToken (
                    &rbtoken, // token
                    TOKEN_AUX, // type
                    XR_AUX_SHIFT, // subtype
                ) THEN
                    // There be a shift.

                    elem^.Body.Xr.ShiftType = rbtoken.TypeContext

                    // Collect the shift amount.

                    elem^.Body.Xr.ShiftAmount = XrCollectShiftAmount ()
                END

                // Consume the right bracket.

                IF NOT LexMatchToken (
                    &rbtoken, // token
                    TOKEN_RBRACKET, // type
                    0, // subtype
                ) THEN
                    LexError ( &rbtoken, "Expected right bracket\n", )
                END

                // Set the opcode.

                elem^.Body.Xr.Opcode = 0x39

                elem^.Body.Xr.FunctionCode =
                    XrRegLoadFunctionCode[sizetok.Subtype]

                LEAVE
            END

            // Offset by immediate expression.

            elem^.Body.Xr.ImmExpr = AsmParseAtom ()
            elem^.Body.Xr.Opcode = XrImmLoadOpcode[sizetok.Subtype]
            elem^.Body.Xr.FormatType = XR_FORMAT_IMM

            // Consume the right bracket.

            IF NOT LexMatchToken (
                &rbtoken, // token
                TOKEN_RBRACKET, // type
                0, // subtype
            ) THEN
                LexError ( &rbtoken, "Expected right bracket\n", )
            END

            // Create a shift on the immediate value so that it is encoded
            // correctly.

            IF sizetok.Subtype == XR_AUX_INT THEN
                elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
                    TOKEN_RIGHTSHIFT, // operator
                    elem^.Body.Xr.ImmExpr, // left
                    1, // constant
                    EVAL_ERROR, // warnlevel
                )

            ELSEIF sizetok.Subtype == XR_AUX_LONG THEN
                elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
                    TOKEN_RIGHTSHIFT, // operator
                    elem^.Body.Xr.ImmExpr, // left
                    2, // constant
                    EVAL_ERROR, // warnlevel
                )
            END

            LEAVE
        END

        // Offset by immediate value of zero.

        elem^.Body.Xr.ImmExpr = NULLPTR
        elem^.Body.Xr.Opcode = XrImmLoadOpcode[sizetok.Subtype]
        elem^.Body.Xr.FormatType = XR_FORMAT_IMM

        // Consume the right bracket.

        IF NOT LexMatchToken (
            &rbtoken, // token
            TOKEN_RBRACKET, // type
            0, // subtype
        ) THEN
            LexError ( &rbtoken, "Expected right bracket\n", )
        END

        LEAVE
    END

    // Must be an inline load.
    //
    // This is actually the following sequence, which we must generate as a
    // series of AsmElements:
    //
    //     LUI RA, ZERO, IMM >> 16
    //     MOV RA, BYTE/INT/LONG [RA + ((IMM & 0xFFFF) >> 0/1/2)]

    // First parse the immediate expression.

    immexpr := AsmParseAtom ()

    // Consume the right bracket.

    IF NOT LexMatchToken (
        &rbtoken, // token
        TOKEN_RBRACKET, // type
        0, // subtype
    ) THEN
        LexError ( &rbtoken, "Expected right bracket\n", )
    END

    // Now initialize the LUI instruction.

    elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
        TOKEN_RIGHTSHIFT, // operator
        immexpr, // left
        16, // constant
        EVAL_NO_WARNING, // warnlevel
    )

    elem^.Body.Xr.Opcode = 0x04 // LUI
    elem^.Body.Xr.RegB = 0 // ZERO
    elem^.Body.Xr.FormatType = XR_FORMAT_IMM

    // Now create the load instruction.

    elem2 := AsmCreateElement (
        &elem^.ErrorToken, // token
        4, // size
    )

    elem2^.Body.Xr.RegA = elem^.Body.Xr.RegA
    elem2^.Body.Xr.RegB = elem^.Body.Xr.RegA
    elem2^.Body.Xr.FormatType = XR_FORMAT_IMM

    elem2^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
        TOKEN_BITAND, // operator
        immexpr, // left
        0xFFFF, // constant
        EVAL_NO_WARNING, // warnlevel
    )

    // Set the opcode and a right shift according to the size type.
    // Note that we also need to annotate that there's a possible relocation
    // here, on the LUI instruction, since thats the first one.

    elem2^.Body.Xr.Opcode = XrImmLoadOpcode[sizetok.Subtype]

    IF sizetok.Subtype == XR_AUX_BYTE THEN
        elem^.RelocationType = XLO_RELOC_XR17032_LA

    ELSEIF sizetok.Subtype == XR_AUX_INT THEN
        elem^.RelocationType = XLO_RELOC_XR17032_FAR_INT

        elem2^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
            TOKEN_RIGHTSHIFT, // operator
            elem2^.Body.Xr.ImmExpr, // left
            1, // constant
            EVAL_ERROR, // warnlevel
        )

    ELSEIF sizetok.Subtype == XR_AUX_LONG THEN
        elem^.RelocationType = XLO_RELOC_XR17032_FAR_LONG

        elem2^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
            TOKEN_RIGHTSHIFT, // operator
            elem2^.Body.Xr.ImmExpr, // left
            2, // constant
            EVAL_ERROR, // warnlevel
        )
    END
END

FN XrParseMovStore (
    IN elem : ^AsmElement,
    IN sizetok : ^LexToken,
)

    // Parse the store cases of MOV.

    rbtoken : LexToken

    IF NOT LexMatchToken (
        &rbtoken, // token
        TOKEN_LBRACKET, // type
        0, // subtype
    ) THEN
        LexError ( &rbtoken, "Expected left bracket\n", )
    END

    IF LexMatchToken (
        &rbtoken, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        basereg := rbtoken.TypeContext

        // This is an offsetted store from a register.
        // If there's no plus, then this is an offset by an immediate value of
        // zero. If there is, and it is followed by a register, then it is an
        // offset by a register. If there's no shift type after the register,
        // then it's a left shift by zero. Otherwise, there's some type of shift
        // by a small immediate.

        IF LexMatchToken (
            &rbtoken, // token
            TOKEN_OPER, // type
            TOKEN_PLUS, // subtype
        ) THEN
            // Offset by something.

            IF LexMatchToken (
                &rbtoken, // token
                TOKEN_REGISTER, // type
                0, // subtype
            ) THEN
                // Offset by register.

                elem^.Body.Xr.FormatType = XR_FORMAT_REG
                elem^.Body.Xr.RegC = rbtoken.TypeContext
                elem^.Body.Xr.ShiftType = 0
                elem^.Body.Xr.ShiftAmount = 0

                // Check if there's a shift.

                IF LexMatchToken (
                    &rbtoken, // token
                    TOKEN_AUX, // type
                    XR_AUX_SHIFT, // subtype
                ) THEN
                    // There be a shift.

                    elem^.Body.Xr.ShiftType = rbtoken.TypeContext

                    // Collect the shift amount.

                    elem^.Body.Xr.ShiftAmount = XrCollectShiftAmount ()
                END

                // Set the opcode.

                elem^.Body.Xr.Opcode = 0x39

                elem^.Body.Xr.FunctionCode =
                    XrRegStoreFunctionCode[sizetok^.Subtype]

            ELSE
                // Offset by immediate expression.

                elem^.Body.Xr.ImmExpr = AsmParseAtom ()
                elem^.Body.Xr.Opcode = XrImmStoreOpcode[sizetok^.Subtype]
                elem^.Body.Xr.FormatType = XR_FORMAT_IMM

                // Create a shift on the immediate value so that it is encoded
                // correctly.

                IF sizetok^.Subtype == XR_AUX_INT THEN
                    elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
                        TOKEN_RIGHTSHIFT, // operator
                        elem^.Body.Xr.ImmExpr, // left
                        1, // constant
                        EVAL_ERROR, // warnlevel
                    )

                ELSEIF sizetok^.Subtype == XR_AUX_LONG THEN
                    elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
                        TOKEN_RIGHTSHIFT, // operator
                        elem^.Body.Xr.ImmExpr, // left
                        2, // constant
                        EVAL_ERROR, // warnlevel
                    )
                END
            END
        
        ELSE
            // Offset by immediate value of zero.

            elem^.Body.Xr.ImmExpr = NULLPTR
            elem^.Body.Xr.Opcode = XrImmStoreOpcode[sizetok^.Subtype]
            elem^.Body.Xr.FormatType = XR_FORMAT_IMM
        END

        // Consume the right bracket.

        IF NOT LexMatchToken (
            &rbtoken, // token
            TOKEN_RBRACKET, // type
            0, // subtype
        ) THEN
            LexError ( &rbtoken, "Expected right bracket\n", )
        END

        // Consume the comma.

        AsmConsumeComma ()

        // Consume the source register.

        IF NOT LexMatchToken (
            &rbtoken, // token
            TOKEN_REGISTER, // type
            0, // subtype
        ) THEN
            IF elem^.Body.Xr.FormatType == XR_FORMAT_IMM THEN
                // It can actually be a short 5-bit immediate.

                shortimm := AsmParseAtom ()

                dumpster : ^VOID

                val : UWORD

                AsmEvaluateNodeMustWork (
                    shortimm, // node
                    OUT val, // value
                    OUT dumpster, // refsymbol
                )

                val &= 0xFFFFFFFF

                IF val > 15 AND val < 0xFFFFFFF0 THEN
                    LexError ( &shortimm^.Token,
                        "Short imm must be in range of -16 to 15\n", )
                END

                elem^.Body.Xr.RegB = val

                elem^.Body.Xr.Opcode = XrImmStoreImmOpcode[sizetok^.Subtype]
                elem^.Body.Xr.RegA = basereg

            ELSE
                LexError ( &rbtoken, "Expected register name\n", )
            END
        
        ELSEIF elem^.Body.Xr.FormatType == XR_FORMAT_IMM THEN
            // For the IMM format stores, the source register goes in the B
            // position.

            elem^.Body.Xr.RegB = rbtoken.TypeContext
            elem^.Body.Xr.RegA = basereg

        ELSE
            // For the REG format stores, the source register goes in the A
            // position. Don't ask me why this is different between the two
            // formats -- ask whatever idiot designed this instruction set.

            elem^.Body.Xr.RegA = rbtoken.TypeContext
            elem^.Body.Xr.RegB = basereg
        END

        LEAVE
    END

    // Must be an inline store.
    //
    // This is actually the following sequence, which we must generate as a
    // series of AsmElements:
    //
    //     LUI REG2, ZERO, IMM >> 16
    //     MOV BYTE/INT/LONG [REG2 + ((IMM & 0xFFFF) >> 1/2/4)], REG1

    // First parse the immediate expression.

    immexpr := AsmParseAtom ()

    // Consume the right bracket.

    IF NOT LexMatchToken (
        &rbtoken, // token
        TOKEN_RBRACKET, // type
        0, // subtype
    ) THEN
        LexError ( &rbtoken, "Expected right bracket\n", )
    END

    // Now create the store instruction.

    elem2 := AsmCreateElement (
        &elem^.ErrorToken, // token
        4, // size
    )

    // Consume the comma.

    AsmConsumeComma ()

    // Consume the source register.

    IF NOT LexMatchToken (
        &rbtoken, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        // It can actually be a short 5-bit immediate.

        shortimm := AsmParseAtom ()

        dumpster : ^VOID

        val : UWORD

        AsmEvaluateNodeMustWork (
            shortimm, // node
            OUT val, // value
            OUT dumpster, // refsymbol
        )

        val &= 0xFFFFFFFF

        IF val > 15 AND val < 0xFFFFFFF0 THEN
            LexError ( &shortimm^.Token,
                "Short imm must be in range of -16 to 15\n", )
        END

        elem2^.Body.Xr.RegB = val

        elem2^.Body.Xr.Opcode = XrImmStoreImmOpcode[sizetok^.Subtype]

    ELSE
        elem2^.Body.Xr.Opcode = XrImmStoreOpcode[sizetok^.Subtype]
        elem2^.Body.Xr.RegB = rbtoken.TypeContext
    END

    // Consume the comma and tmp=.

    AsmConsumeComma ()

    IF NOT LexMatchToken (
        &rbtoken, // token
        TOKEN_AUX, // type
        XR_AUX_TMP, // subtype
    ) THEN
        LexError ( &rbtoken, "Expected tmp=\n", )
    END

    IF NOT LexMatchToken (
        &rbtoken, // token
        TOKEN_EQUALS, // type
        0, // subtype
    ) THEN
        LexError ( &rbtoken, "Expected tmp=\n", )
    END

    // Consume the TMP register.

    IF NOT LexMatchToken (
        &rbtoken, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &rbtoken, "Expected a register\n", )
    END

    elem^.Body.Xr.RegA = rbtoken.TypeContext
    elem2^.Body.Xr.RegA = rbtoken.TypeContext

    // Now initialize the LUI instruction.

    elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
        TOKEN_RIGHTSHIFT, // operator
        immexpr, // left
        16, // constant
        EVAL_NO_WARNING, // warnlevel
    )

    elem^.Body.Xr.Opcode = 0x04 // LUI
    elem^.Body.Xr.RegB = 0 // ZERO
    elem^.Body.Xr.FormatType = XR_FORMAT_IMM

    // Now initialize the store instruction.

    elem2^.Body.Xr.FormatType = XR_FORMAT_IMM

    elem2^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
        TOKEN_BITAND, // operator
        immexpr, // left
        0xFFFF, // constant
        EVAL_NO_WARNING, // warnlevel
    )

    // Set a right shift according to the size type.
    // Note that we also need to annotate that there's a possible relocation
    // here, on the LUI instruction, since thats the first one.

    IF sizetok^.Subtype == XR_AUX_BYTE THEN
        elem^.RelocationType = XLO_RELOC_XR17032_LA

    ELSEIF sizetok^.Subtype == XR_AUX_INT THEN
        elem^.RelocationType = XLO_RELOC_XR17032_FAR_INT

        elem2^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
            TOKEN_RIGHTSHIFT, // operator
            elem2^.Body.Xr.ImmExpr, // left
            1, // constant
            EVAL_ERROR, // warnlevel
        )

    ELSEIF sizetok^.Subtype == XR_AUX_LONG THEN
        elem^.RelocationType = XLO_RELOC_XR17032_FAR_LONG

        elem2^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
            TOKEN_RIGHTSHIFT, // operator
            elem2^.Body.Xr.ImmExpr, // left
            2, // constant
            EVAL_ERROR, // warnlevel
        )
    END
END

FN (XrInstructionMnemonicF) XrParseMov (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse the various MOV instructions.
    //
    // These are:
    //
    // Loads:
    //   MOV RA, BYTE/INT/LONG [RB]
    //   MOV RA, BYTE/INT/LONG [RB + OFF]
    //   MOV RA, BYTE/INT/LONG [RB + RC]
    //   MOV RA, BYTE/INT/LONG [RB + RC xSH VAL]
    //   MOV RA, BYTE/INT/LONG [IMM]
    //     (LA, FAR_INT, or FAR_LONG relocation required)
    //     LUI RA, ZERO, IMM >> 16
    //     MOV RA, BYTE/INT/LONG [RA + ((IMM & 0xFFFF) >> 0/1/2)]
    //   MOV RA, RB
    //
    // Stores:
    //   MOV BYTE/INT/LONG [RB], RA/SIGNEXT(IMM5)
    //   MOV BYTE/INT/LONG [RB + OFF], RA/SIGNEXT(IMM5)
    //   MOV BYTE/INT/LONG [RB + RC], RA
    //   MOV BYTE/INT/LONG [RB + RC xSH VAL], RA
    //   MOV BYTE/INT/LONG [IMM], REG1, TMP=REG2
    //     (LA, FAR_INT, or FAR_LONG relocation required)
    //     LUI REG2, ZERO, IMM >> 16
    //     MOV BYTE/INT/LONG [REG2 + IMM & 0xFFFF], REG1

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    nexttok : LexToken

    LexGetToken ( &nexttok )

    IF nexttok.Type == TOKEN_REGISTER THEN
        // This is a load.

        AsmConsumeComma ()

        XrParseMovLoad (
            elem, // elem
            &nexttok, // token
        )

        RETURN elem
    END

    IF nexttok.Type != TOKEN_SIZE_SPECIFIER THEN
        LexError ( &nexttok, "Expected register or size specifier\n", )
    END

    // This is a store.

    XrParseMovStore (
        elem, // elem
        &nexttok, // sizetok
    )

    RETURN elem
END

FN (XrInstructionMnemonicF) XrParseRegFormat (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse a reg format instruction.

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_REG
    elem^.Body.Xr.Opcode = XrSubtypeToOpcode[token^.Subtype]
    elem^.Body.Xr.FunctionCode = XrSubtypeToFunctionCode[token^.Subtype]
    elem^.Body.Xr.ShiftType = 0
    elem^.Body.Xr.ShiftAmount = 0

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegA = reg.TypeContext

    AsmConsumeComma ()

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegB = reg.TypeContext

    AsmConsumeComma ()

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegC = reg.TypeContext

    // There may be a shift specifier now.

    shifttok : LexToken

    IF LexMatchToken (
        &shifttok, // token
        TOKEN_AUX, // type
        XR_AUX_SHIFT, // subtype
    ) THEN
        elem^.Body.Xr.ShiftType = shifttok.TypeContext

        // Now consume the shift amount.

        elem^.Body.Xr.ShiftAmount = XrCollectShiftAmount ()
    END

    RETURN elem
END

FN (XrInstructionMnemonicF) XrParseSlt (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse an SLT [SIGNED] instruction.

    IF LexMatchToken (
        NULLPTR, // token
        TOKEN_AUX, // type
        XR_AUX_SIGNED, // subtype
    ) THEN
        // It's the signed variant, so fiddle the subtype.

        token^.Subtype = XR_SLT_SIGNED
    END

    RETURN XrParseRegFormat ( token )
END

FN (XrInstructionMnemonicF) XrParseDiv (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse an DIV [SIGNED] instruction.

    IF LexMatchToken (
        NULLPTR, // token
        TOKEN_AUX, // type
        XR_AUX_SIGNED, // subtype
    ) THEN
        // It's the signed variant, so fiddle the subtype.

        token^.Subtype = XR_DIV_SIGNED
    END

    RETURN XrParseRegFormat ( token )
END

FN (XrInstructionMnemonicF) XrParseShiftReg (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse a shift reg instruction.

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_REG
    elem^.Body.Xr.Opcode = 0x39
    elem^.Body.Xr.FunctionCode = 0x8
    elem^.Body.Xr.ShiftType = token^.TypeContext
    elem^.Body.Xr.ShiftAmount = 0

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegA = reg.TypeContext

    AsmConsumeComma ()

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegC = reg.TypeContext

    AsmConsumeComma ()

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegB = reg.TypeContext

    RETURN elem
END

FN (XrInstructionMnemonicF) XrParseShiftImm (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse a shift imm pseudo-instruction.
    // This is really ADD RA, ZERO, RB xSH IMM

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_REG
    elem^.Body.Xr.Opcode = 0x39
    elem^.Body.Xr.FunctionCode = 0x7 // ADD
    elem^.Body.Xr.ShiftType = token^.TypeContext
    elem^.Body.Xr.ShiftAmount = 0
    elem^.Body.Xr.RegB = 0

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegA = reg.TypeContext

    AsmConsumeComma ()

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegC = reg.TypeContext

    AsmConsumeComma ()

    // Now consume the shift amount.

    elem^.Body.Xr.ShiftAmount = XrCollectShiftAmount ()

    RETURN elem
END

FN (XrInstructionMnemonicF) XrParseLoadLocked (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse the LL (load locked) instruction.

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_REG
    elem^.Body.Xr.Opcode = 0x31
    elem^.Body.Xr.FunctionCode = 0x9
    elem^.Body.Xr.RegC = 0
    elem^.Body.Xr.ShiftType = 0
    elem^.Body.Xr.ShiftAmount = 0

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegA = reg.TypeContext

    AsmConsumeComma ()

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegB = reg.TypeContext
END

FN (XrInstructionMnemonicF) XrParseRegNone (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse reg format instructions with no operands.

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_REG
    elem^.Body.Xr.Opcode = XrSubtypeToOpcode[token^.Subtype]
    elem^.Body.Xr.FunctionCode = XrSubtypeToFunctionCode[token^.Subtype]
    elem^.Body.Xr.RegA = 0
    elem^.Body.Xr.RegB = 0
    elem^.Body.Xr.RegC = 0
    elem^.Body.Xr.ShiftType = 0
    elem^.Body.Xr.ShiftAmount = 0
END

FN (XrInstructionMnemonicF) XrParseMfcr (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse MFCR (move from control register).

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_REG
    elem^.Body.Xr.Opcode = 0x29
    elem^.Body.Xr.FunctionCode = 0xF
    elem^.Body.Xr.RegB = 0
    elem^.Body.Xr.ShiftType = 0
    elem^.Body.Xr.ShiftAmount = 0

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegA = reg.TypeContext

    AsmConsumeComma ()

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_CONTROL_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a control register\n", )
    END

    elem^.Body.Xr.RegC = reg.TypeContext
END

FN (XrInstructionMnemonicF) XrParseMtcr (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse MTCR (move to control register).

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_REG
    elem^.Body.Xr.Opcode = 0x29
    elem^.Body.Xr.FunctionCode = 0xE
    elem^.Body.Xr.RegA = 0
    elem^.Body.Xr.ShiftType = 0
    elem^.Body.Xr.ShiftAmount = 0

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_CONTROL_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a control register\n", )
    END

    elem^.Body.Xr.RegC = reg.TypeContext

    AsmConsumeComma ()

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegB = reg.TypeContext
END

FN (XrInstructionMnemonicF) XrParseB (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse a B pseudo-instruction.
    // This is really BEQ ZERO, IMM

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_BRANCH
    elem^.Body.Xr.Opcode = 0x3D // BEQ
    elem^.Body.Xr.RegA = 0

    // Note that here we store the expression in an "absolute" form, but
    // the encoding stage is sure to turn it into a relative branch offset.

    elem^.Body.Xr.ImmExpr = AsmParseAtom ()
END

FN (XrInstructionMnemonicF) XrParseRet (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse a RET pseudo-instruction.
    // This is really JALR ZERO, LR, 0

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_IMM
    elem^.Body.Xr.Opcode = 0x38
    elem^.Body.Xr.RegA = 0
    elem^.Body.Xr.RegB = 31
    elem^.Body.Xr.ImmExpr = NULLPTR
END

FN (XrInstructionMnemonicF) XrParseJr (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse a JR pseudo-instruction.
    // This is really JALR ZERO, RA, 0

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_IMM
    elem^.Body.Xr.Opcode = 0x38
    elem^.Body.Xr.RegA = 0
    elem^.Body.Xr.ImmExpr = NULLPTR

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegB = reg.TypeContext
END

FN (XrInstructionMnemonicF) XrParseLi (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse an LI pseudo-instruction.
    // This is really ORI RA, ZERO, IMM

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.Body.Xr.FormatType = XR_FORMAT_IMM
    elem^.Body.Xr.Opcode = 0x0C // ORI
    elem^.Body.Xr.RegB = 0

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    elem^.Body.Xr.RegA = reg.TypeContext

    AsmConsumeComma ()

    immexpr := AsmParseAtom ()

    elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
        TOKEN_BITAND, // operator
        immexpr, // left
        0xFFFF, // constant
        EVAL_ERROR, // warnlevel
    )
END

FN (XrInstructionMnemonicF) XrParseLa (
    IN token : ^LexToken,
) : ^AsmElement

    // Parse an LA pseudo-instruction.
    // This is really:
    //   LUI RA, ZERO, IMM >> 16
    //   ORI RA, RA, IMM & 0xFFFF
    //
    // It can create a relocation, so note that on the LUI instruction.

    reg : LexToken

    IF NOT LexMatchToken (
        &reg, // token
        TOKEN_REGISTER, // type
        0, // subtype
    ) THEN
        LexError ( &reg, "Expected a register\n", )
    END

    AsmConsumeComma ()

    immexpr := AsmParseAtom ()

    // Create the LUI instruction.

    elem := AsmCreateElement (
        token, // token
        4, // size
    )

    elem^.RelocationType = XLO_RELOC_XR17032_LA

    elem^.Body.Xr.FormatType = XR_FORMAT_IMM
    elem^.Body.Xr.Opcode = 0x04 // LUI
    elem^.Body.Xr.RegA = reg.TypeContext
    elem^.Body.Xr.RegB = 0

    elem^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
        TOKEN_RIGHTSHIFT, // operator
        immexpr, // left
        16, // constant
        EVAL_NO_WARNING, // warnlevel
    )

    // Create the ORI instruction.

    elem2 := AsmCreateElement (
        token, // token
        4, // size
    )

    elem2^.Body.Xr.FormatType = XR_FORMAT_IMM
    elem2^.Body.Xr.Opcode = 0x0C // ORI
    elem2^.Body.Xr.RegA = reg.TypeContext
    elem2^.Body.Xr.RegB = reg.TypeContext

    elem2^.Body.Xr.ImmExpr = AsmCreateOperationWithConstant (
        TOKEN_BITAND, // operator
        immexpr, // left
        0xFFFF, // constant
        EVAL_NO_WARNING, // warnlevel
    )
END

XrInstructionMnemonics : XrInstructionMnemonicF[XR_INSTRUCTION_MAX] = {
    [XR_JAL] = &XrParseJumpFormat,
    [XR_J] = &XrParseJumpFormat,

    [XR_BEQ] = &XrParseBranchFormat,
    [XR_BNE] = &XrParseBranchFormat,
    [XR_BLT] = &XrParseBranchFormat,
    [XR_BGT] = &XrParseBranchFormat,
    [XR_BLE] = &XrParseBranchFormat,
    [XR_BGE] = &XrParseBranchFormat,
    [XR_BPE] = &XrParseBranchFormat,
    [XR_BPO] = &XrParseBranchFormat,

    [XR_ADDI] = &XrParseImmFormat,
    [XR_SUBI] = &XrParseImmFormat,
    [XR_SLTI] = &XrParseSlti,
    [XR_ANDI] = &XrParseImmFormat,
    [XR_XORI] = &XrParseImmFormat,
    [XR_ORI] = &XrParseImmFormat,
    [XR_LUI] = &XrParseLui,

    [XR_MOV] = &XrParseMov,

    [XR_JALR] = &XrParseJalr,
    [XR_ADR] = &XrParseAdr,

    [XR_LSH] = &XrParseShiftReg,
    [XR_RSH] = &XrParseShiftReg,
    [XR_ASH] = &XrParseShiftReg,
    [XR_ROR] = &XrParseShiftReg,

    [XR_ADD] = &XrParseRegFormat,
    [XR_SUB] = &XrParseRegFormat,
    [XR_SLT] = &XrParseSlt,
    [XR_AND] = &XrParseRegFormat,
    [XR_XOR] = &XrParseRegFormat,
    [XR_OR] = &XrParseRegFormat,
    [XR_NOR] = &XrParseRegFormat,

    [XR_MUL] = &XrParseRegFormat,
    [XR_DIV] = &XrParseDiv,
    [XR_MOD] = &XrParseRegFormat,

    [XR_LL] = &XrParseLoadLocked,
    [XR_SC] = &XrParseRegFormat,

    [XR_PAUSE] = &XrParseRegNone,

    [XR_MB] = &XrParseRegNone,
    [XR_WMB] = &XrParseRegNone,
    [XR_BRK] = &XrParseRegNone,
    [XR_SYS] = &XrParseRegNone,

    [XR_MFCR] = &XrParseMfcr,
    [XR_MTCR] = &XrParseMtcr,

    [XR_HLT] = &XrParseRegNone,
    [XR_RFE] = &XrParseRegNone,

    [XR_B] = &XrParseB,
    [XR_RET] = &XrParseRet,
    [XR_JR] = &XrParseJr,
    [XR_LI] = &XrParseLi,
    [XR_LA] = &XrParseLa,

    [XR_NOP] = &XrParseRegNone,

    [XR_LSHI] = &XrParseShiftImm,
    [XR_RSHI] = &XrParseShiftImm,
    [XR_ASHI] = &XrParseShiftImm,
    [XR_RORI] = &XrParseShiftImm,
}

FN (AsmTargetParseF) XrParseInstruction (
    IN token : ^LexToken,
)

    // Parse the instruction.
    // First line is to dispatch to the parse function that corresponds to this
    // instruction mnemonic.

    XrInstructionMnemonics[token^.Subtype] ( token )
END

FNPTR XrInstructionEncodeF (
    IN instruction : ^AsmElement,
    IN section : ^AsmSection,
    IN dataptr : ^UBYTE,
)

#MACRO XrWriteInstructionWord ( dataptr, inst ) [
    dataptr[0] = inst
    dataptr[1] = inst >> 8
    dataptr[2] = inst >> 16
    dataptr[3] = inst >> 24
]

FN (XrInstructionEncodeF) XrEncodeJump (
    IN instruction : ^AsmElement,
    IN section : ^AsmSection,
    IN dataptr : ^UBYTE,
)

    // Build a JUMP format instruction word.

    inst : ULONG = 0
    inst |= instruction^.Body.Xr.Opcode

    val : UWORD
    refsymbol : ^LexSymbol

    AsmEvaluateNodeMustWork (
        instruction^.Body.Xr.ImmExpr, // node
        OUT val, // value
        OUT refsymbol, // refsymbol
    )

    IF instruction^.RelocationType AND refsymbol THEN
        // Add a relocation.

        AsmAddRelocation (
            instruction^.FileOffset, // offset
            instruction^.RelocationType, // relocationtype
            section, // section
            refsymbol, // symbol
        )
    END

    inst |= val << 3

    XrWriteInstructionWord ( dataptr, inst )
END

FN (XrInstructionEncodeF) XrEncodeBranch (
    IN instruction : ^AsmElement,
    IN section : ^AsmSection,
    IN dataptr : ^UBYTE,
)

    // Build a BRANCH format instruction word.

    inst : ULONG = 0
    inst |= instruction^.Body.Xr.Opcode
    inst |= (instruction^.Body.Xr.RegA & 31) << 6

    val : UWORD
    refsymbol : ^LexSymbol

    AsmEvaluateNodeMustWork (
        instruction^.Body.Xr.ImmExpr, // node
        OUT val, // value
        OUT refsymbol, // refsymbol
    )

    IF refsymbol AND
        refsymbol^.Section != section THEN

        LexError ( &instruction^.ErrorToken,
            "Can't relative branch to another section\n", )
    END

    // Turn the value into a relative branch offset by subtracting the offset to
    // this instruction.

    val -= instruction^.MemoryOffset

    // Check alignment.

    IF val & 3 THEN
        LexError ( &instruction^.ErrorToken, "Unaligned branch offset\n", )
    END

    val >>= 2

    inst |= val << 11

    XrWriteInstructionWord ( dataptr, inst )
END

FN (XrInstructionEncodeF) XrEncodeImm (
    IN instruction : ^AsmElement,
    IN section : ^AsmSection,
    IN dataptr : ^UBYTE,
)

    // Build an IMM format instruction word.

    inst : ULONG = 0
    inst |= instruction^.Body.Xr.Opcode
    inst |= (instruction^.Body.Xr.RegA & 31) << 6
    inst |= (instruction^.Body.Xr.RegB & 31) << 11

    val := 0
    refsymbol : ^LexSymbol = NULLPTR

    IF instruction^.Body.Xr.ImmExpr THEN
        AsmEvaluateNodeMustWork (
            instruction^.Body.Xr.ImmExpr, // node
            OUT val, // value
            OUT refsymbol, // refsymbol
        )
    END

    IF instruction^.RelocationType AND refsymbol THEN
        // Add a relocation.

        AsmAddRelocation (
            instruction^.FileOffset, // offset
            instruction^.RelocationType, // relocationtype
            section, // section
            refsymbol, // symbol
        )
    END

    inst |= val << 16

    XrWriteInstructionWord ( dataptr, inst )
END

FN (XrInstructionEncodeF) XrEncodeReg (
    IN instruction : ^AsmElement,
    IN section : ^AsmSection,
    IN dataptr : ^UBYTE,
)

    // Build a REG format instruction word.

    inst : ULONG = 0
    inst |= instruction^.Body.Xr.Opcode
    inst |= (instruction^.Body.Xr.RegA & 31) << 6
    inst |= (instruction^.Body.Xr.RegB & 31) << 11
    inst |= (instruction^.Body.Xr.RegC & 31) << 16
    inst |= instruction^.Body.Xr.ShiftAmount << 21
    inst |= instruction^.Body.Xr.ShiftType << 26
    inst |= instruction^.Body.Xr.FunctionCode << 28

    XrWriteInstructionWord ( dataptr, inst )
END

XrInstructionEncode : XrInstructionEncodeF[XR_FORMAT_MAX] = {
    [XR_FORMAT_JUMP] = &XrEncodeJump,
    [XR_FORMAT_BRANCH] = &XrEncodeBranch,
    [XR_FORMAT_IMM] = &XrEncodeImm,
    [XR_FORMAT_REG] = &XrEncodeReg,
}

FN (AsmTargetEncodeF) XrEncodeInstruction (
    IN instruction : ^AsmElement,
    IN section : ^AsmSection,
    IN dataptr : ^UBYTE,
)

    // Encode the instruction.

    XrInstructionEncode[instruction^.Body.Xr.FormatType] (
        instruction, // instruction
        section, // section
        dataptr, // dataptr
    )
END