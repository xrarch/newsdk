//
// The tokenizer of the lexer. Processes the raw character stream into tokens
// for the parser to use. Also does string internment, and creates the symbol
// tables (with scopes directed by the parser).
//

#INCLUDE "<inc>/Lexer.hjk"

#DEFINE TargetInfo [AsmTargetInfo]

PUBLIC LexCharTreatment : LexCharBehavior[256] = {
    [0] = CHAR_EOF,

    [' ']  = CHAR_WHITESPACE,
    ['\t'] = CHAR_WHITESPACE,

    ['^'] = CHAR_SPLIT,
    ['('] = CHAR_SPLIT,
    [')'] = CHAR_SPLIT,
    ['~'] = CHAR_SPLIT,
    [','] = CHAR_SPLIT,
    ['['] = CHAR_SPLIT,
    [']'] = CHAR_SPLIT,
    [':'] = CHAR_SPLIT,
    ['{'] = CHAR_SPLIT,
    ['}'] = CHAR_SPLIT,
    ['#'] = CHAR_SPLIT,
    ['\n'] = CHAR_SPLIT,

    ['='] = CHAR_COALESCE,
    ['&'] = CHAR_COALESCE,
    ['|'] = CHAR_COALESCE,
    ['!'] = CHAR_COALESCE,
    ['<'] = CHAR_COALESCE,
    ['>'] = CHAR_COALESCE,
    ['+'] = CHAR_COALESCE,
    ['-'] = CHAR_COALESCE,
    ['*'] = CHAR_COALESCE,
    ['/'] = CHAR_COALESCE,
    ['%'] = CHAR_COALESCE,
    ['.'] = CHAR_COALESCE,
    ['@'] = CHAR_COALESCE,

    // Since CHAR_NORMAL is the first field in the enum, it is guaranteed to
    // be zero in value, so we don't have to explicitly set all the other
    // character behaviors to it, since any non-defined fields here will also
    // be zero.
}

#INCLUDE "../../Cf/CfLexTokenizer.jkl"

FN LexInitializeConsumer ()

    // Perform XrAsm-specific lexer initialization.

    LexInsertKeyword ( ")", TOKEN_RPAREN, 0, 0 )
    LexInsertKeyword ( "]", TOKEN_RBRACKET, 0, 0 )
    LexInsertKeyword ( ":", TOKEN_COLON, 0, 0 )
    LexInsertKeyword ( "{", TOKEN_LBRACE, 0, 0 )
    LexInsertKeyword ( "}", TOKEN_RBRACE, 0, 0 )
    LexInsertKeyword ( ",", TOKEN_COMMA, 0, 0 )
    LexInsertKeyword ( ".", TOKEN_DOT, 0, 0 )
    LexInsertKeyword ( "[", TOKEN_LBRACKET, 0, 0 )
    LexInsertKeyword ( "(", TOKEN_LPAREN, 0, 0 )
    LexInsertKeyword ( "\n", TOKEN_NEWLINE, 0, 0 )
    LexInsertKeyword ( "=", TOKEN_EQUALS, 0, 0 )

    LexInsertKeyword ( "section", TOKEN_DIRECTIVE, TOKEN_SECTION, 0 )
    LexInsertKeyword ( "db", TOKEN_DIRECTIVE, TOKEN_DB, 0 )
    LexInsertKeyword ( "di", TOKEN_DIRECTIVE, TOKEN_DI, 0 )
    LexInsertKeyword ( "dl", TOKEN_DIRECTIVE, TOKEN_DL, 0 )
    LexInsertKeyword ( "dq", TOKEN_DIRECTIVE, TOKEN_DQ, 0 )
    LexInsertKeyword ( "dp", TOKEN_DIRECTIVE, TOKEN_DP, 0 )
    LexInsertKeyword ( "define", TOKEN_DIRECTIVE, TOKEN_DEFINE, 0 )
    LexInsertKeyword ( "incbin", TOKEN_DIRECTIVE, TOKEN_INCBIN, 0 )
    LexInsertKeyword ( "bytes", TOKEN_DIRECTIVE, TOKEN_BYTES, 0 )
    LexInsertKeyword ( "global", TOKEN_DIRECTIVE, TOKEN_GLOBAL, 0 )
    LexInsertKeyword ( "export", TOKEN_DIRECTIVE, TOKEN_EXPORT, 0 )
    LexInsertKeyword ( "extern", TOKEN_DIRECTIVE, TOKEN_EXTERN, 0 )
    LexInsertKeyword ( "ds", TOKEN_DIRECTIVE, TOKEN_DS, 0 )
    LexInsertKeyword ( "align", TOKEN_DIRECTIVE, TOKEN_ALIGN, 0 )

    LexInsertKeyword ( "&", TOKEN_OPER, TOKEN_BITAND, 0 )
    LexInsertKeyword ( "|", TOKEN_OPER, TOKEN_BITOR, 0 )
    LexInsertKeyword ( "+", TOKEN_OPER, TOKEN_PLUS, 0 )
    LexInsertKeyword ( "-", TOKEN_OPER, TOKEN_MINUS, 0 )
    LexInsertKeyword ( "/", TOKEN_OPER, TOKEN_DIVIDE, 0 )
    LexInsertKeyword ( "%", TOKEN_OPER, TOKEN_MODULO, 0 )
    LexInsertKeyword ( "$", TOKEN_OPER, TOKEN_BITXOR, 0 )
    LexInsertKeyword ( "<<", TOKEN_OPER, TOKEN_LEFTSHIFT, 0 )
    LexInsertKeyword ( ">>", TOKEN_OPER, TOKEN_RIGHTSHIFT, 0 )
    LexInsertKeyword ( "~", TOKEN_OPER, TOKEN_BITNOT, 0 )
    LexInsertKeyword ( "*", TOKEN_OPER, TOKEN_MUL, 0 )

    // Call the target to register its instruction keywords.

    AsmTargetInfo^.KeywordsFunc ()
END