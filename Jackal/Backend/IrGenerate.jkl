//
// Converts the abstract syntax tree for each function into straight-line IR.
//

#INCLUDE "Be.hjk"

FNPTR IrStatementGenerationF (
    IN node : ^PrsAstNode,
)

FNPTR IrExpressionGenerationF (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

IrCurrentFunction : ^IrFunction

IrWhileEndLabel : ^IrInstruction = NULLPTR
IrWhileBeginLabel : ^IrInstruction = NULLPTR

IrCurrentFunctionType : ^LexSemanticType

PUBLIC IrCommutativity : UBYTE[IR_MAX] = {
    [IR_COMPARE_EQUALS] = TRUE,
    [IR_COMPARE_NOT_EQUALS] = TRUE,
    [IR_BIT_AND] = TRUE,
    [IR_BIT_OR] = TRUE,
    [IR_ADD] = TRUE,
    [IR_BIT_XOR] = TRUE,
    [IR_MULTIPLY] = TRUE,
}

IrTokenToInstructionType : IrInstructionType[TOKEN_SUBTYPE_MAX] = {
    [TOKEN_PLUSEQUALS] = IR_ADD,
    [TOKEN_MINUSEQUALS] = IR_SUBTRACT,
    [TOKEN_MULEQUALS] = IR_MULTIPLY,
    [TOKEN_DIVEQUALS] = IR_DIVIDE,
    [TOKEN_MODEQUALS] = IR_MODULO,
    [TOKEN_ANDEQUALS] = IR_BIT_AND,
    [TOKEN_OREQUALS] = IR_BIT_OR,
    [TOKEN_XOREQUALS] = IR_BIT_XOR,
    [TOKEN_LSHEQUALS] = IR_LEFT_SHIFT,
    [TOKEN_RSHEQUALS] = IR_RIGHT_SHIFT,
}

FN IrAllocateStack (
    IN func : ^IrFunction,
    IN bytes : UWORD,
) : UWORD

    // Allocate stack frame from the function and return the offset.

    offset := func^.StackFrameSize

    newsize := bytes + offset

    // Restore stack alignment.

    newsize += JklTargetInfo^.StackAlignment - 1
    newsize &= ~(JklTargetInfo^.StackAlignment - 1)

    func^.StackFrameSize = newsize

    RETURN offset
END

FN IrGetStackOffset (
    IN func : ^IrFunction,
    IN symbol : ^LexSymbol,
) : UWORD

    IF symbol^.StackAllocated THEN
        RETURN symbol^.StackOffset
    END

    type := symbol^.SemanticType

    WHILE type^.Subtype == TYPE_NAMED DO
        type = type^.Body.Named.Symbol^.SemanticType
    END

    symbol^.StackAllocated = TRUE

    symbol^.StackOffset = IrAllocateStack (
        func, // func
        type^.Size, // bytes
    )

    RETURN symbol^.StackOffset
END

FN IrCreateInstruction (
    IN type : IrInstructionType,
) : ^IrInstruction

    inst : ^IrInstruction

    status := TlBumpAlloc (
        SIZEOF IrInstruction, // bytes
        OUT inst, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to create IR instruction", 0, 0, 0 )
    END

    inst^.Type = type
    inst^.Defines = NULLPTR
    inst^.Source1 = NULLPTR
    inst^.Source2 = NULLPTR

    inst^.LirRegister = NULLPTR

    RETURN inst
END

IrLabelNumber := 1

FN IrCreateLabel () : ^IrInstruction

    // Create a label instruction.

    label := IrCreateInstruction (
        IR_LABEL, // type
    )

    label^.Body.Label.Symbol = NULLPTR
    label^.Body.Label.LirLabel = NULLPTR
    label^.Body.Label.Number = IrLabelNumber
    label^.Body.Label.GenCount = 0

    IrLabelNumber += 1

    RETURN label
END

FN IrEvaluateTypeForAccess (
    IN node : ^PrsAstNode,
) : ^LexSemanticType

    // Skip any casts.

    WHILE node^.Type == AST_OPERATOR AND
        node^.Token.Subtype == TOKEN_CAST DO

        node = node^.Body.Operator.Left
    END

    RETURN PrsEvaluateType ( node )
END

FN IrCreateVariable (
    IN definedby : ^IrInstruction,
) : ^IrVariable

    var : ^IrVariable

    status := TlBumpAlloc (
        SIZEOF IrVariable, // bytes
        OUT var, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to create IR variable", 0, 0, 0 )
    END

    var^.DefinedBy = definedby
    var^.Annotation = IR_VAR_UNINITIALIZED
    var^.Symbol = NULLPTR
    var^.LirRegister = NULLPTR
    var^.Number = 0

    var^.Opt.Vn.AcquiredByLoad = FALSE
    var^.Opt.Vn.KeyOp = 0

    var^.KnownConstant = FALSE
    var^.Known = FALSE
    var^.ConsideredForDve = FALSE

    RETURN var
END

FN IrInsertInstructionTail (
    IN inst : ^IrInstruction,
)

    // Insert the instruction at the end of the current chain.

    inst^.Block = IrCurrentFunction
    inst^.Next = NULLPTR
    inst^.Prev = IrCurrentFunction^.Tail

    IF NOT IrCurrentFunction^.Tail THEN
        IrCurrentFunction^.Head = inst
    ELSE
        IrCurrentFunction^.Tail^.Next = inst
    END

    IrCurrentFunction^.Tail = inst

    IF inst^.Type > IR_BRANCH_LOW_NUMBER AND
        inst^.Type < IR_BRANCH_HIGH_NUMBER THEN

        IrValueNumberBarrier (
            FALSE, // onlyloads
            NULLPTR, // symbol
        )

    ELSEIF inst^.Type > IR_LOAD_BARRIER_LOW_NUMBER AND
        inst^.Type < IR_LOAD_BARRIER_HIGH_NUMBER THEN

        IrValueNumberBarrier (
            TRUE, // onlyloads
            NULLPTR, // symbol
        )
    END
END

FN IrRemoveInstruction (
    IN inst : ^IrInstruction,
)

    // Remove the instruction from the chain.

    block := inst^.Block

    p := inst^.Prev

    IF p THEN
        p^.Next = inst^.Next
    ELSE // no prev means we were the head
        block^.Head = inst^.Next
    END

    p = inst^.Next

    IF p THEN
        p^.Prev = inst^.Prev
    ELSE // no next means we were the tail
        block^.Tail = inst^.Prev
    END
END

FN IrGenerateLoad (
    IN var : ^IrVariable,
    IN type : ^LexSemanticType,
) : ^IrVariable

    // Generate a load of a pointer into another variable. The variable is not
    // annotated.

    retvar := IrFindValue (
        IR_LOAD, // op
        var, // src1
        NULLPTR, // src2
    )

    IF retvar THEN
        RETURN retvar
    END

    inst := IrCreateInstruction (
        IR_LOAD,
    )

    retvar = IrCreateVariable (
        inst, // definedby
    )

    WHILE type^.Subtype == TYPE_NAMED DO
        type = type^.Body.Named.Symbol^.SemanticType
    END

    IF type^.Subtype == TYPE_PRIMITIVE THEN
        inst^.Body.LoadStore.Type = type^.Body.Primitive.Type

    ELSEIF type^.Subtype == TYPE_POINTER THEN
        inst^.Body.LoadStore.Type = PRIM_TYPE_POINTER

    ELSE
        TlInternalError ( "Illegal IR load", type^.Subtype, 0, 0 )
    END

    inst^.Defines = retvar
    inst^.Source1 = var

    retvar^.Opt.Vn.AcquiredByLoad = TRUE
    retvar^.Opt.Vn.AcquiredByLoadOf = NULLPTR

    definedby := var^.DefinedBy

    IF definedby THEN
        IF definedby^.Type == IR_STACK_ADDR OR
            definedby^.Type == IR_ADDR THEN

            retvar^.Opt.Vn.AcquiredByLoadOf = definedby^.Body.Addr.Symbol
        END
    END

    IrValueNumberVariable (
        retvar, // var
        IR_LOAD, // valueop
        var, // src1
        NULLPTR, // src2
    )

    IrInsertInstructionTail ( inst )

    RETURN retvar
END

FN IrGenerateStore (
    IN destvar : ^IrVariable,
    IN srcvar : ^IrVariable,
    IN type : ^LexSemanticType,
)

    // Generate a memory store where destvar contains the address.

    inst := IrCreateInstruction (
        IR_STORE, // type
    )

    WHILE type^.Subtype == TYPE_NAMED DO
        type = type^.Body.Named.Symbol^.SemanticType
    END

    IF type^.Subtype == TYPE_PRIMITIVE THEN
        inst^.Body.LoadStore.Type = type^.Body.Primitive.Type

    ELSEIF type^.Subtype == TYPE_POINTER THEN
        inst^.Body.LoadStore.Type = PRIM_TYPE_POINTER

    ELSE
        TlInternalError ( "Illegal IR store", type^.Subtype, 0, 0 )
    END

    inst^.Source1 = destvar
    inst^.Source2 = srcvar

    symbol : ^LexSymbol = NULLPTR

    definedby := destvar^.DefinedBy

    IF definedby AND
        (definedby^.Type == IR_STACK_ADDR OR
        definedby^.Type == IR_ADDR) THEN

        symbol = definedby^.Body.Addr.Symbol
    END

    IrInsertInstructionTail ( inst )

    IrValueNumberBarrier (
        TRUE, // onlyloads
        symbol, // symbol
    )
END

FN IrGenerateBranch (
    IN node : ^PrsAstNode,
    IN var1 : ^IrVariable,
    IN var2 : ^IrVariable,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
    IN type : IrInstructionType,
    IN genload : UWORD,
)

    // Generate a branch instruction based on a property of two variables.

    IF genload THEN
        IF var1^.Annotation == IR_VAR_ADDRESS_CALC THEN
            var1 = IrGenerateLoad (
                var1, // var
                IrEvaluateTypeForAccess ( node ), // type
            )
        END

        IF var2 AND var2^.Annotation == IR_VAR_ADDRESS_CALC THEN
            var2 = IrGenerateLoad (
                var2, // var
                IrEvaluateTypeForAccess ( node ), // type
            )
        END
    END

    inst := IrCreateInstruction (
        type,
    )

    inst^.Body.Branch.TrueLabel = truelabel
    inst^.Body.Branch.FalseLabel = falselabel
    inst^.Source1 = var1
    inst^.Source2 = var2

    IrInsertInstructionTail ( inst )
END

FN IrGenerateUnconditionalJump (
    IN label : ^IrInstruction,
)

    // Generate an unconditional jump.

    inst := IrCreateInstruction (
        IR_JUMP, // type
    )

    inst^.Body.Jump.Label = label

    IrInsertInstructionTail ( inst )
END

FN IrCreateConstantVariable (
    IN value : UWORD,
) : ^IrVariable

    // Create a variable with a constant value.

    dovaluenumber := JklTargetInfo^.ValueNumberConstantFunc ( value )

    // Look up the value even if we've decided not to value number this
    // constant. We will see why in a second.

    valvar := IrFindConstant (
        value, // constant
        IR_CONSTANT, // op
    )

    IF dovaluenumber AND valvar THEN
        // Cool, we're allowed to use this.

        RETURN valvar
    END

    inst := IrCreateInstruction (
        IR_CONSTANT, // type
    )

    var := IrCreateVariable (
        inst, // definedby
    )

    inst^.Defines = var
    inst^.Body.Constant.Constant = value

    IF dovaluenumber OR NOT valvar THEN
        // Value number this constant variable in the case that we're here for
        // that, or that we didn't find an existing value.

        IrValueNumberConstantVariable (
            var, // var
            value, // value
            IR_CONSTANT, // op
        )

    ELSEIF valvar THEN
        // We weren't allowed to value number this constant, but we found an
        // existing identical constant. Steal its value number so that common
        // expressions are still value numbered together.

        var^.Opt.Vn.ValueNumber = valvar^.Opt.Vn.ValueNumber
    END

    IrInsertInstructionTail ( inst )

    RETURN var
END

FN IrCreateConstantBefore (
    IN beforeinst : ^IrInstruction,
    IN value : UWORD,
) : ^IrVariable

    // Create a variable with a constant value, and insert it before the given
    // instruction. Helper function for IR simplifier.

    inst := IrCreateInstruction (
        IR_CONSTANT, // type
    )

    var := IrCreateVariable (
        inst, // definedby
    )

    inst^.Defines = var
    inst^.Body.Constant.Constant = value

    inst^.Block = beforeinst^.Block

    prev := beforeinst^.Prev

    IF prev THEN
        prev^.Next = inst

    ELSE
        // beforeinst must have been the head.

        beforeinst^.Block^.Head = inst
    END

    beforeinst^.Prev = inst
    inst^.Next = beforeinst
    inst^.Prev = prev

    RETURN var
END

FN IrGenerateMove (
    IN destvar : ^IrVariable,
    IN srcvar : ^IrVariable,
)

    // Generate a move from the source variable into the destination variable.

    inst := IrCreateInstruction (
        IR_MOVE, // type
    )

    inst^.Defines = destvar
    inst^.Source1 = srcvar

    IrKillVariable ( destvar )

    IrInsertInstructionTail ( inst )
END

FN IrGenerateConstantMove (
    IN destvar : ^IrVariable,
    IN constant : UWORD,
)

    // Generate a move of a constant into the destination variable.

    constvar := IrCreateConstantVariable ( constant )

    IrGenerateMove (
        destvar, // destvar
        constvar, // srcvar
    )
END

FN IrGenerateOperatorInst (
    IN type : IrInstructionType,
    IN src1 : ^IrVariable,
    IN src2 : ^IrVariable,
) : ^IrVariable

    var := IrFindValue (
        type, // op
        src1, // src1
        src2, // src2
    )

    IF var THEN
        RETURN var
    END

    inst := IrCreateInstruction (
        type, // type
    )

    var = IrCreateVariable (
        inst, // definedby
    )

    inst^.Defines = var
    inst^.Source1 = src1
    inst^.Source2 = src2

    IrValueNumberVariable (
        var, // var
        type, // valueop
        src1, // src1
        src2, // src2
    )

    IrInsertInstructionTail ( inst )

    RETURN var
END

// FORWARD
EXTERN FN IrGenerateExpression (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

// FORWARD
EXTERN FN IrGenerateRvalue (
    IN node : ^PrsAstNode,
) : ^IrVariable

FN (IrExpressionGenerationF) IrGenerateIdentifier (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR to put an identifier into an IR variable.

    // If the identifier is a global variable, we will load the pointer to it
    // into the IR variable.

    // If it's a local variable, and it's compound (an array or struct), we
    // generate an expression that loads the pointer within the stack frame into
    // the IR variable.

    // If it's a local variable and it's a datum (i.e. ULONG), we just return
    // the IR variable that it maps to.

    symbol := CAST node^.Token.Payload TO ^LexSymbol

    IF symbol^.Type != SYM_VAR THEN
        TlInternalError ( "Unexpected symbol type", symbol^.Type, 0, 0 )
    END

    type := symbol^.SemanticType

    WHILE type^.Subtype == TYPE_NAMED DO
        type = type^.Body.Named.Symbol^.SemanticType
    END

    var : ^IrVariable

    IF symbol^.Entry.HashTable != &LexRootScope^.HashTable THEN
        // It's a local.

        IF symbol^.IrContext THEN
            // It's a local datum variable and we've already given it an IR
            // variable.

            var = CAST symbol^.IrContext TO ^IrVariable

            var^.Annotation = IR_VAR_LOCAL

        ELSEIF type^.Subtype == TYPE_PRIMITIVE OR type^.Subtype == TYPE_POINTER THEN
            // It's a datum. Create a variable to represent this local
            // variable.

            var = IrCreateVariable (
                NULLPTR, // definedby
            )

            symbol^.IrContext = var

            var^.Symbol = symbol

            var^.Annotation = IR_VAR_LOCAL

            IrGiveOpaqueValueVariable ( var )

        ELSE
            // It must be compound.

            var = IrFindConstant (
                CAST symbol TO UWORD, // constant
                IR_STACK_ADDR, // op
            )

            IF NOT var THEN
                inst := IrCreateInstruction (
                    IR_STACK_ADDR, // type
                )

                var = IrCreateVariable (
                    inst, // definedby
                )

                inst^.Defines = var
                inst^.Body.Addr.Symbol = symbol
                inst^.Body.Addr.Offset = 0

                IrInsertInstructionTail ( inst )

                IrValueNumberConstantVariable (
                    var, // var
                    CAST symbol TO UWORD, // constant
                    IR_STACK_ADDR, // op
                )
            END

            var^.Annotation = IR_VAR_ADDRESS_CALC
        END

    ELSE
        // It's a global.

        var = IrFindConstant (
            CAST symbol TO UWORD, // constant
            IR_ADDR, // op
        )

        IF NOT var THEN
            inst := IrCreateInstruction (
                IR_ADDR, // type
            )

            var = IrCreateVariable (
                inst, // definedby
            )

            inst^.Defines = var
            inst^.Body.Addr.Symbol = symbol

            IrInsertInstructionTail ( inst )

            IrValueNumberConstantVariable (
                var, // var
                CAST symbol TO UWORD, // constant
                IR_ADDR, // op
            )
        END

        var^.Annotation = IR_VAR_ADDRESS_CALC
    END

    IF truelabel THEN
        IrGenerateBranch (
            node, // node
            var, // var1
            NULLPTR, // var2
            truelabel, // truelabel
            falselabel, // falselabel
            IR_BRANCH_NONZERO, // type
            TRUE, // genload
        )

        RETURN NULLPTR
    END

    RETURN var
END

FN (IrExpressionGenerationF) IrGenerateCast (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for a cast.

    // Do nothing!

    RETURN IrGenerateExpression (
        node^.Body.Operator.Left, // node
        truelabel, // truelabel
        falselabel, // falselabel
    )
END

FN (IrExpressionGenerationF) IrGenerateAnd (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for logical AND.

    IF truelabel != NULLPTR THEN
        // This AND does control flow.

        secondlabel := IrCreateLabel ()

        IrGenerateExpression (
            node^.Body.Operator.Left, // node
            secondlabel, // truelabel
            falselabel, // falselabel
        )

        IrInsertInstructionTail ( secondlabel )

        IrGenerateExpression (
            node^.Body.Operator.Right, // node
            truelabel, // truelabel
            falselabel, // falselabel
        )

        RETURN NULLPTR
    END

    // This AND has to produce a value, but still needs to respect short
    // circuiting. We don't need to worry about identity law (i.e. x AND TRUE)
    // because the parser already helpfully dealt with that for us.

    retvar := IrCreateVariable (
        NULLPTR, // definedby
    )

    secondlabel := IrCreateLabel ()
    truelabel = IrCreateLabel ()
    falselabel = IrCreateLabel ()
    donelabel := IrCreateLabel ()

    IrGenerateExpression (
        node^.Body.Operator.Left, // node
        secondlabel, // truelabel
        falselabel, // falselabel
    )

    IrInsertInstructionTail ( secondlabel )

    IrGenerateExpression (
        node^.Body.Operator.Right, // node
        truelabel, // truelabel
        falselabel, // falselabel
    )

    IrInsertInstructionTail ( truelabel )

    IrGenerateConstantMove (
        retvar, // destvar
        1, // constant
    )

    IrGenerateUnconditionalJump ( donelabel )

    IrInsertInstructionTail ( falselabel )

    IrGenerateConstantMove (
        retvar, // destvar
        0, // constant
    )

    IrInsertInstructionTail ( donelabel )

    RETURN retvar
END

FN (IrExpressionGenerationF) IrGenerateOr (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for logical OR.

    IF truelabel != NULLPTR THEN
        // This OR does control flow.

        secondlabel := IrCreateLabel ()

        IrGenerateExpression (
            node^.Body.Operator.Left, // node
            truelabel, // truelabel
            secondlabel, // falselabel
        )

        IrInsertInstructionTail ( secondlabel )

        IrGenerateExpression (
            node^.Body.Operator.Right, // node
            truelabel, // truelabel
            falselabel, // falselabel
        )

        RETURN NULLPTR
    END

    // This OR has to produce a value, but still needs to respect short
    // circuiting. We don't need to worry about identity law (i.e. x OR TRUE)
    // because the parser already helpfully dealt with that for us.

    retvar := IrCreateVariable (
        NULLPTR, // definedby
    )

    secondlabel := IrCreateLabel ()
    truelabel = IrCreateLabel ()
    falselabel = IrCreateLabel ()
    donelabel := IrCreateLabel ()

    IrGenerateExpression (
        node^.Body.Operator.Left, // node
        truelabel, // truelabel
        secondlabel, // falselabel
    )

    IrInsertInstructionTail ( secondlabel )

    IrGenerateExpression (
        node^.Body.Operator.Right, // node
        truelabel, // truelabel
        falselabel, // falselabel
    )

    IrInsertInstructionTail ( truelabel )

    IrGenerateConstantMove (
        retvar, // destvar
        1, // constant
    )

    IrGenerateUnconditionalJump ( donelabel )

    IrInsertInstructionTail ( falselabel )

    IrGenerateConstantMove (
        retvar, // destvar
        0, // constant
    )

    IrInsertInstructionTail ( donelabel )

    RETURN retvar
END

FN (IrExpressionGenerationF) IrGenerateNot (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for logical NOT.

    IF truelabel THEN
        // This NOT does control flow.

        IrGenerateExpression (
            node^.Body.Operator.Left, // node
            falselabel, // truelabel
            truelabel, // falselabel
        )

        RETURN NULLPTR
    END

    // This NOT has to produce a value.

    var := IrGenerateRvalue (
        node^.Body.Operator.Left, // node
    )

    RETURN IrGenerateOperatorInst (
        IR_NOT, // type
        var, // src1
        NULLPTR, // src2
    )
END

FN (IrExpressionGenerationF) IrGenerateEquiv (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for equivalence.

    var1 := IrGenerateRvalue (
        node^.Body.Operator.Left, // node
    )

    var2 := IrGenerateRvalue (
        node^.Body.Operator.Right, // node
    )

    IF truelabel THEN
        // This equivalence does control flow.

        IrGenerateBranch (
            node, // node
            var1, // var1
            var2, // var2
            truelabel, // truelabel
            falselabel, // falselabel
            IR_BRANCH_EQUALS, // type
            FALSE, // genload
        )

        RETURN NULLPTR
    END

    RETURN IrGenerateOperatorInst (
        IR_COMPARE_EQUALS, // type
        var1, // src1
        var2, // src2
    )
END

FN (IrExpressionGenerationF) IrGenerateNotEquiv (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for non-equivalence.

    var1 := IrGenerateRvalue (
        node^.Body.Operator.Left, // node
    )

    var2 := IrGenerateRvalue (
        node^.Body.Operator.Right, // node
    )

    IF truelabel THEN
        // This operator does control flow.

        IrGenerateBranch (
            node, // node
            var1, // var1
            var2, // var2
            truelabel, // truelabel
            falselabel, // falselabel
            IR_BRANCH_NOT_EQUALS, // type
            FALSE, // genload
        )

        RETURN NULLPTR
    END

    RETURN IrGenerateOperatorInst (
        IR_COMPARE_NOT_EQUALS, // type
        var1, // src1
        var2, // src2
    )
END

FN IrIsSignedType (
    IN node : ^PrsAstNode,
) : UBYTE

    // Helper routine.

    type := PrsEvaluateType ( node )

    IF type^.Subtype != TYPE_PRIMITIVE THEN
        RETURN FALSE
    END

    primtype := type^.Body.Primitive.Type

    RETURN primtype > PRIM_TYPE_SIGNED AND primtype < PRIM_TYPE_SIGNED_MAX
END

FN IrGenerateComparison (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
    IN signedbranchtype : IrInstructionType,
    IN unsignedbranchtype : IrInstructionType,
    IN signedcmptype : IrInstructionType,
    IN unsignedcmptype : IrInstructionType,
) : ^IrVariable

    // Generate IR for a comparison.

    var1 := IrGenerateRvalue (
        node^.Body.Operator.Left, // node
    )

    var2 := IrGenerateRvalue (
        node^.Body.Operator.Right, // node
    )

    issigned := IrIsSignedType ( node^.Body.Operator.Left )

    IF truelabel THEN
        // This operator does control flow.

        IF issigned THEN
            IrGenerateBranch (
                node, // node
                var1, // var1
                var2, // var2
                truelabel, // truelabel
                falselabel, // falselabel
                signedbranchtype, // type
                FALSE, // genload
            )

        ELSE
            IrGenerateBranch (
                node, // node
                var1, // var1
                var2, // var2
                truelabel, // truelabel
                falselabel, // falselabel
                unsignedbranchtype, // type
                FALSE, // genload
            )
        END

        RETURN NULLPTR
    END

    IF issigned THEN
        RETURN IrGenerateOperatorInst (
            signedcmptype, // type
            var1, // src1
            var2, // src2
        )

    ELSE
        RETURN IrGenerateOperatorInst (
            unsignedcmptype, // type
            var1, // src1
            var2, // src2
        )
    END
END

FN (IrExpressionGenerationF) IrGenerateLessThan (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for less-than.

    RETURN IrGenerateComparison (
        node, // node
        truelabel, // truelabel
        falselabel, // falselabel
        IR_BRANCH_LESS_THAN_SIGNED, // signedbranchtype
        IR_BRANCH_LESS_THAN, // unsignedbranchtype
        IR_COMPARE_LESS_THAN_SIGNED, // signedcmptype
        IR_COMPARE_LESS_THAN, // unsignedcmptype
    )
END

FN (IrExpressionGenerationF) IrGenerateGreaterThan (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for greater-than.

    RETURN IrGenerateComparison (
        node, // node
        truelabel, // truelabel
        falselabel, // falselabel
        IR_BRANCH_GREATER_THAN_SIGNED, // signedbranchtype
        IR_BRANCH_GREATER_THAN, // unsignedbranchtype
        IR_COMPARE_GREATER_THAN_SIGNED, // signedcmptype
        IR_COMPARE_GREATER_THAN, // unsignedcmptype
    )
END

FN (IrExpressionGenerationF) IrGenerateLtEq (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for less than or equal to.

    RETURN IrGenerateComparison (
        node, // node
        truelabel, // truelabel
        falselabel, // falselabel
        IR_BRANCH_LTEQ_SIGNED, // signedbranchtype
        IR_BRANCH_LTEQ, // unsignedbranchtype
        IR_COMPARE_LTEQ_SIGNED, // signedcmptype
        IR_COMPARE_LTEQ, // unsignedcmptype
    )
END

FN (IrExpressionGenerationF) IrGenerateGtEq (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for greater than or equal to.

    RETURN IrGenerateComparison (
        node, // node
        truelabel, // truelabel
        falselabel, // falselabel
        IR_BRANCH_GTEQ_SIGNED, // signedbranchtype
        IR_BRANCH_GTEQ, // unsignedbranchtype
        IR_COMPARE_GTEQ_SIGNED, // signedcmptype
        IR_COMPARE_GTEQ, // unsignedcmptype
    )
END

FN IrGenerateArithmetic (
    IN node : ^PrsAstNode,
    IN type : IrInstructionType,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for arithmetic.

    var1 := IrGenerateRvalue (
        node^.Body.Operator.Left, // node
    )

    var2 := IrGenerateRvalue (
        node^.Body.Operator.Right, // node
    )

    retvar := IrGenerateOperatorInst (
        type, // type
        var1, // src1
        var2, // src2
    )

    IF truelabel THEN
        IrGenerateBranch (
            node, // node
            retvar, // var1
            NULLPTR, // var2
            truelabel, // truelabel
            falselabel, // falselabel
            IR_BRANCH_NONZERO, // type
            FALSE, // genload
        )

        RETURN NULLPTR
    END

    RETURN retvar
END

FN IrGenerateUnaryArithmetic (
    IN node : ^PrsAstNode,
    IN type : IrInstructionType,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for unary arithmetic.

    var1 := IrGenerateRvalue (
        node^.Body.Operator.Left, // node
    )

    retvar := IrGenerateOperatorInst (
        type, // type
        var1, // src1
        NULLPTR, // src2
    )

    IF truelabel THEN
        IrGenerateBranch (
            node, // node
            retvar, // var1
            NULLPTR, // var2
            truelabel, // truelabel
            falselabel, // falselabel
            IR_BRANCH_NONZERO, // type
            FALSE, // genload
        )

        RETURN NULLPTR
    END

    RETURN retvar
END

#MACRO IrGenerateBinOp ( FN_NAME, OP_TYPE ) [
    FN (IrExpressionGenerationF) FN_NAME (
        IN node : ^PrsAstNode,
        IN truelabel : ^IrInstruction,
        IN falselabel : ^IrInstruction,
    ) : ^IrVariable

        // Generate IR for binary op.

        RETURN IrGenerateArithmetic (
            node, // node
            OP_TYPE, // type
            truelabel, // truelabel
            falselabel, // falselabel
        )
    END
]

// NOTE: Macro function generation

IrGenerateBinOp ( IrGenerateBitAnd, IR_BIT_AND )
IrGenerateBinOp ( IrGenerateBitOr, IR_BIT_OR )
IrGenerateBinOp ( IrGeneratePlus, IR_ADD )
IrGenerateBinOp ( IrGenerateMinus, IR_SUBTRACT )
IrGenerateBinOp ( IrGenerateModulo, IR_MODULO )
IrGenerateBinOp ( IrGenerateBitXor, IR_BIT_XOR )
IrGenerateBinOp ( IrGenerateLeftShift, IR_LEFT_SHIFT )
IrGenerateBinOp ( IrGenerateMul, IR_MULTIPLY )

FN (IrExpressionGenerationF) IrGenerateRightShift (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for right shift.

    type := IR_RIGHT_SHIFT

    IF IrIsSignedType ( node^.Body.Operator.Left ) THEN
        type = IR_RIGHT_SHIFT_SIGNED
    END

    RETURN IrGenerateArithmetic (
        node, // node
        type, // type
        truelabel, // truelabel
        falselabel, // falselabel
    )
END

FN (IrExpressionGenerationF) IrGenerateDivide (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for division.

    type := IR_DIVIDE

    IF IrIsSignedType ( node^.Body.Operator.Left ) THEN
        type = IR_DIVIDE_SIGNED
    END

    RETURN IrGenerateArithmetic (
        node, // node
        type, // type
        truelabel, // truelabel
        falselabel, // falselabel
    )
END

FN (IrExpressionGenerationF) IrGenerateBitNot (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for bitwise NOT.

    RETURN IrGenerateUnaryArithmetic (
        node, // node
        IR_BIT_NOT, // type
        truelabel, // truelabel
        falselabel, // falselabel
    )
END

FN (IrExpressionGenerationF) IrGenerateAddrOf (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for taking an address.

    IF truelabel THEN
        IrGenerateUnconditionalJump ( truelabel )

        RETURN NULLPTR
    END

    var := IrGenerateExpression (
        node^.Body.Operator.Left, // node
        NULLPTR, // truelabel
        NULLPTR, // falselabel
    )

    IF var^.Annotation != IR_VAR_ADDRESS_CALC THEN
        TlInternalError ( "Weird variable at AddrOf", 0, 0, 0 )
    END

    // This variable already contained an address. Clear the annotation so
    // that it doesn't get loaded erroneously.

    var^.Annotation = IR_VAR_UNINITIALIZED

    RETURN var
END

FN (IrExpressionGenerationF) IrGenerateCompoundTypeIndex (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for indexing a compound type.

    var := IrGenerateExpression (
        node^.Body.Operator.Left, // node
        NULLPTR, // truelabel
        NULLPTR, // falselabel
    )

    // Load the offset of the field.

    fieldsymbol := CAST node^.Body.Operator.OperatorSpecific TO ^LexSymbol

    constvar := IrCreateConstantVariable ( fieldsymbol^.Value )

    // Generate an addition to calculate the field pointer.

    retvar := IrGenerateOperatorInst (
        IR_ADD, // type
        var, // src1
        constvar, // src2
    )

    retvar^.Annotation = IR_VAR_ADDRESS_CALC

    IF truelabel THEN
        IrGenerateBranch (
            node, // node
            retvar, // var1
            NULLPTR, // var2
            truelabel, // truelabel
            falselabel, // falselabel
            IR_BRANCH_NONZERO, // type
            TRUE, // genload
        )

        RETURN NULLPTR
    END

    RETURN retvar
END

FN (IrExpressionGenerationF) IrGenerateArrayIndex (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for indexing an array.

    type := PrsEvaluateType ( node^.Body.Operator.Left )

    var : ^IrVariable
    stride : UWORD

    IF type^.Subtype == TYPE_ARRAY THEN
        stride = type^.Body.Array.ElementSize

        var = IrGenerateExpression (
            node^.Body.Operator.Left, // node
            NULLPTR, // truelabel
            NULLPTR, // falselabel
        )

    ELSE
        // Must be a pointer.

        basetype := type^.Body.Pointer.Base

        // Skip type names.

        WHILE basetype^.Subtype == TYPE_NAMED DO
            basetype = basetype^.Body.Named.Symbol^.SemanticType
        END

        stride = basetype^.Size

        var = IrGenerateRvalue (
            node^.Body.Operator.Left, // node
        )
    END

    indexvar := IrGenerateRvalue ( node^.Body.Operator.Right )

    stridevar := IrCreateConstantVariable ( stride )

    // Generate a multiplication to calculate the offset.

    offsetvar := IrGenerateOperatorInst (
        IR_MULTIPLY, // type
        indexvar, // src1
        stridevar, // src2
    )

    // Generate an addition to calculate the element pointer.

    retvar := IrGenerateOperatorInst (
        IR_ADD, // type
        var, // src1
        offsetvar, // src2
    )

    retvar^.Annotation = IR_VAR_ADDRESS_CALC

    IF truelabel THEN
        IrGenerateBranch (
            node, // node
            retvar, // var1
            NULLPTR, // var2
            truelabel, // truelabel
            falselabel, // falselabel
            IR_BRANCH_NONZERO, // type
            TRUE, // genload
        )

        RETURN NULLPTR
    END

    RETURN retvar
END

FN (IrExpressionGenerationF) IrGeneratePtrDereference (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for dereferencing a pointer.

    var := IrGenerateRvalue (
        node^.Body.Operator.Left, // node
    )

    var^.Annotation = IR_VAR_ADDRESS_CALC

    IF truelabel THEN
        IrGenerateBranch (
            node, // node
            var, // var1
            NULLPTR, // var2
            truelabel, // truelabel
            falselabel, // falselabel
            IR_BRANCH_NONZERO, // type
            TRUE, // genload
        )

        RETURN NULLPTR
    END

    RETURN var
END

FN IrGenerateVarTableStore (
    IN vartablevar : ^IrVariable,
    IN argvar : ^IrVariable,
    IN offset : UWORD,
)

    // Generate a store into the var table. Helper function for function calls.

    offsetvar := IrCreateConstantVariable ( offset )

    addrvar := IrGenerateOperatorInst (
        IR_ADD, // type
        vartablevar, // src1
        offsetvar, // src2
    )

    inst := IrCreateInstruction (
        IR_STORE, // type
    )

    inst^.Body.LoadStore.Type = PRIM_TYPE_POINTER

    inst^.Source1 = addrvar
    inst^.Source2 = argvar

    IrInsertInstructionTail ( inst )
END

FN (IrExpressionGenerationF) IrGenerateFunctionCall (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for a function call.
    // Essentially we need to create a list of temporaries containing the value
    // of each argument. We don't care if they're varargs or not, sorting that
    // out is the province of the code generator.

    type := PrsEvaluateType ( node^.Body.Operator.Left )

    inst := IrCreateInstruction (
        IR_CALL, // type
    )

    var := IrCreateVariable (
        NULLPTR, // definedby
    )

    funcvar := IrGenerateExpression (
        node^.Body.Operator.Left, // node
        NULLPTR, // truelabel
        NULLPTR, // falselabel
    )

    IF type^.Body.Function.ReturnType THEN
        inst^.Defines = var
    END

    inst^.Source1 = funcvar
    inst^.Body.Call.ArgListHead = NULLPTR
    inst^.Body.Call.OutListHead = NULLPTR
    inst^.Body.Call.CallNode = node

    arglisttail : ^IrArgument = NULLPTR
    outlisttail : ^IrArgument = NULLPTR

    incount := 0
    outcount := 0

    refarg := type^.Body.Function.ArgListHead

    argnode := CAST node^.Body.Operator.OperatorSpecific TO ^PrsAstNode

    WHILE argnode DO
        IF NOT refarg THEN
            // The following are varargs.

            BREAK
        END

        irarg : ^IrArgument

        status := TlBumpAlloc (
            SIZEOF IrArgument, // bytes
            OUT irarg, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate IR argument", 0, 0, 0 )
        END

        irarg^.Next = NULLPTR

        IF refarg^.InOut == ARG_IN THEN
            irarg^.Variable = IrGenerateRvalue ( argnode )

            IF arglisttail THEN
                arglisttail^.Next = irarg

            ELSE
                inst^.Body.Call.ArgListHead = irarg
            END

            arglisttail = irarg

            incount += 1

        ELSE
            // We don't want to generate the expression here yet so stash it in
            // the variable field so we can get to it later.

            irarg^.Variable = CAST argnode TO ^IrVariable

            IF outlisttail THEN
                outlisttail^.Next = irarg

            ELSE
                inst^.Body.Call.OutListHead = irarg
            END

            outlisttail = irarg

            outcount += 1
        END

        argnode = argnode^.Next

        refarg = refarg^.Next
    END

    vartablevar : ^IrVariable = NULLPTR

    IF argnode THEN
        IF NOT type^.Body.Function.IsVarArg THEN
            TlInternalError ( "More args but not varargs", 0, 0, 0 )
        END

        // There are still varargs.

        offset := 0

        vartable := IrCurrentFunctionType^.Body.Function.VarTable

        vartablevar = IrFindConstant (
            CAST vartable TO UWORD, // constant
            IR_STACK_ADDR, // op
        )

        IF NOT vartablevar THEN
            varinst := IrCreateInstruction (
                IR_STACK_ADDR, // type
            )

            vartablevar = IrCreateVariable (
                varinst, // definedby
            )

            varinst^.Defines = vartablevar
            varinst^.Body.Addr.Symbol = vartable
            varinst^.Body.Addr.Offset = 0

            IrInsertInstructionTail ( varinst )

            IrValueNumberConstantVariable (
                vartablevar, // var
                CAST vartable TO UWORD, // constant
                IR_STACK_ADDR, // op
            )
        END

        WHILE argnode DO
            // Generate store instructions into the vararg table.

            argvar := IrGenerateRvalue ( argnode )

            IrGenerateVarTableStore (
                vartablevar, // vartablevar
                argvar, // argvar
                offset, // offset
            )

            offset += JklTargetInfo^.PointerSize
            argnode = argnode^.Next
        END
    END

    IF type^.Body.Function.IsVarArg THEN
        // Add the vartable and arg count arguments.

        incount += 2

        // Add the vartable as the penultimate argument.

        irarg : ^IrArgument

        status := TlBumpAlloc (
            SIZEOF IrArgument, // bytes
            OUT irarg, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate IR argument", 0, 0, 0 )
        END

        irarg^.Next = NULLPTR

        IF vartablevar THEN
            irarg^.Variable = vartablevar

        ELSE
            irarg^.Variable = IrCreateConstantVariable ( 0 )
        END

        IF arglisttail THEN
            arglisttail^.Next = irarg

        ELSE
            inst^.Body.Call.ArgListHead = irarg
        END

        arglisttail = irarg

        // Add the constant number of varargs as the final argument.

        argcvar := IrCreateConstantVariable (
            node^.Body.Operator.VarArgCount, // constant
        )

        status = TlBumpAlloc (
            SIZEOF IrArgument, // bytes
            OUT irarg, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate IR argument", 0, 0, 0 )
        END

        irarg^.Variable = argcvar
        irarg^.Next = NULLPTR

        IF arglisttail THEN
            arglisttail^.Next = irarg

        ELSE
            inst^.Body.Call.ArgListHead = irarg
        END

        arglisttail = irarg
    END

    IrInsertInstructionTail ( inst )

    outarg := inst^.Body.Call.OutListHead

    WHILE outarg DO
        argnode = CAST outarg^.Variable TO ^PrsAstNode

        outvar := IrGenerateExpression (
            argnode, // node
            NULLPTR, // truelabel
            NULLPTR, // falselabel
        )

        IF outvar^.Annotation == IR_VAR_LOCAL THEN
            // Just put it directly as the destination.

            outarg^.Variable = outvar

            // Also, kill.

            IrKillVariable ( outvar )
        
        ELSEIF outvar^.Annotation == IR_VAR_ADDRESS_CALC THEN
            // Make the destination a temporary.

            outarg^.Variable = IrCreateVariable (
                NULLPTR, // definedby
            )

            // Now generate a store of that temporary.

            IrGenerateStore (
                outvar, // destvar
                outarg^.Variable, // srcvar
                IrEvaluateTypeForAccess ( argnode ), // type
            )

        ELSE
            TlInternalError ( "Unexpected IR variable",
                outvar^.Annotation, 0, 0 )
        END

        outarg = outarg^.Next
    END

    IF incount > IrCurrentFunction^.MaximumInCount THEN
        IrCurrentFunction^.MaximumInCount = incount
    END

    IF outcount > IrCurrentFunction^.MaximumOutCount THEN
        IrCurrentFunction^.MaximumOutCount = outcount
    END

    IrCurrentFunction^.CallCount += 1

    IF truelabel THEN
        IrGenerateBranch (
            node, // node
            var, // var1
            NULLPTR, // var2
            truelabel, // truelabel
            falselabel, // falselabel
            IR_BRANCH_NONZERO, // type
            TRUE, // genload
        )

        RETURN NULLPTR
    END

    RETURN var
END

FN IrGenerateAssignment (
    IN node : ^PrsAstNode,
    IN destvar : ^IrVariable,
    IN srcvar : ^IrVariable,
    IN type : ^LexSemanticType,
)

    // Generate a store into a variable.

    IF destvar^.Annotation == IR_VAR_ADDRESS_CALC THEN
        // Actually generate a memory store.

        IrGenerateStore (
            destvar, // destvar
            srcvar, // srcvar
            type, // type
        )

    ELSEIF destvar^.Annotation == IR_VAR_LOCAL THEN
        // Generate a move.
        // XXX Remember that code generation should notice a cast here.

        IrGenerateMove (
            destvar, // destvar
            srcvar, // srcvar
        )

    ELSE
        TlInternalError ( "Unexpected IR variable", destvar^.Annotation, 0, 0 )
    END
END

FN (IrExpressionGenerationF) IrGenerateEqualsAssign (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for a plain equals assignment.

    var := IrGenerateRvalue (
        node^.Body.Assign.Right, // node
    )

    dest := IrGenerateExpression (
        node^.Body.Assign.Left, // node
        NULLPTR, // truelabel
        NULLPTR, // falselabel
    )

    IrGenerateAssignment (
        node, // node
        dest, // destvar
        var, // srcvar
        IrEvaluateTypeForAccess ( node^.Body.Assign.Left ), // type
    )

    RETURN NULLPTR
END

FN (IrExpressionGenerationF) IrGenerateModificationAssign (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generic code for generating IR for a modification assignment.

    desttype := IrEvaluateTypeForAccess ( node^.Body.Assign.Left )

    valvar := IrGenerateRvalue (
        node^.Body.Assign.Right, // node
    )

    destvar := IrGenerateExpression (
        node^.Body.Assign.Left, // node
        NULLPTR, // truelabel
        NULLPTR, // falselabel
    )

    contentsvar : ^IrVariable

    IF destvar^.Annotation == IR_VAR_ADDRESS_CALC THEN
        contentsvar = IrGenerateLoad (
            destvar, // var
            desttype, // type
        )

    ELSE
        contentsvar = destvar
    END

    // Generate the modification instruction.

    type := IrTokenToInstructionType[node^.Token.Subtype]

    IF (type == IR_DIVIDE OR type == IR_RIGHT_SHIFT) AND
        IrIsSignedType ( node^.Body.Assign.Left ) THEN

        // Flip to signed variant. Note that the conditional above is crafted to
        // only cause a function call if the type is one of those two options.

        IF type == IR_DIVIDE THEN
            type = IR_DIVIDE_SIGNED

        ELSE
            type = IR_RIGHT_SHIFT_SIGNED
        END
    END

    newvar := IrGenerateOperatorInst (
        IrTokenToInstructionType[node^.Token.Subtype], // type
        contentsvar, // src1
        valvar, // src2
    )

    IrGenerateAssignment (
        node, // node
        destvar, // destvar
        newvar, // srcvar
        IrEvaluateTypeForAccess ( node^.Body.Assign.Left ), // type
    )
END

IrOperatorGenerationTable : IrExpressionGenerationF[TOKEN_SUBTYPE_MAX] = {
    [TOKEN_AND] = &IrGenerateAnd,
    [TOKEN_CAST] = &IrGenerateCast,
    [TOKEN_NOT] = &IrGenerateNot,
    [TOKEN_OR] = &IrGenerateOr,
    [TOKEN_EQUIV] = &IrGenerateEquiv,
    [TOKEN_NOTEQUIV] = &IrGenerateNotEquiv,
    [TOKEN_BITAND] = &IrGenerateBitAnd,
    [TOKEN_BITOR] = &IrGenerateBitOr,
    [TOKEN_LESSTHAN] = &IrGenerateLessThan,
    [TOKEN_GREATERTHAN] = &IrGenerateGreaterThan,
    [TOKEN_LTEQ] = &IrGenerateLtEq,
    [TOKEN_GTEQ] = &IrGenerateGtEq,
    [TOKEN_PLUS] = &IrGeneratePlus,
    [TOKEN_MINUS] = &IrGenerateMinus,
    [TOKEN_DIVIDE] = &IrGenerateDivide,
    [TOKEN_MODULO] = &IrGenerateModulo,
    [TOKEN_DOT] = &IrGenerateCompoundTypeIndex,
    [TOKEN_BITXOR] = &IrGenerateBitXor,
    [TOKEN_LEFTSHIFT] = &IrGenerateLeftShift,
    [TOKEN_RIGHTSHIFT] = &IrGenerateRightShift,
    [TOKEN_BITNOT] = &IrGenerateBitNot,
    [TOKEN_MUL] = &IrGenerateMul,
    [TOKEN_LBRACKET] = &IrGenerateArrayIndex,
    [TOKEN_CARET] = &IrGeneratePtrDereference,
    [TOKEN_LPAREN] = &IrGenerateFunctionCall,
    [TOKEN_ADDROF] = &IrGenerateAddrOf,

    // Use the same table to squirrel away the assignment operators.

    [TOKEN_EQUALS] = &IrGenerateEqualsAssign,
    [TOKEN_PLUSEQUALS] = &IrGenerateModificationAssign,
    [TOKEN_MINUSEQUALS] = &IrGenerateModificationAssign,
    [TOKEN_MULEQUALS] = &IrGenerateModificationAssign,
    [TOKEN_DIVEQUALS] = &IrGenerateModificationAssign,
    [TOKEN_MODEQUALS] = &IrGenerateModificationAssign,
    [TOKEN_ANDEQUALS] = &IrGenerateModificationAssign,
    [TOKEN_OREQUALS] = &IrGenerateModificationAssign,
    [TOKEN_XOREQUALS] = &IrGenerateModificationAssign,
    [TOKEN_LSHEQUALS] = &IrGenerateModificationAssign,
    [TOKEN_RSHEQUALS] = &IrGenerateModificationAssign,
}

FN (IrExpressionGenerationF) IrGenerateOperatorExpression (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR to put an operator expression into a variable.

    subtype := node^.Token.Subtype

    RETURN IrOperatorGenerationTable[node^.Token.Subtype] (
        node, // node
        truelabel, // truelabel,
        falselabel, // falselabel,
    )
END

FN (IrExpressionGenerationF) IrGenerateConstant (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR to put a constant into a variable.

    IF truelabel THEN
        IF node^.Body.Constant.Value THEN
            IrGenerateUnconditionalJump ( truelabel )

        ELSE
            IrGenerateUnconditionalJump ( falselabel )
        END

        RETURN NULLPTR
    END

    var := IrCreateConstantVariable (
        node^.Body.Constant.Value, // value
    )

    RETURN var
END

FN (IrExpressionGenerationF) IrGenerateString (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR to put a string pointer into a variable.

    IF truelabel THEN
        IrGenerateUnconditionalJump ( truelabel )

        RETURN NULLPTR
    END

    inst := IrCreateInstruction (
        IR_STRING_ADDR, // type
    )

    var := IrCreateVariable (
        inst, // definedby
    )

    inst^.Defines = var
    inst^.Body.String.String = CAST node^.Token.Payload TO ^LexInternedString

    IrInsertInstructionTail ( inst )

    RETURN var
END

FN IrGenerateInitializer (
    IN node : ^PrsAstNode,
) : ^IrVariable

    // Generate IR to initialize a structure.

    LexError ( &node^.Token,
        "I didn't feel like implementing runtime initializers yet\n" )

    RETURN NULLPTR
END

IrExpressionGenerationTable : IrExpressionGenerationF[AST_MAX] = {
    [AST_IDENTIFIER] = &IrGenerateIdentifier,
    [AST_OPERATOR] = &IrGenerateOperatorExpression,
    [AST_CONSTANT] = &IrGenerateConstant,
    [AST_STRING] = &IrGenerateString,
    [AST_INITIALIZER] = &IrGenerateInitializer,
}

FN IrGenerateExpression (
    IN node : ^PrsAstNode,
    IN truelabel : ^IrInstruction,
    IN falselabel : ^IrInstruction,
) : ^IrVariable

    // Generate IR for an expression. The result is in the virtual variable, or
    // by control flow to the true or false label if provided.

    RETURN IrExpressionGenerationTable[node^.Type] (
        node, // node
        truelabel, // truelabel,
        falselabel, // falselabel,
    )
END

FN IrGenerateRvalue (
    IN node : ^PrsAstNode,
) : ^IrVariable

    // Generate IR for an expression, as an Rvalue, i.e., a load is performed if
    // relevant.

    var := IrGenerateExpression (
        node, // node
        NULLPTR, // truelabel
        NULLPTR, // falselabel
    )

    IF var^.Annotation == IR_VAR_ADDRESS_CALC THEN
        var = IrGenerateLoad (
            var, // var
            IrEvaluateTypeForAccess ( node ), // type
        )
    END

    RETURN var
END

FN (IrStatementGenerationF) IrGenerateAssign (
    IN node : ^PrsAstNode,
)

    // Generate IR for an assignment.

    subtype := node^.Token.Subtype

    IrOperatorGenerationTable[node^.Token.Subtype] (
        node, // node
        NULLPTR, // truelabel,
        NULLPTR, // falselabel,
    )
END

FN (IrStatementGenerationF) IrGenerateOperator (
    IN node : ^PrsAstNode,
)

    // Generate IR for an operator statement (such as a function call or an
    // address probe).

    IrGenerateRvalue ( node )
END

FN (IrStatementGenerationF) IrGenerateBreak (
    IN node : ^PrsAstNode,
)

    // Generate IR for a break statement.

    IrGenerateUnconditionalJump ( IrWhileEndLabel )
END

FN (IrStatementGenerationF) IrGenerateBarrier (
    IN node : ^PrsAstNode,
)

    // Generate IR for a barrier statement.

    inst := IrCreateInstruction (
        IR_BARRIER, // type
    )

    IrInsertInstructionTail ( inst )
END

FN (IrStatementGenerationF) IrGenerateInsertAsm (
    IN node : ^PrsAstNode,
)

    // Generate IR for an INSERTASM statement.

    inst := IrCreateInstruction (
        IR_INSERTASM, // type
    )

    inst^.Body.String.String = node^.Body.Statement.StatementSpecific

    IrInsertInstructionTail ( inst )
END

FN (IrStatementGenerationF) IrGenerateReturn (
    IN node : ^PrsAstNode,
)

    // Generate IR for a return or leave statement.

    retnode := CAST node^.Body.Statement.StatementSpecific TO ^PrsAstNode

    var : ^IrVariable = NULLPTR

    IF retnode THEN
        var = IrGenerateRvalue ( retnode )
    END

    inst := IrCreateInstruction (
        IR_RETURN, // type
    )

    inst^.Source1 = var

    IrInsertInstructionTail ( inst )
END

// FORWARD
EXTERN FN IrGenerateBlock (
    IN block : ^PrsBlock,
)

FN (IrStatementGenerationF) IrGenerateWhile (
    IN node : ^PrsAstNode,
)

    // Generate IR for a while loop.

    cond := node^.Body.While.Conditional
    body := node^.Body.While.BodyBlock

    truelabel := IrCreateLabel ()
    falselabel := IrCreateLabel ()

    oldtruelabel := IrWhileBeginLabel
    oldfalselabel := IrWhileEndLabel

    IrWhileBeginLabel = truelabel
    IrWhileEndLabel = falselabel

    IF cond^.Type == AST_CONSTANT OR cond^.Type == AST_STRING THEN
        // Must be a non-zero constant. Create a simple infinite loop.

        IrInsertInstructionTail ( truelabel )

        IrGenerateBlock ( body )

        IrGenerateUnconditionalJump ( truelabel )

        IrInsertInstructionTail ( falselabel )

        IrWhileBeginLabel = oldtruelabel
        IrWhileEndLabel = oldfalselabel

        LEAVE
    END

    // To reduce branches, we want to turn:
    //
    // WHILE x DO
    //     ...
    // END
    //
    // Into:
    //
    // IF x THEN
    //     WHILE TRUE DO
    //         ...
    //         IF NOT x THEN
    //             BREAK
    //         END
    //     END
    // END

    IrGenerateExpression (
        cond, // node
        truelabel, // truelabel
        falselabel, // falselabel
    )

    IrInsertInstructionTail ( truelabel )

    beginlabel := IrCreateLabel ()
    IrWhileBeginLabel = beginlabel

    IrGenerateBlock ( body )

    IrInsertInstructionTail ( beginlabel )

    IrGenerateExpression (
        cond, // node
        truelabel, // truelabel
        falselabel, // falselabel
    )

    IrInsertInstructionTail ( falselabel )

    IrWhileBeginLabel = oldtruelabel
    IrWhileEndLabel = oldfalselabel
END

FN (IrStatementGenerationF) IrGenerateLabel (
    IN node : ^PrsAstNode,
)

    // Generate IR for a label.

    labelsym := CAST node^.Body.Statement.StatementSpecific TO ^LexSymbol

    IF NOT labelsym^.Value THEN
        // The label was never used anyway.

        LEAVE
    END

    inst := CAST labelsym^.IrContext TO ^IrInstruction

    IF NOT inst THEN
        inst = IrCreateLabel ()

        labelsym^.IrContext = inst
    END

    inst^.Body.Label.Symbol = labelsym

    IrInsertInstructionTail ( inst )
END

FN (IrStatementGenerationF) IrGenerateGoTo (
    IN node : ^PrsAstNode,
)

    // Generate IR for a goto statement.

    labelsym := CAST node^.Body.Statement.StatementSpecific TO ^LexSymbol

    IF labelsym^.Type == SYM_FORWARD_LABEL THEN
        // The symbol was never actually defined :(
        // This is one of the few source text errors that we wait until IR gen
        // to catch.

        LexError ( &node^.Token, "Use of label that is never defined\n" )
    END

    labelinst := CAST labelsym^.IrContext TO ^IrInstruction

    IF NOT labelinst THEN
        labelinst = IrCreateLabel ()

        labelsym^.IrContext = labelinst
    END

    IrGenerateUnconditionalJump ( labelinst )
END

FN (IrStatementGenerationF) IrGenerateContinue (
    IN node : ^PrsAstNode,
)

    // Generate IR for a continue statement.

    IrGenerateUnconditionalJump ( IrWhileBeginLabel )
END

FN (IrStatementGenerationF) IrGenerateIf (
    IN node : ^PrsAstNode,
)

    // Generate IR for an if statement.

    ifcase := node^.Body.If.CaseListHead
    elseblock := node^.Body.If.ElseBlock

    donelabel := IrCreateLabel ()

    WHILE ifcase DO
        body := ifcase^.BodyBlock
        cond := ifcase^.Conditional

        IF ifcase^.Conditional^.Type == AST_CONSTANT THEN
            // Must be a non-zero constant. We can assume the ELSE block was
            // completely elided by the parser.

            IrGenerateBlock ( body )

            BREAK
        END

        truelabel := IrCreateLabel ()
        falselabel : ^IrInstruction

        IF ifcase^.Next OR elseblock THEN
            falselabel = IrCreateLabel ()

        ELSE
            falselabel = donelabel
        END

        IrGenerateExpression (
            cond, // node
            truelabel, // truelabel
            falselabel, // falselabel
        )

        IrInsertInstructionTail ( truelabel )

        IrGenerateBlock ( body )

        IF ifcase^.Next OR elseblock THEN
            IrGenerateUnconditionalJump ( donelabel )

            IrInsertInstructionTail ( falselabel )
        END

        ifcase = ifcase^.Next
    END

    IF elseblock THEN
        IrGenerateBlock ( elseblock )
    END

    IrInsertInstructionTail ( donelabel )
END

IrStatementGenerationTable : IrStatementGenerationF[AST_MAX] = {
    [AST_ASSIGN] = &IrGenerateAssign,
    [AST_OPERATOR] = &IrGenerateOperator,
    [AST_BREAK] = &IrGenerateBreak,
    [AST_RETURN] = &IrGenerateReturn,
    [AST_WHILE] = &IrGenerateWhile,
    [AST_LABEL] = &IrGenerateLabel,
    [AST_GOTO] = &IrGenerateGoTo,
    [AST_CONTINUE] = &IrGenerateContinue,
    [AST_IF] = &IrGenerateIf,
    [AST_BARRIER] = &IrGenerateBarrier,
    [AST_INSERTASM] = &IrGenerateInsertAsm,
}

FN IrGenerateBlock (
    IN block : ^PrsBlock,
)

    // Generate IR for a single block, which is a sequence of statements.

    node := block^.StatementListHead

    WHILE node DO
        func := IrStatementGenerationTable[node^.Type]

        IF func THEN
            func ( node )
        END

        node = node^.Next
    END
END

FN IrGenerateForFunction (
    IN funcsym : ^LexSymbol,
)

    // Generate IR for a function definition.

    // First create an IR function.

    status := TlBumpAlloc (
        SIZEOF IrFunction, // sizeof
        OUT IrCurrentFunction, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to create IR block", 0, 0, 0 )
    END

    IrCurrentFunction^.Head = NULLPTR
    IrCurrentFunction^.Tail = NULLPTR
    IrCurrentFunction^.StackFrameSize = 0

    IrCurrentFunction^.MaximumInCount = 0
    IrCurrentFunction^.MaximumOutCount = 0
    IrCurrentFunction^.CallCount = 0
    IrCurrentFunction^.EpilogueLabel = IrCreateLabel ()

    funcsym^.InitialValue = IrCurrentFunction

    // Make sure all the OUT parameters have an IR variable.

    type := funcsym^.SemanticType

    IrCurrentFunctionType = type

    outarg := type^.Body.Function.ArgListHead

    WHILE outarg DO
        IF outarg^.InOut != ARG_OUT THEN
            outarg = outarg^.Next

            CONTINUE
        END

        symbol := outarg^.Symbol

        irvar := IrCreateVariable (
            NULLPTR, // definedby
        )

        symbol^.IrContext = irvar

        irvar^.Symbol = symbol

        irvar^.Annotation = IR_VAR_LOCAL

        irvar^.ConsideredForDve = TRUE
        irvar^.Opt.Dve.References = 1

        outarg = outarg^.Next
    END

    // Generate the function block.

    IrGenerateBlock ( funcsym^.SemanticType^.Body.Function.BodyBlock )

    IrInsertInstructionTail ( IrCurrentFunction^.EpilogueLabel )
END

FN IrGenerate ()

    // Initialize the value numbering support package.

    IrInitializeValueNumber ()

    // For each function definition, generate IR.

    funcsym := PrsFunctionListHead

    WHILE funcsym DO
        // Now generate the IR for the function.

        IrValueNumberBarrier (
            FALSE, // onlyloads
            NULLPTR, // symbol
        )

        IrGenerateForFunction ( funcsym )

        funcsym = funcsym^.NextFunction
    END
END