//
// The tokenizer of the lexer. Processes the raw character stream into tokens
// for the parser to use. Also does string internment, and creates the symbol
// tables (with scopes directed by the parser).
//

#INCLUDE "<inc>/Lexer.hjk"

#DEFINE TargetInfo [JklTargetInfo]

PUBLIC LexCharTreatment : LexCharBehavior[256] = {
    [0] = CHAR_EOF,

    [' ']  = CHAR_WHITESPACE,
    ['\n'] = CHAR_WHITESPACE,
    ['\t'] = CHAR_WHITESPACE,

    ['^'] = CHAR_SPLIT,
    ['('] = CHAR_SPLIT,
    [')'] = CHAR_SPLIT,
    ['~'] = CHAR_SPLIT,
    [','] = CHAR_SPLIT,
    ['['] = CHAR_SPLIT,
    [']'] = CHAR_SPLIT,
    [':'] = CHAR_SPLIT,
    ['{'] = CHAR_SPLIT,
    ['}'] = CHAR_SPLIT,
    ['#'] = CHAR_SPLIT,

    ['='] = CHAR_COALESCE,
    ['&'] = CHAR_COALESCE,
    ['|'] = CHAR_COALESCE,
    ['!'] = CHAR_COALESCE,
    ['<'] = CHAR_COALESCE,
    ['>'] = CHAR_COALESCE,
    ['+'] = CHAR_COALESCE,
    ['-'] = CHAR_COALESCE,
    ['*'] = CHAR_COALESCE,
    ['/'] = CHAR_COALESCE,
    ['%'] = CHAR_COALESCE,
    ['.'] = CHAR_COALESCE,
    ['@'] = CHAR_COALESCE,
    ['$'] = CHAR_COALESCE,

    // Since CHAR_NORMAL is the first field in the enum, it is guaranteed to
    // be zero in value, so we don't have to explicitly set all the other
    // character behaviors to it, since any non-defined fields here will also
    // be zero.
}

#INCLUDE "../../Cf/CfLexTokenizer.jkl"

FN LexInitializeConsumer ()

    // Initialize the Jackal-specific lexer things.

    // Initialize the section package.

    LexInitializeSectionStuff ()

    // Insert the keywords.

    LexInsertKeyword ( "AND", TOKEN_OPER, TOKEN_AND, 0 )
    LexInsertKeyword ( "BREAK", TOKEN_STATEMENT, TOKEN_BREAK, 0 )
    LexInsertKeyword ( "BYTE", TOKEN_PTYPE, TOKEN_BYTE, PRIM_TYPE_BYTE )
    LexInsertKeyword ( "CAST", TOKEN_OPER, TOKEN_CAST, 0 )
    LexInsertKeyword ( "CONTAINEROF", TOKEN_OPER, TOKEN_CONTAINEROF, 0 )
    LexInsertKeyword ( "CONTINUE", TOKEN_STATEMENT, TOKEN_CONTINUE, 0 )
    LexInsertKeyword ( "DO", TOKEN_OTHER, TOKEN_DO, 0 )
    LexInsertKeyword ( "ELSE", TOKEN_TERMINATOR, TOKEN_ELSE, 0 )
    LexInsertKeyword ( "ELSEIF", TOKEN_TERMINATOR, TOKEN_ELSEIF, 0 )
    LexInsertKeyword ( "END", TOKEN_TERMINATOR, TOKEN_END, 0 )
    LexInsertKeyword ( "ENUM", TOKEN_DECL, TOKEN_ENUM, 0 )
    LexInsertKeyword ( "EXTERN", TOKEN_DECL, TOKEN_EXTERN, 0 )
    LexInsertKeyword ( "FALSE", TOKEN_VALUE, TOKEN_FALSE, 0 )
    LexInsertKeyword ( "FN", TOKEN_DECL, TOKEN_FN, 0 )
    LexInsertKeyword ( "FNPTR", TOKEN_DECL, TOKEN_FNPTR, 0 )
    LexInsertKeyword ( "GOTO", TOKEN_STATEMENT, TOKEN_GOTO, 0 )
    LexInsertKeyword ( "IF", TOKEN_STATEMENT, TOKEN_IF, 0 )
    LexInsertKeyword ( "IN", TOKEN_ARGSPEC, TOKEN_IN, 0 )
    LexInsertKeyword ( "INT", TOKEN_PTYPE, TOKEN_INT, PRIM_TYPE_INT )
    LexInsertKeyword ( "LEAVE", TOKEN_STATEMENT, TOKEN_LEAVE, 0 )
    LexInsertKeyword ( "LONG", TOKEN_PTYPE, TOKEN_LONG, PRIM_TYPE_LONG )
    LexInsertKeyword ( "NOT", TOKEN_OPER, TOKEN_NOT, 0 )
    LexInsertKeyword ( "NULLPTR", TOKEN_VALUE, TOKEN_NULLPTR, 0 )
    LexInsertKeyword ( "OR", TOKEN_OPER, TOKEN_OR, 0 )
    LexInsertKeyword ( "OUT", TOKEN_ARGSPEC, TOKEN_OUT, 0 )
    LexInsertKeyword ( "PACKED", TOKEN_OTHER, TOKEN_PACKED, 0 )
    LexInsertKeyword ( "PUBLIC", TOKEN_DECL, TOKEN_PUBLIC, 0 )
    LexInsertKeyword ( "RETURN", TOKEN_STATEMENT, TOKEN_RETURN, 0 )
    LexInsertKeyword ( "SIZEOF", TOKEN_SIZEOF, 0, 0 )
    LexInsertKeyword ( "OFFSETOF", TOKEN_OFFSETOF, 0, 0 )
    LexInsertKeyword ( "SIZEOFVALUE", TOKEN_OPER, TOKEN_SIZEOFVALUE, 0 )
    LexInsertKeyword ( "STRUCT", TOKEN_DECL, TOKEN_STRUCT, 0 )
    LexInsertKeyword ( "THEN", TOKEN_OTHER, TOKEN_THEN, 0 )
    LexInsertKeyword ( "TO", TOKEN_OTHER, TOKEN_TO, 0 )
    LexInsertKeyword ( "TRUE", TOKEN_VALUE, TOKEN_TRUE, 0 )
    LexInsertKeyword ( "TYPE", TOKEN_DECL, TOKEN_TYPE, 0 )
    LexInsertKeyword ( "UBYTE", TOKEN_PTYPE, TOKEN_UBYTE, PRIM_TYPE_UBYTE )
    LexInsertKeyword ( "UINT", TOKEN_PTYPE, TOKEN_UINT, PRIM_TYPE_UINT )
    LexInsertKeyword ( "ULONG", TOKEN_PTYPE, TOKEN_ULONG, PRIM_TYPE_ULONG )
    LexInsertKeyword ( "UNION", TOKEN_DECL, TOKEN_UNION, 0 )
    LexInsertKeyword ( "VOID", TOKEN_PTYPE, TOKEN_VOID, PRIM_TYPE_VOID )
    LexInsertKeyword ( "WHILE", TOKEN_STATEMENT, TOKEN_WHILE, 0 )
    LexInsertKeyword ( "BARRIER", TOKEN_STATEMENT, TOKEN_BARRIER, 0 )
    LexInsertKeyword ( "INSERTASM", TOKEN_STATEMENT, TOKEN_INSERTASM, 0 )
    LexInsertKeyword ( "NOTHING", TOKEN_STATEMENT, TOKEN_NOTHING, 0 )
    LexInsertKeyword ( "EXPORT", TOKEN_DECL, TOKEN_EXPORT, 0 )
    LexInsertKeyword ( "PRIVATE", TOKEN_DECL, TOKEN_PRIVATE, 0 )
    LexInsertKeyword ( "UQUAD", TOKEN_PTYPE, TOKEN_UQUAD, PRIM_TYPE_UQUAD )
    LexInsertKeyword ( "QUAD", TOKEN_PTYPE, TOKEN_QUAD, PRIM_TYPE_QUAD )
    LexInsertKeyword ( "ROR", TOKEN_OPER, TOKEN_ROR, 0 )

    LexInsertKeyword ( "UWORD", TOKEN_PTYPE, TOKEN_UWORD,
        JklTargetInfo^.LargestPrimitive )

    LexInsertKeyword ( "WORD", TOKEN_PTYPE, TOKEN_WORD,
        JklTargetInfo^.LargestSignedPrimitive )

    LexInsertKeyword ( ")", TOKEN_RPAREN, 0, 0 )
    LexInsertKeyword ( "]", TOKEN_RBRACKET, 0, 0 )
    LexInsertKeyword ( ":", TOKEN_COLON, 0, 0 )
    LexInsertKeyword ( "{", TOKEN_LBRACE, 0, 0 )
    LexInsertKeyword ( "}", TOKEN_RBRACE, 0, 0 )
    LexInsertKeyword ( ",", TOKEN_COMMA, 0, 0 )

    LexInsertKeyword ( "==", TOKEN_OPER, TOKEN_EQUIV, 0 )
    LexInsertKeyword ( "!=", TOKEN_OPER, TOKEN_NOTEQUIV, 0 )
    LexInsertKeyword ( "&", TOKEN_OPER, TOKEN_BITAND, 0 )
    LexInsertKeyword ( "|", TOKEN_OPER, TOKEN_BITOR, 0 )
    LexInsertKeyword ( "<", TOKEN_OPER, TOKEN_LESSTHAN, 0 )
    LexInsertKeyword ( ">", TOKEN_OPER, TOKEN_GREATERTHAN, 0 )
    LexInsertKeyword ( "<=", TOKEN_OPER, TOKEN_LTEQ, 0 )
    LexInsertKeyword ( ">=", TOKEN_OPER, TOKEN_GTEQ, 0 )
    LexInsertKeyword ( "+", TOKEN_OPER, TOKEN_PLUS, 0 )
    LexInsertKeyword ( "-", TOKEN_OPER, TOKEN_MINUS, 0 )
    LexInsertKeyword ( "/", TOKEN_OPER, TOKEN_DIVIDE, 0 )
    LexInsertKeyword ( "%", TOKEN_OPER, TOKEN_MODULO, 0 )
    LexInsertKeyword ( ".", TOKEN_OPER, TOKEN_DOT, 0 )
    LexInsertKeyword ( "@", TOKEN_STATEMENT, TOKEN_LABEL, 0 )
    LexInsertKeyword ( "$", TOKEN_OPER, TOKEN_BITXOR, 0 )
    LexInsertKeyword ( "<<", TOKEN_OPER, TOKEN_LEFTSHIFT, 0 )
    LexInsertKeyword ( ">>", TOKEN_OPER, TOKEN_RIGHTSHIFT, 0 )
    LexInsertKeyword ( "~", TOKEN_OPER, TOKEN_BITNOT, 0 )
    LexInsertKeyword ( "*", TOKEN_OPER, TOKEN_MUL, 0 )
    LexInsertKeyword ( "...", TOKEN_ARGSPEC, TOKEN_VARARG, 0 )

    LexInsertKeyword ( "[", TOKEN_OPER, TOKEN_LBRACKET, 0 )
    LexInsertKeyword ( "^", TOKEN_OPER, TOKEN_CARET, 0 )
    LexInsertKeyword ( "(", TOKEN_OPER, TOKEN_LPAREN, 0 )

    LexInsertKeyword ( "=", TOKEN_ASSIGN, TOKEN_EQUALS, 0 )
    LexInsertKeyword ( "+=", TOKEN_ASSIGN, TOKEN_PLUSEQUALS, 0 )
    LexInsertKeyword ( "-=", TOKEN_ASSIGN, TOKEN_MINUSEQUALS, 0 )
    LexInsertKeyword ( "*=", TOKEN_ASSIGN, TOKEN_MULEQUALS, 0 )
    LexInsertKeyword ( "/=", TOKEN_ASSIGN, TOKEN_DIVEQUALS, 0 )
    LexInsertKeyword ( "%=", TOKEN_ASSIGN, TOKEN_MODEQUALS, 0 )
    LexInsertKeyword ( "&=", TOKEN_ASSIGN, TOKEN_ANDEQUALS, 0 )
    LexInsertKeyword ( "|=", TOKEN_ASSIGN, TOKEN_OREQUALS, 0 )
    LexInsertKeyword ( "$=", TOKEN_ASSIGN, TOKEN_XOREQUALS, 0 )
    LexInsertKeyword ( "<<=", TOKEN_ASSIGN, TOKEN_LSHEQUALS, 0 )
    LexInsertKeyword ( ">>=", TOKEN_ASSIGN, TOKEN_RSHEQUALS, 0 )
END