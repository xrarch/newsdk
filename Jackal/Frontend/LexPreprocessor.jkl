//
// Inline preprocessor for the lexer. Invoked when the tokenizer stumbles on a
// '#' character inbetween tokens.
//

#INCLUDE "<inc>/Lexer.hjk"

#DEFINE TargetInfo [JklTargetInfo]

PUBLIC LexAsmBlockListHead : ^LexAsmBlock = NULLPTR
PUBLIC LexAsmBlockListTail : ^LexAsmBlock = NULLPTR
PUBLIC LexCurrentFunctionSymbol : ^LexSymbol

LexLastExpansionFunction : ^LexSymbol

#INCLUDE "../../Cf/CfLexPreprocessor.jkl"

FN (LexDirectiveParseF) LexParseAsm ()

    IF LexFalseCount THEN
        // This region is being compiled out. Just collect the value and return.

        token : LexToken
        buffer : TlDynamicBuffer

        TlInitializeDynamicBuffer ( &buffer )

        LexCollectValue (
            &token, // token
            &buffer, // buffer
            TRUE, // ignore
        )

        TlUninitializeDynamicBuffer ( &buffer )

        LEAVE
    END

    asmblock : ^LexAsmBlock

    status := TlBumpAlloc (
        SIZEOF LexAsmBlock, // bytes
        OUT asmblock, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate asm block", 0, 0, 0 )
    END

    TlInitializeDynamicBuffer ( &asmblock^.Contents )

    LexCollectValue (
        &asmblock^.Token, // token
        &asmblock^.Contents, // buffer
        FALSE, // ignore
    )

    IF LexCurrentSection == &LexDefaultSection THEN
        asmblock^.Section = &LexTextSection

    ELSE
        asmblock^.Section = LexCurrentSection
    END

    asmblock^.Next = NULLPTR

    IF NOT LexAsmBlockListTail THEN
        LexAsmBlockListHead = asmblock
    ELSE
        LexAsmBlockListTail^.Next = asmblock
    END

    LexAsmBlockListTail = asmblock
END

FN (LexDirectiveParseF) LexParseSection ()

    // Parse the section directive. Causes the next symbol to be declared to be
    // placed in the specified section.

    str : TlDynamicBuffer
    token : LexToken

    TlInitializeDynamicBuffer ( &str )

    LexCollectString (
        &token, // token
        &str, // buffer
    )

    IF LexFalseCount THEN
        // We're in a region that is being conditionally compiled out, so
        // do nothing except collect that string from the source stream.

        TlUninitializeDynamicBuffer ( &str )

        LEAVE
    END

    // Validate that the name isn't too long.

    IF str.Count >= LEX_DIRECTIVE_MAX - 1 THEN
        LexError ( &token, "Section name too long\n" )
    END

    section := LexLookupSection (
        &str.Buffer[0], // name
    )

    TlUninitializeDynamicBuffer ( &str )

    // Set the next symbol section.

    LexNextSymbolSection = section
END

FN (LexDirectiveParseF) LexParseEnterSection ()

    // Parse the enter section directive. Causes subsequent symbols to be placed
    // in the specified section until the next leave section directive.

    str : TlDynamicBuffer
    token : LexToken

    TlInitializeDynamicBuffer ( &str )

    LexCollectString (
        &token, // token
        &str, // buffer
    )

    IF LexFalseCount THEN
        // We're in a region that is being conditionally compiled out, so
        // do nothing except collect that string from the source stream.

        TlUninitializeDynamicBuffer ( &str )

        LEAVE
    END

    // Validate that the name isn't too long.

    IF str.Count >= LEX_DIRECTIVE_MAX - 1 THEN
        LexError ( &token, "Section name too long\n" )
    END

    section := LexLookupSection (
        &str.Buffer[0], // name
    )

    TlUninitializeDynamicBuffer ( &str )

    // Push the section.

    LexPushSection ( section )
END

FN (LexDirectiveParseF) LexParseLeaveSection ()

    // Parse the leave section directive. Pops the section stack.

    IF LexFalseCount THEN
        LEAVE
    END

    popped := LexPopSection ()

    IF NOT popped THEN
        LexError ( &LexDirectiveToken, "Section stack was empty\n" )
    END
END

FN LexInitializePreprocessorConsumer ()

    // Initialize the consumer-specific parts of the preprocessor.

    LexDefineSpecialMacro ( "JKL_FUNC_NAME", LEX_FUNC_NAME )

    LexInsertDirective ( "ASM", &LexParseAsm )
    LexInsertDirective ( "SECTION", &LexParseSection )
    LexInsertDirective ( "ENTERSECTION", &LexParseEnterSection )
    LexInsertDirective ( "LEAVESECTION", &LexParseLeaveSection )
END