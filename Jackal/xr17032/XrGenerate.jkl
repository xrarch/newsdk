//
// Implements the XR/17032 code generator.
//

#INCLUDE "<inc>/Target.hjk"
#INCLUDE "<inc>/XrSdkAsm.hjk"

// FORWARD
EXTERN FN (JklTargetF) XrCompile ()

// FORWARD
EXTERN FN (JklValueNumberF) XrValueNumber (
    IN constant : UWORD,
) : UBYTE

// FORWARD
EXTERN FN (JklIsUnconditionalF) XrIsUnconditional (
    IN inst : ^LirInstruction,
) : UBYTE

// FORWARD
EXTERN XrLirInfo : LirTargetInfoRecord

PUBLIC XrTargetInfo : JklTargetInfoRecord = {
    [Name] = "xr17032",
    [EntryFunc] = &XrCompile,
    [ValueNumberConstantFunc] = &XrValueNumber,
    [IsUnconditionalFunc] = &XrIsUnconditional,
    [FoldStackAddr] = TRUE,
    [LirInfo] = &XrLirInfo,
    [ConstantMask] = 0xFFFFFFFF,
    [PointerMask] = 0xFFFFFFFF,
    [StackAlignment] = 4,
    [PointerAlignment] = 4,
    [PointerSize] = 4,
    [CodeAlignment] = 4,
    [LargestPrimitive] = PRIM_TYPE_ULONG,
    [LargestSignedPrimitive] = PRIM_TYPE_LONG,
    [Bits] = 32,
    [SupportedTypes] = {
        [PRIM_TYPE_VOID] = TRUE,
        [PRIM_TYPE_UBYTE] = TRUE,
        [PRIM_TYPE_UINT] = TRUE,
        [PRIM_TYPE_ULONG] = TRUE,
        [PRIM_TYPE_UQUAD] = FALSE,
        [PRIM_TYPE_BYTE] = TRUE,
        [PRIM_TYPE_INT] = TRUE,
        [PRIM_TYPE_LONG] = TRUE,
        [PRIM_TYPE_QUAD] = FALSE,
    },
    [PrimitiveAlignment] = {
        [PRIM_TYPE_VOID] = 1,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
    [PrimitiveSize] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
}

ENUM XrRegisters : UBYTE
    XR_NULL,

    XR_ZERO,
    XR_T0,
    XR_T1,
    XR_T2,
    XR_T3,
    XR_T4,
    XR_T5,
    XR_A0,
    XR_A1,
    XR_A2,
    XR_A3,
    XR_S0,
    XR_S1,
    XR_S2,
    XR_S3,
    XR_S4,
    XR_S5,
    XR_S6,
    XR_S7,
    XR_S8,
    XR_S9,
    XR_S10,
    XR_S11,
    XR_S12,
    XR_S13,
    XR_S14,
    XR_S15,
    XR_S16,
    XR_S17,

    XR_SP,
    XR_LR,

    XR_REG_MAX,
END

XrRegisterNames : ^UBYTE[XR_REG_MAX] = {
    [XR_ZERO] = "zero",
    [XR_T0] = "t0",
    [XR_T1] = "t1",
    [XR_T2] = "t2",
    [XR_T3] = "t3",
    [XR_T4] = "t4",
    [XR_T5] = "t5",
    [XR_A0] = "a0",
    [XR_A1] = "a1",
    [XR_A2] = "a2",
    [XR_A3] = "a3",
    [XR_S0] = "s0",
    [XR_S1] = "s1",
    [XR_S2] = "s2",
    [XR_S3] = "s3",
    [XR_S4] = "s4",
    [XR_S5] = "s5",
    [XR_S6] = "s6",
    [XR_S7] = "s7",
    [XR_S8] = "s8",
    [XR_S9] = "s9",
    [XR_S10] = "s10",
    [XR_S11] = "s11",
    [XR_S12] = "s12",
    [XR_S13] = "s13",
    [XR_S14] = "s14",
    [XR_S15] = "s15",
    [XR_S16] = "s16",
    [XR_S17] = "s17",
    [XR_SP] = "sp",
    [XR_LR] = "lr",
}

// Note that these have little relation to machine instructions but rather to
// the assembler's set of "pseudo-instructions".

ENUM XrInstructionTypes : UBYTE
    XR_INST_NULL,

    XR_B,
    XR_RET,
    XR_JR,
    XR_MOV_REG,
    XR_LI,
    XR_LA,
    XR_LSHI,
    XR_RSHI,
    XR_ASHI,
    XR_RORI,
    XR_JAL,
    XR_J,
    XR_BEQ,
    XR_BNE,
    XR_BLT,
    XR_BGT,
    XR_BLE,
    XR_BGE,
    XR_BPE,
    XR_BPO,
    XR_ADDI,
    XR_SUBI,
    XR_SLTI,
    XR_SLTI_SIGNED,
    XR_ANDI,
    XR_XORI,
    XR_ORI,
    XR_LUI,
    XR_JALR,
    XR_ADD,
    XR_SUB,
    XR_SLT,
    XR_SLT_SIGNED,
    XR_AND,
    XR_XOR,
    XR_OR,
    XR_MOV_LOAD,
    XR_MOV_LOAD_INLINED,
    XR_MOV_STORE,
    XR_MOV_STORE_INLINED,
    XR_LSH,
    XR_RSH,
    XR_ASH,
    XR_ROR,
    XR_MUL,
    XR_DIV,
    XR_DIV_SIGNED,
    XR_MOD,
    XR_NOR,

    XR_INST_MAX,
END

XrInstructionNames : ^UBYTE[XR_INST_MAX] = {
    [XR_B] = "b",
    [XR_RET] = "ret",
    [XR_JR] = "jr",
    [XR_MOV_REG] = "mov",
    [XR_LI] = "li",
    [XR_LA] = "la",
    [XR_LSHI] = "lshi",
    [XR_RSHI] = "rshi",
    [XR_ASHI] = "ashi",
    [XR_RORI] = "rori",
    [XR_JAL] = "jal",
    [XR_J] = "j",
    [XR_BEQ] = "beq",
    [XR_BNE] = "bne",
    [XR_BLT] = "blt",
    [XR_BGT] = "bgt",
    [XR_BLE] = "ble",
    [XR_BPE] = "bpe",
    [XR_BPO] = "bpo",
    [XR_ADDI] = "addi",
    [XR_SUBI] = "subi",
    [XR_SLTI] = "slti",
    [XR_SLTI_SIGNED] = "slti signed",
    [XR_ANDI] = "andi",
    [XR_XORI] = "xori",
    [XR_ORI] = "ori",
    [XR_LUI] = "lui",
    [XR_JALR] = "jalr",
    [XR_ADD] = "add",
    [XR_SUB] = "sub",
    [XR_SLT] = "slt",
    [XR_SLT_SIGNED] = "slt signed",
    [XR_AND] = "and",
    [XR_XOR] = "xor",
    [XR_OR] = "or",
    [XR_MOV_LOAD] = "mov",
    [XR_MOV_LOAD_INLINED] = "mov",
    [XR_MOV_STORE] = "mov",
    [XR_MOV_STORE_INLINED] = "mov",
    [XR_LSH] = "lsh",
    [XR_RSH] = "rsh",
    [XR_ASH] = "ash",
    [XR_ROR] = "ror",
    [XR_MUL] = "mul",
    [XR_DIV] = "div",
    [XR_DIV_SIGNED] = "div signed",
    [XR_MOD] = "mod",
    [XR_NOR] = "nor",
}

ENUM XrBits : UBYTE
    XR_BITS_8,
    XR_BITS_16,
    XR_BITS_32,

    XR_BITS_MAX,
END

ENUM XrAccessType : UBYTE
    XR_ACCESS_NONE,
    XR_ACCESS_REGISTER,
    XR_ACCESS_ZERO,
    XR_ACCESS_IMM,
    XR_ACCESS_IMM_NAME,
    XR_ACCESS_IMM_STRING,
    XR_ACCESS_IMM_LABEL,
END

XrPrimTypeToBits : UBYTE[PRIM_TYPE_MAX] = {
    [PRIM_TYPE_BYTE] = XR_BITS_8,
    [PRIM_TYPE_INT] = XR_BITS_16,
    [PRIM_TYPE_LONG] = XR_BITS_32,

    [PRIM_TYPE_UBYTE] = XR_BITS_8,
    [PRIM_TYPE_UINT] = XR_BITS_16,
    [PRIM_TYPE_ULONG] = XR_BITS_32,

    [PRIM_TYPE_POINTER] = XR_BITS_32,
}

XrBitsToMaximumOffset : UWORD[XR_BITS_MAX] = {
    [XR_BITS_8] = 65536,
    [XR_BITS_16] = 131072,
    [XR_BITS_32] = 262144,
}

XrBitsOffsetMask : UBYTE[XR_BITS_MAX] = {
    [XR_BITS_8] = 0,
    [XR_BITS_16] = 1,
    [XR_BITS_32] = 3,
}

XrBitsNames : ^UBYTE[XR_BITS_MAX] = {
    [XR_BITS_8] = "byte",
    [XR_BITS_16] = "int",
    [XR_BITS_32] = "long",
}

ENUM XrShiftTypes : UBYTE
    XR_SHIFT_LSH,
    XR_SHIFT_RSH,
    XR_SHIFT_ASH,
    XR_SHIFT_ROR,

    XR_SHIFT_MAX,
END

XrShiftTypeNames : ^UBYTE[XR_SHIFT_MAX] = {
    [XR_SHIFT_LSH] = "LSH",
    [XR_SHIFT_RSH] = "RSH",
    [XR_SHIFT_ASH] = "ASH",
    [XR_SHIFT_ROR] = "ROR",
}

XrInstToShiftType : XrShiftTypes[IR_MAX] = {
    [IR_LEFT_SHIFT] = XR_SHIFT_LSH,
    [IR_RIGHT_SHIFT] = XR_SHIFT_RSH,
    [IR_RIGHT_SHIFT_SIGNED] = XR_SHIFT_ASH,
    [IR_ROTATE_RIGHT] = XR_SHIFT_ROR,
}

XrIrToImmOp : UBYTE[IR_MAX] = {
    [IR_BIT_AND] = XR_ANDI,
    [IR_BIT_OR] = XR_ORI,
    [IR_ADD] = XR_ADDI,
    [IR_SUBTRACT] = XR_SUBI,
    [IR_DIVIDE] = XR_INST_NULL,
    [IR_DIVIDE_SIGNED] = XR_INST_NULL,
    [IR_MODULO] = XR_INST_NULL,
    [IR_BIT_XOR] = XR_XORI,
    [IR_LEFT_SHIFT] = XR_LSHI,
    [IR_RIGHT_SHIFT] = XR_RSHI,
    [IR_RIGHT_SHIFT_SIGNED] = XR_ASHI,
    [IR_ROTATE_RIGHT] = XR_RORI,
    [IR_MULTIPLY] = XR_INST_NULL,

    [IR_BRANCH_EQUALS] = XR_SUBI,
    [IR_BRANCH_NOT_EQUALS] = XR_SUBI,
    [IR_BRANCH_LESS_THAN] = XR_SLTI,
    [IR_BRANCH_GREATER_THAN] = XR_SLTI,
    [IR_BRANCH_LTEQ] = XR_SLTI,
    [IR_BRANCH_GTEQ] = XR_SLTI,
    [IR_BRANCH_LESS_THAN_SIGNED] = XR_SLTI_SIGNED,
    [IR_BRANCH_GREATER_THAN_SIGNED] = XR_SLTI_SIGNED,
    [IR_BRANCH_LTEQ_SIGNED] = XR_SLTI_SIGNED,
    [IR_BRANCH_GTEQ_SIGNED] = XR_SLTI_SIGNED,

    [IR_COMPARE_EQUALS] = XR_SUBI,
    [IR_COMPARE_NOT_EQUALS] = XR_SUBI,
    [IR_COMPARE_LESS_THAN] = XR_SLTI,
    [IR_COMPARE_GREATER_THAN] = XR_SLTI,
    [IR_COMPARE_LTEQ] = XR_SLTI,
    [IR_COMPARE_GTEQ] = XR_SLTI,
    [IR_COMPARE_LESS_THAN_SIGNED] = XR_SLTI_SIGNED,
    [IR_COMPARE_GREATER_THAN_SIGNED] = XR_SLTI_SIGNED,
    [IR_COMPARE_LTEQ_SIGNED] = XR_SLTI_SIGNED,
    [IR_COMPARE_GTEQ_SIGNED] = XR_SLTI_SIGNED,
}

XrIrToRegOp : UBYTE[IR_MAX] = {
    [IR_BIT_AND] = XR_AND,
    [IR_BIT_OR] = XR_OR,
    [IR_ADD] = XR_ADD,
    [IR_SUBTRACT] = XR_SUB,
    [IR_DIVIDE] = XR_DIV,
    [IR_DIVIDE_SIGNED] = XR_DIV_SIGNED,
    [IR_MODULO] = XR_MOD,
    [IR_BIT_XOR] = XR_XOR,
    [IR_LEFT_SHIFT] = XR_LSH,
    [IR_RIGHT_SHIFT] = XR_RSH,
    [IR_RIGHT_SHIFT_SIGNED] = XR_ASH,
    [IR_ROTATE_RIGHT] = XR_ROR,
    [IR_MULTIPLY] = XR_MUL,

    [IR_BRANCH_EQUALS] = XR_SUB,
    [IR_BRANCH_NOT_EQUALS] = XR_SUB,
    [IR_BRANCH_LESS_THAN] = XR_SLT,
    [IR_BRANCH_GREATER_THAN] = XR_SLT,
    [IR_BRANCH_LTEQ] = XR_SLT,
    [IR_BRANCH_GTEQ] = XR_SLT,
    [IR_BRANCH_LESS_THAN_SIGNED] = XR_SLT_SIGNED,
    [IR_BRANCH_GREATER_THAN_SIGNED] = XR_SLT_SIGNED,
    [IR_BRANCH_LTEQ_SIGNED] = XR_SLT_SIGNED,
    [IR_BRANCH_GTEQ_SIGNED] = XR_SLT_SIGNED,

    [IR_COMPARE_EQUALS] = XR_SUB,
    [IR_COMPARE_NOT_EQUALS] = XR_SUB,
    [IR_COMPARE_LESS_THAN] = XR_SLT,
    [IR_COMPARE_GREATER_THAN] = XR_SLT,
    [IR_COMPARE_LTEQ] = XR_SLT,
    [IR_COMPARE_GTEQ] = XR_SLT,
    [IR_COMPARE_LESS_THAN_SIGNED] = XR_SLT_SIGNED,
    [IR_COMPARE_GREATER_THAN_SIGNED] = XR_SLT_SIGNED,
    [IR_COMPARE_LTEQ_SIGNED] = XR_SLT_SIGNED,
    [IR_COMPARE_GTEQ_SIGNED] = XR_SLT_SIGNED,
}

#DEFINE XR_BRANCH_FLIP 1
#DEFINE XR_BRANCH_NEG 2

XrBranchFlags : UBYTE[IR_MAX] = {
    [IR_BRANCH_EQUALS] = XR_BRANCH_NEG,
    [IR_BRANCH_GREATER_THAN] = XR_BRANCH_FLIP,
    [IR_BRANCH_LTEQ] = XR_BRANCH_FLIP | XR_BRANCH_NEG,
    [IR_BRANCH_GTEQ] = XR_BRANCH_NEG,
    [IR_BRANCH_GREATER_THAN_SIGNED] = XR_BRANCH_FLIP,
    [IR_BRANCH_LTEQ_SIGNED] = XR_BRANCH_FLIP | XR_BRANCH_NEG,
    [IR_BRANCH_GTEQ_SIGNED] = XR_BRANCH_NEG,

    [IR_COMPARE_EQUALS] = XR_BRANCH_NEG,
    [IR_COMPARE_GREATER_THAN] = XR_BRANCH_FLIP,
    [IR_COMPARE_LTEQ] = XR_BRANCH_FLIP | XR_BRANCH_NEG,
    [IR_COMPARE_GTEQ] = XR_BRANCH_NEG,
    [IR_COMPARE_GREATER_THAN_SIGNED] = XR_BRANCH_FLIP,
    [IR_COMPARE_LTEQ_SIGNED] = XR_BRANCH_FLIP | XR_BRANCH_NEG,
    [IR_COMPARE_GTEQ_SIGNED] = XR_BRANCH_NEG,
}

XrPrimTypeToSignShift : UBYTE[PRIM_TYPE_MAX] = {
    [PRIM_TYPE_INT] = 16,
    [PRIM_TYPE_BYTE] = 24,
}

XrTmps : LirRegister[3]
XrSp : LirRegister
XrLr : LirRegister
XrZero : LirRegister
XrCalleeSaved : LirRegister[XR_S17 - XR_S0 + 1]
XrArg : LirRegister[XR_A3 - XR_A0 + 1]

FN XrCreateInstruction (
    IN type : LirInstructionType,
    IN machtype : UBYTE,
) : ^LirInstruction

    inst := LirCreateInstruction (
        type, // type
        machtype, // machtype
    )

    inst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_NONE
    inst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_NONE
    inst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_NONE

    inst^.Body.Machine.Xr.Op1.Constant = 0
    inst^.Body.Machine.Xr.Op2.Constant = 0
    inst^.Body.Machine.Xr.Op3.Constant = 0

    inst^.Body.Machine.Xr.ShiftAmount = 0
    inst^.Body.Machine.Xr.BitSize = XR_BITS_32

    RETURN inst
END

FN XrFillAccess (
    IN inst : ^IrInstruction,
    IN lirinst : ^LirInstruction,
)

    // Fill Source2 and Source3 of the lirinst instruction with relevant
    // junk for this access. It's always in that spot for both loads and stores.
    // Source1 is the value to store, if relevant.

    bits := XrPrimTypeToBits[inst^.Body.LoadStore.Type]

    lirinst^.Body.Machine.Xr.BitSize = bits

    // Base is always a register.

    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    srcvar := inst^.Source1
    srcinst := srcvar^.DefinedBy

    IF NOT srcinst THEN
        // Just fill it with a zero offset.

        lirinst^.Source2 = LirGetRegister ( inst^.Source1 )
        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
        lirinst^.Body.Machine.Xr.Op3.Constant = 0

        LEAVE
    END

    IF srcinst^.Type == IR_STACK_ADDR THEN
        // It's on the stack frame, this is an SP + OFF. 

        symbol := srcinst^.Body.Addr.Symbol

        off := srcinst^.Body.Addr.Offset + IrGetStackOffset (
            LirCurrentFunction, // func
            symbol, // symbol
        ) + LirCurrentFunction^.ScratchAreaSize

        IF off < XrBitsToMaximumOffset[bits] AND
            off & XrBitsOffsetMask[bits] == 0 THEN

            // Great! We can do this directly.

            lirinst^.Body.Machine.Xr.Op3.Constant = off
            lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM

            lirinst^.Source2 = &XrSp

            LEAVE
        END

    ELSEIF srcinst^.Type == IR_ADDR THEN
        // Gotta be a named imm.
        // If the refcount on the variable is low, we can inline this by a
        // pseudo-instruction. Above four uses of it, it's more worthwhile to
        // allow XrSelectAddr to calculate the address into a reusable temporary
        // register.

        IF srcvar^.Opt.Dve.References <= 4 THEN
            lirinst^.Body.Machine.Xr.Op2.Constant =
                CAST srcinst^.Body.Addr.Symbol TO UWORD

            lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_IMM_NAME

            IF lirinst^.MachineInstruction == XR_MOV_STORE THEN
                lirinst^.MachineInstruction = XR_MOV_STORE_INLINED

                // Inlined stores require a temp register to trash.

                lirinst^.Source3 = LirCreateRegister ()

                // The temp register must be live-in to the inlined store so
                // that it isn't assigned to the same one as any of the inlined
                // store's operands. We do this by creating a LIR_JUNK
                // instruction who defines this temporary, and inserting it
                // before us.

                junkinst := XrCreateInstruction (
                    LIR_JUNK, // type
                    0, // machtype
                )

                junkinst^.Defines = lirinst^.Source3

                LirInsertInstructionTail ( junkinst )

            ELSE
                lirinst^.MachineInstruction = XR_MOV_LOAD_INLINED
            END

            LEAVE
        END

    ELSEIF srcinst^.Type == IR_ADD THEN
        // This is an offset by a base. Fill in the base register.

        lirinst^.Source2 = LirSelectOrGetRegister ( srcinst^.Source1 )

        inst2 := srcinst^.Source2^.DefinedBy

        IF inst2 THEN
            IF inst2^.Type == IR_CONSTANT AND
                inst2^.Body.Constant.Constant < XrBitsToMaximumOffset[bits] AND
                inst2^.Body.Constant.Constant & XrBitsOffsetMask[bits] == 0 THEN

                // Great! We can do this constant offset directly.

                lirinst^.Body.Machine.Xr.Op3.Constant =
                    inst2^.Body.Constant.Constant

                lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM

                LEAVE

            ELSEIF inst2^.Type == IR_LEFT_SHIFT OR
                inst2^.Type == IR_RIGHT_SHIFT OR
                inst2^.Type == IR_RIGHT_SHIFT_SIGNED OR
                inst2^.Type == IR_ROTATE_RIGHT THEN

                // If the right side of the shift is a constant less than 32,
                // we can perform it directly in the instruction.

                IF inst2^.Source2^.DefinedBy AND
                    inst2^.Source2^.DefinedBy^.Type == IR_CONSTANT AND
                    inst2^.Source2^.DefinedBy^.Body.Constant.Constant < 32 THEN

                    lirinst^.Source3 =
                        LirSelectOrGetRegister ( inst2^.Source1 )

                    lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER

                    lirinst^.Body.Machine.Xr.ShiftType =
                        XrInstToShiftType[inst2^.Type]

                    lirinst^.Body.Machine.Xr.ShiftAmount =
                        inst2^.Source2^.DefinedBy^.Body.Constant.Constant

                    LEAVE
                END
            END
        END

        // Just offset by a register.

        lirinst^.Source3 = LirSelectOrGetRegister ( srcinst^.Source2 )
        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER

        LEAVE
    END

    // Just fill it with a zero offset from the register.

    lirinst^.Source2 = LirSelect ( srcinst )

    lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
    lirinst^.Body.Machine.Xr.Op3.Constant = 0
END

FN (LirSelectF) XrSelectLoad (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a mem-to-reg MOV instruction.

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_LOAD, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    XrFillAccess (
        inst, // inst
        lirinst, // lirinst
    )

    LirInsertInstructionTail ( lirinst )

    // If this was a signed type, less than 32 bits, make sure to sign extend.

    IF inst^.Body.LoadStore.Type == PRIM_TYPE_BYTE OR
        inst^.Body.LoadStore.Type == PRIM_TYPE_INT THEN

        // Generate a left shift and then an arithmetic right shift.

        lirinst = XrCreateInstruction (
            LIR_MACH_INST, // type
            XR_LSHI, // machtype
        )

        lirinst^.Defines = defreg
        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

        lirinst^.Source2 = defreg
        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM

        lirinst^.Body.Machine.Xr.Op3.Constant =
            XrPrimTypeToSignShift[inst^.Body.LoadStore.Type]

        LirInsertInstructionTail ( lirinst )

        lirinst = XrCreateInstruction (
            LIR_MACH_INST, // type
            XR_ASHI, // machtype
        )

        lirinst^.Defines = defreg
        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

        lirinst^.Source2 = defreg
        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM

        lirinst^.Body.Machine.Xr.Op3.Constant =
            XrPrimTypeToSignShift[inst^.Body.LoadStore.Type]

        LirInsertInstructionTail ( lirinst )
    END

    RETURN defreg
END

FN (LirSelectF) XrSelectStore (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a reg-to-mem MOV instruction.

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_STORE, // machtype
    )

    XrFillAccess (
        inst, // inst
        lirinst, // lirinst
    )

    // If the source is an imm between -16 and 15, we can do it in the
    // instruction. The instruction also needs to either have an immediate
    // offset (XR_ACCESS_IMM on Op3) or be an inline store
    // (XR_ACCESS_IMM_NAME on Op2).

    defby := inst^.Source2^.DefinedBy

    IF defby AND
        defby^.Type == IR_CONSTANT AND
        (defby^.Body.Constant.Constant & 0xFFFFFFFF >= 0xFFFFFFF0 OR
        defby^.Body.Constant.Constant < 16) AND
        (lirinst^.Body.Machine.Xr.Op3.AccessType == XR_ACCESS_IMM OR
        lirinst^.Body.Machine.Xr.Op2.AccessType == XR_ACCESS_IMM_NAME) THEN

        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_IMM

        lirinst^.Body.Machine.Xr.Op1.Constant =
            defby^.Body.Constant.Constant & 0xFFFFFFFF

    ELSE
        lirinst^.Source1 = LirSelectOrGetRegister ( inst^.Source2 )
        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
    END

    LirInsertInstructionTail ( lirinst )

    RETURN NULLPTR
END

FN XrFillConstant (
    IN lirinst : ^LirInstruction,
    IN const : UWORD,
)

    // Make the given LIR instruction load the given constant.

    const &= 0xFFFFFFFF

    IF const < 65536 THEN
        lirinst^.MachineInstruction = XR_LI

        lirinst^.Body.Machine.Xr.Op2.Constant = const
        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_IMM

    ELSEIF const >= 0xFFFF0001 THEN
        lirinst^.MachineInstruction = XR_SUBI

        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_ZERO

        lirinst^.Body.Machine.Xr.Op3.Constant = (~const + 1) & 0xFFFFFFFF
        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM

    ELSEIF const & 0xFFFF == 0 THEN
        lirinst^.MachineInstruction = XR_LUI

        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_ZERO

        lirinst^.Body.Machine.Xr.Op3.Constant = const
        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM

    ELSE
        lirinst^.MachineInstruction = XR_LA

        lirinst^.Body.Machine.Xr.Op2.Constant = const
        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_IMM
    END
END

FN XrGenerateConstant (
    IN tmp : ^LirRegister,
    IN const : UWORD,
    IN afterinst : ^LirInstruction,
    IN beforeinst : ^LirInstruction,
) : ^LirRegister

    // Create an instruction to load the given constant.

    IF NOT tmp THEN
        tmp = LirCreateRegister ()
    END

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_INST_NULL, // machtype
    )

    lirinst^.Defines = tmp
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    XrFillConstant (
        lirinst, // lirinst
        const, // const
    )

    IF afterinst THEN
        LirInsertInstructionAfter (
            afterinst, // afterinst
            lirinst, // inst
        )

    ELSEIF beforeinst THEN
        LirInsertInstructionBefore (
            beforeinst, // beforeinst
            lirinst, // inst
        )

    ELSE
        LirInsertInstructionTail ( lirinst )
    END

    RETURN tmp
END

FN (LirSelectF) XrSelectAddr (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate an imm-to-reg MOV instruction.

    IF inst^.Defines^.DefinedBy AND
        inst^.Type == IR_CONSTANT AND
        inst^.Body.Constant.Constant == 0 THEN

        RETURN &XrZero
    END

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_INST_NULL, // machtype
    )

    lirinst^.Defines = defreg

    IF inst^.Type == IR_ADDR THEN
        lirinst^.MachineInstruction = XR_LA

        lirinst^.Body.Machine.Xr.Op2.Constant =
            CAST inst^.Body.Addr.Symbol TO UWORD
    
        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_IMM_NAME

    ELSEIF inst^.Type == IR_STRING_ADDR THEN
        // This will get resolved to a label pointing to a string during
        // code emission.

        lirinst^.MachineInstruction = XR_LA

        lirinst^.Body.Machine.Xr.Op2.Constant =
            CAST inst^.Body.String.String TO UWORD

        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_IMM_STRING
    
    ELSEIF inst^.Type == IR_CONSTANT THEN
        XrFillConstant (
            lirinst, // lirinst
            inst^.Body.Constant.Constant, // const
        )
    END

    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) XrSelectStackAddr (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate an ADDI DEST, SP, OFF instruction.

    symbol := inst^.Body.Addr.Symbol

    off := IrGetStackOffset (
        LirCurrentFunction, // func
        symbol, // symbol
    ) + inst^.Body.Addr.Offset + LirCurrentFunction^.ScratchAreaSize

    IF off == 0 AND inst^.Defines^.DefinedBy THEN
        // Oh, just use SP directly.

        RETURN &XrSp
    END

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_INST_NULL, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    lirinst^.Source2 = &XrSp
    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    IF off < 65536 THEN
        lirinst^.MachineInstruction = XR_ADDI

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
        lirinst^.Body.Machine.Xr.Op3.Constant = off

    ELSE
        lirinst^.MachineInstruction = XR_ADD

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER

        lirinst^.Source3 = XrGenerateConstant (
            NULLPTR, // tmp
            off, // const
            NULLPTR, // afterinst
            NULLPTR, // beforeinst
        )
    END

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) XrSelectMove (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Select the most appropriate instruction.

    def := inst^.Defines
    src := inst^.Source1
    srcreg : ^LirRegister

    IF src^.DefinedBy THEN
        // The source is a temporary.

        IF src^.Opt.Dve.References == 1 THEN
            // This is the only reference to the temporary, so don't bother
            // sharing; twiddle its defining instruction to define us and then
            // generate that instead.

            src^.DefinedBy^.Defines = def

            RETURN LirSelect ( src^.DefinedBy )
        END

        srcreg = LirSelect ( src^.DefinedBy )

    ELSE
        srcreg = LirGetRegister ( src )
    END

    // Generate an XR/17032 reg-to-reg MOV instruction.

    defreg := LirGetRegister ( def )

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_REG, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Source2 = srcreg

    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    LirMoveHint ( defreg, srcreg )

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN XrGeneratePreallocatedMov (
    IN srcreg : ^LirRegister,
    IN machreg : ^LirRegister,
    IN from : UBYTE,
) : ^LirRegister

    // Hint.

    srcreg^.Hint = machreg^.MachineRegister

    // Generate MOV to preallocated reg.

    movinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_REG, // machtype
    )

    IF from THEN
        movinst^.Source2 = machreg
        movinst^.Defines = srcreg

    ELSE
        movinst^.Defines = machreg
        movinst^.Source2 = srcreg
    END

    movinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
    movinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    LirInsertInstructionTail ( movinst )

    IF from THEN
        RETURN srcreg

    ELSE
        RETURN machreg
    END
END

FN (LirSelectF) XrSelectReturn (
    IN inst : ^IrInstruction,
) : ^LirRegister

    retval : ^LirRegister = NULLPTR

    IF inst^.Source1 THEN
        srcreg := LirSelectOrGetRegister ( inst^.Source1 )

        retval = XrGeneratePreallocatedMov (
            srcreg, // srcreg
            &XrArg[XR_A3 - XR_A0], // machreg
            FALSE, // from
        )
    END

    // Add an unconditional branch to the epilogue.

    lirinst := XrCreateInstruction (
        LIR_BRANCH, // type
        XR_B, // machtype
    )

    lirinst^.TypeBody.Branch.Label =
        LirGetLabel ( LirCurrentFunction^.EpilogueLabel )

    LirInsertInstructionTail ( lirinst )

    RETURN NULLPTR
END

FN XrGenerateFalseBranch (
    IN inst : ^IrInstruction,
)

    IF inst^.Body.Branch.FalseLabel == inst^.Next THEN
        // The false label is the fall-through, don't generate the false branch.

        LEAVE
    END

    // Generate the false branch.

    jmpinst := XrCreateInstruction (
        LIR_BRANCH, // type
        XR_B, // machtype
    )

    jmpinst^.TypeBody.Branch.Label =
        LirGetLabel ( inst^.Body.Branch.FalseLabel )

    LirInsertInstructionTail ( jmpinst )
END

FN (LirSelectF) XrSelectZeroBranch (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF IrIsUselessBranch ( inst ) THEN
        RETURN NULLPTR
    END

    jmpinst := XrCreateInstruction (
        LIR_BRANCH, // type
        XR_INST_NULL, // machtype
    )

    IF inst^.Type == IR_BRANCH_NONZERO THEN
        jmpinst^.MachineInstruction = XR_BNE

    ELSE
        jmpinst^.MachineInstruction = XR_BEQ
    END

    jmpinst^.Source1 = LirSelectOrGetRegister ( inst^.Source1 )
    jmpinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    jmpinst^.TypeBody.Branch.Label = LirGetLabel ( inst^.Body.Branch.TrueLabel )

    LirInsertInstructionTail ( jmpinst )

    // Generate an unconditional branch to the false label if required.

    XrGenerateFalseBranch ( inst )

    RETURN NULLPTR
END

FN XrGenerateArithmetic (
    IN defreg : ^LirRegister,
    IN src1 : ^IrVariable,
    IN src2 : ^IrVariable,
    IN immop : XrInstructionTypes,
    IN regop : XrInstructionTypes,
)

    // Creates a LIR instruction that performs the given arithmetic operation.
    // Tries to fit a right-side constant in, if immop is non-null.

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_INST_NULL, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    lirinst^.Source2 = LirSelectOrGetRegister ( src1 )
    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    defby := src2^.DefinedBy

    IF immop AND
        defby AND
        defby^.Type == IR_CONSTANT AND
        defby^.Body.Constant.Constant < 65536 THEN

        lirinst^.MachineInstruction = immop

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM

        lirinst^.Body.Machine.Xr.Op3.Constant =
            src2^.DefinedBy^.Body.Constant.Constant

    ELSEIF defby AND
        (defby^.Type == IR_LEFT_SHIFT OR
        defby^.Type == IR_RIGHT_SHIFT OR
        defby^.Type == IR_RIGHT_SHIFT_SIGNED OR
        defby^.Type == IR_ROTATE_RIGHT) AND
        defby^.Source2^.DefinedBy AND
        defby^.Source2^.DefinedBy^.Type == IR_CONSTANT AND
        defby^.Source2^.DefinedBy^.Body.Constant.Constant < 32 THEN

        lirinst^.MachineInstruction = regop

        lirinst^.Source3 =
            LirSelectOrGetRegister ( defby^.Source1 )

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER

        lirinst^.Body.Machine.Xr.ShiftType =
            XrInstToShiftType[defby^.Type]

        lirinst^.Body.Machine.Xr.ShiftAmount =
            defby^.Source2^.DefinedBy^.Body.Constant.Constant

    ELSE
        lirinst^.MachineInstruction = regop

        lirinst^.Source3 = LirSelectOrGetRegister ( src2 )

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER
    END

    LirInsertInstructionTail ( lirinst )
END

FN (LirSelectF) XrSelectArithmetic (
    IN inst : ^IrInstruction,
) : ^LirRegister

    defreg := LirGetRegister ( inst^.Defines )

    XrGenerateArithmetic (
        defreg, // defreg
        inst^.Source1, // src1
        inst^.Source2, // src2
        XrIrToImmOp[inst^.Type], // immop
        XrIrToRegOp[inst^.Type], // regop
    )

    RETURN defreg
END

FN (LirSelectF) XrSelectNot (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Output:
    //
    //  SLTI RD, RA, 1

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_SLTI, // machtype
    )

    defreg := LirGetRegister ( inst^.Defines )

    lirinst^.Defines = defreg
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    lirinst^.Source2 = LirSelectOrGetRegister ( inst^.Source1 )
    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
    lirinst^.Body.Machine.Xr.Op3.Constant = 1

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) XrSelectBitNot (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Output:
    //
    //  NOR RD, RA, RA

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_NOR, // machtype
    )

    defreg := LirGetRegister ( inst^.Defines )

    lirinst^.Defines = defreg
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    lirinst^.Source2 = LirSelectOrGetRegister ( inst^.Source1 )
    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    lirinst^.Source3 = lirinst^.Source2
    lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) XrSelectBranch (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF IrIsUselessBranch ( inst ) THEN
        RETURN NULLPTR
    END

    tmp := LirCreateRegister ()

    flags := XrBranchFlags[inst^.Type]

    src1 := inst^.Source1
    src2 := inst^.Source2

    IF flags & XR_BRANCH_FLIP THEN
        tmpsrc := src1

        src1 = src2
        src2 = tmpsrc
    END

    XrGenerateArithmetic (
        tmp, // defreg
        src1, // src1
        src2, // src2
        XrIrToImmOp[inst^.Type], // immop
        XrIrToRegOp[inst^.Type], // regop
    )

    jmpinst := XrCreateInstruction (
        LIR_BRANCH, // type
        XR_INST_NULL, // machtype
    )

    IF flags & XR_BRANCH_NEG THEN
        jmpinst^.MachineInstruction = XR_BEQ

    ELSE
        jmpinst^.MachineInstruction = XR_BNE
    END

    jmpinst^.Source1 = tmp
    jmpinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    jmpinst^.TypeBody.Branch.Label = LirGetLabel ( inst^.Body.Branch.TrueLabel )

    LirInsertInstructionTail ( jmpinst )

    // Generate an unconditional branch to the false label if required.

    XrGenerateFalseBranch ( inst )

    RETURN NULLPTR
END

FN (LirSelectF) XrSelectCompare (
    IN inst : ^IrInstruction,
) : ^LirRegister

    defreg := LirGetRegister ( inst^.Defines )

    flags := XrBranchFlags[inst^.Type]

    src1 := inst^.Source1
    src2 := inst^.Source2

    IF flags & XR_BRANCH_FLIP THEN
        tmpsrc := src1

        src1 = src2
        src2 = tmpsrc
    END

    XrGenerateArithmetic (
        defreg, // defreg
        src1, // src1
        src2, // src2
        XrIrToImmOp[inst^.Type], // immop
        XrIrToRegOp[inst^.Type], // regop
    )

    IF flags & XR_BRANCH_NEG THEN
        lirinst := XrCreateInstruction (
            LIR_MACH_INST, // type
            XR_SLTI, // machtype
        )

        lirinst^.Defines = defreg
        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

        lirinst^.Source2 = defreg
        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
        lirinst^.Body.Machine.Xr.Op3.Constant = 1

        LirInsertInstructionTail ( lirinst )
    END

    RETURN defreg
END

FN (LirSelectF) XrSelectJump (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF inst^.Body.Jump.Label == inst^.Next THEN
        // Don't generate the jump; allow fall-through.

        RETURN NULLPTR
    END

    jmpinst := XrCreateInstruction (
        LIR_BRANCH, // type
        XR_B, // machtype
    )

    jmpinst^.TypeBody.Branch.Label = LirGetLabel ( inst^.Body.Jump.Label )

    LirInsertInstructionTail ( jmpinst )

    RETURN NULLPTR
END

FN XrFillForStackAccess (
    IN tmp : ^LirRegister,
    IN beforeinst : ^LirInstruction,
    IN afterinst : ^LirInstruction,
    IN lirinst : ^LirInstruction,
    IN off : ULONG,
    IN insert : UBYTE,
)

    lirinst^.Source2 = &XrSp

    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    IF off < 262144 AND off & 3 == 0 THEN
        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
        lirinst^.Body.Machine.Xr.Op3.Constant = off
    
    ELSE
        // The offset is GINORMOUS (or unaligned for some reason).
        // Load it into a constant.

        lirinst^.Source3 = XrGenerateConstant (
            tmp, // tmp
            off, // const
            afterinst, // afterinst
            beforeinst, // beforeinst
        )

        IF afterinst THEN
            afterinst = afterinst^.Next
        END

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER
    END

    IF insert THEN
        LirInsertInstructionAfter (
            afterinst, // afterinst
            lirinst, // lirinst
        )
    END
END

FN XrGenerateStoreToStack (
    IN srcreg : ^LirRegister,
    IN srcvar : ^IrVariable,
    IN off : ULONG,
)

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_STORE, // machtype
    )

    IF NOT srcreg THEN
        defby := srcvar^.DefinedBy

        IF defby AND
            defby^.Type == IR_CONSTANT AND
            (defby^.Body.Constant.Constant & 0xFFFFFFFF >= 0xFFFFFFF0 OR
            defby^.Body.Constant.Constant < 16) THEN

            lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_IMM

            lirinst^.Body.Machine.Xr.Op1.Constant =
                defby^.Body.Constant.Constant & 0xFFFFFFFF

        ELSE
            srcreg = LirSelectOrGetRegister ( srcvar )
        END
    END

    IF srcreg THEN
        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

        lirinst^.Source1 = srcreg
    END

    XrFillForStackAccess (
        NULLPTR, // tmp
        NULLPTR, // beforeinst
        NULLPTR, // afterinst
        lirinst, // lirinst
        off, // off
        FALSE, // insert
    )

    LirInsertInstructionTail ( lirinst )
END

FN XrGenerateLoadFromStack (
    IN defreg : ^LirRegister,
    IN off : ULONG,
)

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_LOAD, // machtype
    )

    XrFillForStackAccess (
        NULLPTR, // tmp
        NULLPTR, // beforeinst
        NULLPTR, // afterinst
        lirinst, // lirinst
        off, // off
        FALSE, // insert
    )

    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
    lirinst^.Defines = defreg

    LirInsertInstructionTail ( lirinst )
END

FN (LirSelectF) XrSelectCall (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // We generate the call instruction and all of its arguments.

    callinst := XrCreateInstruction (
        LIR_CALL, // type
        XR_INST_NULL, // machtype
    )

    defreg : ^LirRegister = NULLPTR

    IF inst^.Defines THEN
        defreg = LirGetRegister ( inst^.Defines )

        // Hint the return value to machine reg a3 since that is what it is
        // passed back in.

        defreg^.Hint = XR_A3
    END

    // Now fill the call.

    IF inst^.Source1^.DefinedBy AND
        inst^.Source1^.DefinedBy^.Type == IR_ADDR THEN

        callinst^.MachineInstruction = XR_JAL

        callinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_IMM_NAME

        callinst^.Body.Machine.Xr.Op1.Constant =
            CAST inst^.Source1^.DefinedBy^.Body.Addr.Symbol TO UWORD

    ELSE
        callinst^.MachineInstruction = XR_JALR

        callinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
        callinst^.Source1 = &XrLr

        callinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER
        callinst^.Source2 = LirSelectOrGetRegister ( inst^.Source1 )

        callinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
        callinst^.Body.Machine.Xr.Op3.Constant = 0
    END

    // First generate all of the arguments.

    arglisttail : ^LirArgument = NULLPTR
    callinst^.TypeBody.Call.ArgListHead = NULLPTR

    arg := inst^.Body.Call.ArgListHead
    count := 0
    stackoff := 0

    WHILE arg DO
        lirarg : ^LirArgument

        status := TlBumpAlloc (
            SIZEOF LirArgument, // bytes
            OUT lirarg, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate LIR argument", 0, 0, 0 )
        END

        IF count < 4 THEN
            lirarg^.Register = LirSelectOrGetRegister ( arg^.Variable )

        ELSE
            XrGenerateStoreToStack (
                NULLPTR, // srcreg
                arg^.Variable, // srcvar
                stackoff, // off
            )

            stackoff += 4
        END

        lirarg^.Next = NULLPTR

        IF arglisttail THEN
            arglisttail^.Next = lirarg

        ELSE
            callinst^.TypeBody.Call.ArgListHead = lirarg
        END

        arglisttail = lirarg

        count += 1

        arg = arg^.Next
    END

    // Finally, generate MOVs to A0-A3.

    lirarg := callinst^.TypeBody.Call.ArgListHead
    count = 0

    WHILE lirarg DO
        IF count >= 4 THEN
            BREAK
        END

        XrGeneratePreallocatedMov (
            lirarg^.Register, // reg
            &XrArg[count], // machreg
            FALSE, // from
        )

        count += 1
        lirarg = lirarg^.Next
    END

    // Now insert the CALL instruction.

    LirInsertInstructionTail ( callinst )

    // Now generate a mov from A3 to the destination.

    IF defreg THEN
        XrGeneratePreallocatedMov (
            defreg, // reg
            &XrArg[XR_A3 - XR_A0], // machreg
            TRUE, // from
        )
    END

    outlisttail : ^LirArgument = NULLPTR
    callinst^.TypeBody.Call.OutListHead = NULLPTR

    arg = inst^.Body.Call.OutListHead
    count = 0

    stackoff = 0

    WHILE arg DO
        status := TlBumpAlloc (
            SIZEOF LirArgument, // bytes
            OUT lirarg, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate LIR argument", 0, 0, 0 )
        END

        IF arg^.Variable^.Opt.Dve.References != 0 THEN
            lirarg^.Register = LirGetRegister ( arg^.Variable )

            IF count < 3 THEN
                // First three OUT values are hinted to a0-a2 since they're
                // passed to the caller in those registers. a3 is the primary
                // return value. We allocate them "backwards" in the hope that
                // leaving the lower ones free will help keep the IN arguments
                // in the other regs.

                XrGeneratePreallocatedMov (
                    lirarg^.Register, // reg
                    &XrArg[2 - count], // machreg
                    TRUE, // from
                )
            
            ELSE
                XrGenerateLoadFromStack (
                    lirarg^.Register, // defreg
                    stackoff, // off
                )
            END
        END

        IF count >= 3 THEN
            stackoff += 4
        END

        lirarg^.Next = NULLPTR

        IF outlisttail THEN
            outlisttail^.Next = lirarg

        ELSE
            callinst^.TypeBody.Call.OutListHead = lirarg
        END

        outlisttail = lirarg

        count += 1

        arg = arg^.Next
    END

    RETURN defreg
END

XrLirInfo : LirTargetInfoRecord = {
    [SelectionTable] = {
        [IR_LOAD] = &XrSelectLoad,
        [IR_ADDR] = &XrSelectAddr,
        [IR_STRING_ADDR] = &XrSelectAddr,
        [IR_CONSTANT] = &XrSelectAddr,
        [IR_STACK_ADDR] = &XrSelectStackAddr,

        [IR_MOVE] = &XrSelectMove,

        [IR_RETURN] = &XrSelectReturn,

        [IR_BRANCH_NONZERO] = &XrSelectZeroBranch,
        [IR_BRANCH_ZERO] = &XrSelectZeroBranch,

        [IR_BIT_AND] = &XrSelectArithmetic,
        [IR_BIT_OR] = &XrSelectArithmetic,
        [IR_ADD] = &XrSelectArithmetic,
        [IR_SUBTRACT] = &XrSelectArithmetic,
        [IR_DIVIDE] = &XrSelectArithmetic,
        [IR_DIVIDE_SIGNED] = &XrSelectArithmetic,
        [IR_MODULO] = &XrSelectArithmetic,
        [IR_BIT_XOR] = &XrSelectArithmetic,
        [IR_LEFT_SHIFT] = &XrSelectArithmetic,
        [IR_RIGHT_SHIFT] = &XrSelectArithmetic,
        [IR_RIGHT_SHIFT_SIGNED] = &XrSelectArithmetic,
        [IR_ROTATE_RIGHT] = &XrSelectArithmetic,
        [IR_MULTIPLY] = &XrSelectArithmetic,

        [IR_NOT] = &XrSelectNot,
        [IR_BIT_NOT] = &XrSelectBitNot,

        [IR_BRANCH_EQUALS] = &XrSelectBranch,
        [IR_BRANCH_NOT_EQUALS] = &XrSelectBranch,
        [IR_BRANCH_LESS_THAN] = &XrSelectBranch,
        [IR_BRANCH_GREATER_THAN] = &XrSelectBranch,
        [IR_BRANCH_LTEQ] = &XrSelectBranch,
        [IR_BRANCH_GTEQ] = &XrSelectBranch,
        [IR_BRANCH_LESS_THAN_SIGNED] = &XrSelectBranch,
        [IR_BRANCH_GREATER_THAN_SIGNED] = &XrSelectBranch,
        [IR_BRANCH_LTEQ_SIGNED] = &XrSelectBranch,
        [IR_BRANCH_GTEQ_SIGNED] = &XrSelectBranch,

        [IR_JUMP] = &XrSelectJump,

        [IR_CALL] = &XrSelectCall,

        [IR_STORE] = &XrSelectStore,

        [IR_COMPARE_EQUALS] = &XrSelectCompare,
        [IR_COMPARE_NOT_EQUALS] = &XrSelectCompare,
        [IR_COMPARE_LESS_THAN] = &XrSelectCompare,
        [IR_COMPARE_GREATER_THAN] = &XrSelectCompare,
        [IR_COMPARE_LTEQ] = &XrSelectCompare,
        [IR_COMPARE_GTEQ] = &XrSelectCompare,
        [IR_COMPARE_LESS_THAN_SIGNED] = &XrSelectCompare,
        [IR_COMPARE_GREATER_THAN_SIGNED] = &XrSelectCompare,
        [IR_COMPARE_LTEQ_SIGNED] = &XrSelectCompare,
        [IR_COMPARE_GTEQ_SIGNED] = &XrSelectCompare,
    },
    [RegisterAbiUsage] = {
        [XR_T0] = LIR_REG_CALLER_SAVED,
        [XR_T1] = LIR_REG_CALLER_SAVED,
        [XR_T2] = LIR_REG_CALLER_SAVED,
        [XR_T3] = LIR_REG_CALLER_SAVED,
        [XR_A0] = LIR_REG_CALLER_SAVED,
        [XR_A1] = LIR_REG_CALLER_SAVED,
        [XR_A2] = LIR_REG_CALLER_SAVED,
        [XR_A3] = LIR_REG_CALLER_SAVED,
        [XR_S0] = LIR_REG_CALLEE_SAVED,
        [XR_S1] = LIR_REG_CALLEE_SAVED,
        [XR_S2] = LIR_REG_CALLEE_SAVED,
        [XR_S3] = LIR_REG_CALLEE_SAVED,
        [XR_S4] = LIR_REG_CALLEE_SAVED,
        [XR_S5] = LIR_REG_CALLEE_SAVED,
        [XR_S6] = LIR_REG_CALLEE_SAVED,
        [XR_S7] = LIR_REG_CALLEE_SAVED,
        [XR_S8] = LIR_REG_CALLEE_SAVED,
        [XR_S9] = LIR_REG_CALLEE_SAVED,
        [XR_S10] = LIR_REG_CALLEE_SAVED,
        [XR_S11] = LIR_REG_CALLEE_SAVED,
        [XR_S12] = LIR_REG_CALLEE_SAVED,
        [XR_S13] = LIR_REG_CALLEE_SAVED,
        [XR_S14] = LIR_REG_CALLEE_SAVED,
        [XR_S15] = LIR_REG_CALLEE_SAVED,
        [XR_S16] = LIR_REG_CALLEE_SAVED,
        [XR_S17] = LIR_REG_CALLEE_SAVED,
    },
    [MaximumRegister] = XR_REG_MAX,
}

FN XrHintFunction (
    IN funcsym : ^LexSymbol,
    IN irfunc : ^IrFunction,
)

    // Hint the first four arguments to a0-a3.

    head := irfunc^.LirHead

    functype := funcsym^.SemanticType

    arg := functype^.Body.Function.ArgListHead

    incount := 0
    outcount := 0

    WHILE arg DO
        symbol := arg^.Symbol

        irvar := CAST symbol^.IrContext TO ^IrVariable

        IF irvar THEN
            irreg := LirGetRegister ( irvar )

            IF arg^.InOut == ARG_IN AND incount < 4 THEN
                irreg^.Hint = XR_A0 + incount

                // Create a junk node that defines this at the start of the
                // function, for regalloc purposes.

                junkinst := XrCreateInstruction (
                    LIR_JUNK, // type
                    0, // machtype
                )

                junkinst^.Defines = irreg

                junkinst^.Source1 = &XrArg[incount]

                LirInsertInstructionBefore (
                    head, // beforeinst
                    junkinst, // inst
                )

            ELSEIF arg^.InOut == ARG_OUT AND outcount < 3 THEN
                irreg^.Hint = XR_A2 - outcount

                // Create a junk node that defines this at the end of the
                // function, for regalloc purposes.

                junkinst := XrCreateInstruction (
                    LIR_JUNK, // type
                    0, // machtype
                )

                junkinst^.Defines = &XrArg[2 - outcount]

                junkinst^.Source1 = irreg

                LirInsertInstructionAfter (
                    irfunc^.LirTail, // afterinst
                    junkinst, // inst
                )
            END
        END

        IF arg^.InOut == ARG_IN THEN
            incount += 1

        ELSE
            outcount += 1
        END

        arg = arg^.Next
    END

    IF functype^.Body.Function.IsVarArg THEN
        // Hint the vartable and argcount symbols.

        i := 0

        WHILE incount < 4 AND i < 2 DO
            symbol : ^LexSymbol

            IF NOT i THEN
                symbol = functype^.Body.Function.VarArgTable

            ELSE
                symbol = functype^.Body.Function.VarArgCount
            END

            irvar := CAST symbol^.IrContext TO ^IrVariable

            IF irvar THEN
                irreg := LirGetRegister ( irvar )

                irreg^.Hint = XR_A0 + incount

                junkinst := XrCreateInstruction (
                    LIR_JUNK, // type
                    0, // machtype
                )

                junkinst^.Defines = irreg

                junkinst^.Source1 = &XrArg[incount]

                LirInsertInstructionBefore (
                    head, // beforeinst
                    junkinst, // inst
                )
            END

            incount += 1
            i += 1
        END
    END
END

XrTmpsContain : ^LirRegister[3]
XrTmpsModified : UBYTE[3]
XrTmpsRef : UBYTE[3]
XrTmpReplacementIndex := 0
XrTmpsModifiedCount := 0

FN XrLoadIntoTmp (
    IN tmp : ^LirRegister,
    IN spilledreg : ^LirRegister,
    IN beforeinst : ^LirInstruction,
)

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_LOAD, // machtype
    )

    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    lirinst^.Defines = tmp

    spilloff := LirGetSpillOffset (
        beforeinst^.Block, // irfunc
        spilledreg, // spilledreg
    )

    XrFillForStackAccess (
        tmp, // tmp
        beforeinst, // beforeinst
        NULLPTR, // afterinst
        lirinst, // lirinst
        spilloff, // off
        FALSE, // insert
    )

    LirInsertInstructionBefore (
        beforeinst, // beforeinst
        lirinst, // inst
    )
END

FN XrFlushTmp (
    IN beforeinst : ^LirInstruction,
    IN tmp : ^LirRegister,
    IN tmptmp : ^LirRegister,
    IN spilledreg : ^LirRegister,
)

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_STORE, // machtype
    )

    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    lirinst^.Source1 = tmp

    spilloff := LirGetSpillOffset (
        beforeinst^.Block, // irfunc
        spilledreg, // spilledreg
    )

    XrFillForStackAccess (
        tmptmp, // tmp
        beforeinst, // beforeinst
        NULLPTR, // afterinst
        lirinst, // lirinst
        spilloff, // off
        FALSE, // insert
    )

    LirInsertInstructionBefore (
        beforeinst, // beforeinst
        lirinst, // inst
    )
END

FN XrGetTmp (
    IN spilledreg : ^LirRegister,
    IN beforeinst : ^LirInstruction,
    IN load : UBYTE,
) : UBYTE

    i := 0

    WHILE i < 3 DO
        IF XrTmpsContain[i] == spilledreg THEN
            IF load THEN
                XrTmpsRef[i] = 1
            END

            RETURN i
        END

        i += 1
    END

    i = 0

    WHILE i < 3 DO
        IF NOT XrTmpsContain[i] THEN
            XrTmpsContain[i] = spilledreg

            IF load THEN
                XrLoadIntoTmp (
                    &XrTmps[i], // tmp
                    spilledreg, // spilledreg
                    beforeinst, // beforeinst
                )

                XrTmpsRef[i] = 1
            END

            RETURN i
        END

        i += 1
    END

    // "Randomly" replace a tmp, potentially causing a writeback.
    // There must be at least one free tmp since we free them all at instruction
    // boundaries and only two can currently be used if we're allocating
    // another.

    replace := XrTmpReplacementIndex

    IF replace == 2 THEN
        XrTmpReplacementIndex = 0

    ELSE
        XrTmpReplacementIndex += 1
    END

    WHILE TRUE DO
        IF replace == 3 THEN
            replace = 0
        END

        IF NOT XrTmpsRef[replace] THEN
            BREAK
        END

        replace += 1
    END

    IF XrTmpsModified[replace] THEN
        tmptmp := replace + 1

        WHILE TRUE DO
            // Find a temp to serve as the temp for this guy, in case he needs
            // to use one to calculate the stack address. We're guaranteed to
            // have at least one unmodified temp at all times for this purpose.

            IF tmptmp == 3 THEN
                tmptmp = 0
            END

            IF NOT XrTmpsModified[tmptmp] AND NOT XrTmpsRef[tmptmp] THEN
                XrTmpsContain[tmptmp] = NULLPTR

                BREAK
            END

            tmptmp += 1
        END

        XrFlushTmp (
            beforeinst, // beforeinst
            &XrTmps[replace], // tmp
            &XrTmps[tmptmp], // tmptmp
            XrTmpsContain[replace], // tmp
        )

        XrTmpsModified[replace] = FALSE
        XrTmpsModifiedCount = 0
    END

    IF load THEN
        XrLoadIntoTmp (
            &XrTmps[replace], // tmp
            spilledreg, // spilledreg
            beforeinst, // beforeinst
        )

        XrTmpsRef[replace] = 1
    END

    XrTmpsContain[replace] = spilledreg

    RETURN replace
END

FN XrModifyTmp (
    IN beforeinst : ^LirInstruction,
    IN tmp : UBYTE,
)

    IF XrTmpsModified[tmp] THEN
        LEAVE
    END

    IF XrTmpsModifiedCount == 1 THEN
        // Flush the other, using myself as the tmptmp.

        i := 0

        WHILE i < 3 DO
            IF XrTmpsModified[i] THEN
                XrFlushTmp (
                    beforeinst, // beforeinst
                    &XrTmps[i], // tmp
                    &XrTmps[tmp], // tmptmp
                    XrTmpsContain[i], // spilledreg
                )

                XrTmpsModified[i] = FALSE

                BREAK
            END

            i += 1
        END
    END

    XrTmpsModified[tmp] = TRUE
    XrTmpsModifiedCount = 1
END

FN XrGenerateSpills (
    IN irfunc : ^IrFunction,
)

    // Generate spill code using the two temporaries that were permanently
    // reserved, T4 and T5.
    //
    // The spill cases are as follows, excluding cases where the SP offset is
    // out of range:
    //
    //  A, B, SPILLED                ->  MOV T5, LONG [SP + OFF]
    //                                   A, B, T5
    //
    //  A, SPILLED, C                ->  MOV T4, LONG [SP + OFF]
    //                                   A, T4, C
    //
    //  SPILLED, A, B                 -> T4, A, B
    //                                   MOV LONG [SP + OFF], T4

    inst := irfunc^.LirHead

    i := 0

    WHILE i < 3 DO
        XrTmpsContain[i] = NULLPTR
        XrTmpsRef[i] = 0
        XrTmpsModified[i] = FALSE

        i += 1
    END

    XrTmpsModifiedCount = 0

    WHILE inst DO
        def := inst^.Defines
        src1 := inst^.Source1
        src2 := inst^.Source2
        src3 := inst^.Source3

        type := inst^.Type
        machinst := inst^.MachineInstruction
        access1 := inst^.Body.Machine.Xr.Op1.AccessType
        access2 := inst^.Body.Machine.Xr.Op2.AccessType
        access3 := inst^.Body.Machine.Xr.Op3.AccessType

        IF type == LIR_JUNK THEN
            LirRemoveInstruction ( inst )

            inst = inst^.Next

            CONTINUE
        END

        IF type == LIR_LABEL AND
            inst^.Body.Label.References == 0 THEN

            LirRemoveInstruction ( inst )

            inst = inst^.Next

            CONTINUE
        END

        // First check if this is a useless move. Despite the massive bundle of
        // conditions below, this is a pretty common occurrence after regalloc,
        // since we didn't know if register hinting would be successful until
        // after we generated lots of MOVs into function argument registers and
        // so on.

        IF type == LIR_MACH_INST AND machinst == XR_MOV_REG THEN
            IF def == src2 OR
                (def^.Type == LIR_PREALLOCATED_REG OR
                def^.Type == LIR_MACHINE_REG) AND
                (src2^.Type == LIR_PREALLOCATED_REG OR
                src2^.Type == LIR_MACHINE_REG) AND
                (def^.MachineRegister == src2^.MachineRegister) THEN

                // Elide this useless move.

                LirRemoveInstruction ( inst )

                inst = inst^.Next

                CONTINUE
            END
        END

        src1tmp := -1
        src2tmp := -1

        IF NOT def AND src1 AND src1^.Type == LIR_SPILLED_REG THEN
            src1tmp = XrGetTmp (
                src1, // spilledreg
                inst, // beforeinst
                TRUE, // load
            )

            inst^.Source1 = &XrTmps[src1tmp]
        END

        IF src2 AND src2^.Type == LIR_SPILLED_REG THEN
            src2tmp = XrGetTmp (
                src2, // spilledreg
                inst, // beforeinst
                TRUE, // load
            )

            inst^.Source2 = &XrTmps[src2tmp]
        END

        IF src3 AND src3^.Type == LIR_SPILLED_REG THEN
            tmp := XrGetTmp (
                src3, // spilledreg
                inst, // beforeinst
                TRUE, // load
            )

            inst^.Source3 = &XrTmps[tmp]

            XrTmpsRef[tmp] = 0
        END

        IF src1tmp != -1 THEN
            XrTmpsRef[src1tmp] = 0
        END

        IF src2tmp != -1 THEN
            XrTmpsRef[src2tmp] = 0
        END

        IF def AND def^.Type == LIR_SPILLED_REG THEN
            tmp := XrGetTmp (
                def, // spilledreg
                inst, // beforeinst
                FALSE, // load
            )

            inst^.Defines = &XrTmps[tmp]

            XrModifyTmp (
                inst, // beforeinst
                tmp, // tmp
            )
        END

        IF type == LIR_BRANCH OR
            type == LIR_CALL OR
            type == LIR_LABEL THEN

            i = 0

            WHILE i < 3 DO
                IF XrTmpsModified[i] THEN
                    XrFlushTmp (
                        inst, // beforeinst
                        &XrTmps[i], // tmp
                        &XrTmps[(i + 1) % 3], // tmptmp
                        XrTmpsContain[i], // spilledreg
                    )

                    XrTmpsModified[i] = FALSE
                END

                XrTmpsContain[i] = NULLPTR

                i += 1
            END

            XrTmpsModifiedCount = 0
        END

        inst = inst^.Next
    END
END

FN XrGenerateAbiStuff (
    IN funcsym : ^LexSymbol,
    IN irfunc : ^IrFunction,
)

    // Generate a prologue and epilogue for the function.

    functype := funcsym^.SemanticType

    // Remember not to generate MOVs from a register to itself, we already
    // generated the spill code so there's no pass after this to get rid of
    // redundant MOVs again.

    // First generate the prologue. The prologue is:
    //
    //  SUBI SP, SP, { frame size }
    //  MOV [SP + OFF], { all allocated callee saved regs }
    //  MOV [SP + OFF], lr
    //  MOV { all arguments }, { their input reg or stack location }

    head := irfunc^.LirHead
    regmap := &irfunc^.RegisterAllocationStatus[0]

    i := XR_S0
    saveds := 0

    WHILE i <= XR_S17 DO
        IF regmap[i] THEN
            saveds += 1
        END

        i += 1
    END

    IF irfunc^.CallCount THEN
        // We have to save LR, so account for that.

        saveds += 1
    END

    savearea := irfunc^.StackFrameSize + irfunc^.ScratchAreaSize

    framesize := savearea + saveds * 4

    //  SUBI SP, SP, { frame size }

    IF framesize THEN
        inst := XrCreateInstruction (
            LIR_MACH_INST, // type
            XR_INST_NULL, // machtype
        )

        inst^.Defines = &XrSp
        inst^.Source2 = &XrSp
        
        inst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
        inst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

        IF framesize < 65536 THEN
            inst^.MachineInstruction = XR_SUBI

            inst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
            inst^.Body.Machine.Xr.Op3.Constant = framesize

        ELSE
            inst^.MachineInstruction = XR_SUB

            XrGenerateConstant (
                &XrTmps[0], // tmp
                framesize, // const
                NULLPTR, // afterinst
                head, // beforeinst
            )

            inst^.Source3 = &XrTmps[0]

            inst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER
        END

        LirInsertInstructionBefore (
            head, // beforeinst
            inst, // inst
        )
    END

    //  MOV [SP + OFF], { all allocated callee saved regs }

    offset := savearea
    i = XR_S0

    WHILE i <= XR_S17 DO
        IF regmap[i] THEN
            lirinst := XrCreateInstruction (
                LIR_MACH_INST, // type
                XR_MOV_STORE, // machtype
            )

            lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

            lirinst^.Source1 = &XrCalleeSaved[i - XR_S0]

            XrFillForStackAccess (
                &XrTmps[0], // tmp
                head, // beforeinst
                NULLPTR, // afterinst
                lirinst, // lirinst
                offset, // off
                FALSE, // insert
            )

            LirInsertInstructionBefore (
                head, // beforeinst
                lirinst, // inst
            )

            offset += 4
        END

        i += 1
    END

    //  MOV [SP + OFF], lr

    // NOTE: lr MUST be saved last so that it is predictably at the top of the
    //       stack frame for stack traces.

    IF irfunc^.CallCount THEN
        lirinst := XrCreateInstruction (
            LIR_MACH_INST, // type
            XR_MOV_STORE, // machtype
        )

        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

        lirinst^.Source1 = &XrLr

        XrFillForStackAccess (
            &XrTmps[0], // tmp
            head, // beforeinst
            NULLPTR, // afterinst
            lirinst, // lirinst
            offset, // off
            FALSE, // insert
        )

        LirInsertInstructionBefore (
            head, // beforeinst
            lirinst, // inst
        )

        offset += 4
    END

    //  MOV { all arguments }, { their input reg or stack location }

    arg := functype^.Body.Function.ArgListHead
    count := 0

    scratchoff := offset
    varargextras := 0

    IF functype^.Body.Function.IsVarArg THEN
        varargextras = 2
    END

    WHILE TRUE DO
        symbol : ^LexSymbol

        IF arg THEN
            IF arg^.InOut != ARG_IN THEN
                arg = arg^.Next

                CONTINUE
            END

            symbol = arg^.Symbol

        ELSEIF NOT varargextras THEN
            BREAK

        ELSE
            IF varargextras == 2 THEN
                symbol = functype^.Body.Function.VarArgTable

            ELSE
                symbol = functype^.Body.Function.VarArgCount
            END

            varargextras -= 1
        END

        irvar := CAST symbol^.IrContext TO ^IrVariable

        IF irvar AND irvar^.Opt.Dve.References THEN
            irreg := LirGetRegister ( irvar )

            // Move it from the right place.

            IF irreg^.Type == LIR_MACHINE_REG AND
                count < 4 AND
                irreg^.MachineRegister == XR_A0 + count THEN

                // Oh it's already there, nvm.
            
            ELSE
                srcreg : ^LirRegister = NULLPTR

                IF count < 4 THEN
                    srcreg = &XrArg[count]
                
                ELSE
                    // Have to generate a stack load.

                    lirinst := XrCreateInstruction (
                        LIR_MACH_INST, // type
                        XR_MOV_LOAD, // machtype
                    )

                    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

                    IF irreg^.Type == LIR_SPILLED_REG THEN
                        srcreg = &XrTmps[0]
                        lirinst^.Defines = &XrTmps[0]

                    ELSE
                        lirinst^.Defines = irreg
                    END

                    XrFillForStackAccess (
                        &XrTmps[1], // tmp
                        head, // beforeinst
                        NULLPTR, // afterinst
                        lirinst, // lirinst
                        scratchoff, // off
                        FALSE, // insert
                    )

                    LirInsertInstructionBefore (
                        head, // beforeinst
                        lirinst, // inst
                    )
                END

                IF irreg^.Type == LIR_SPILLED_REG THEN
                    // Need to generate a stack store.

                    lirinst := XrCreateInstruction (
                        LIR_MACH_INST, // type
                        XR_MOV_STORE, // machtype
                    )

                    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
                    lirinst^.Source1 = srcreg

                    XrFillForStackAccess (
                        &XrTmps[1], // tmp
                        head, // beforeinst
                        NULLPTR, // afterinst
                        lirinst, // lirinst
                        LirGetSpillOffset ( irfunc, irreg ), // off
                        FALSE, // insert
                    )

                    LirInsertInstructionBefore (
                        head, // beforeinst
                        lirinst, // inst
                    )

                ELSEIF srcreg THEN
                    lirinst := XrCreateInstruction (
                        LIR_MACH_INST, // type
                        XR_MOV_REG, // machtype
                    )

                    lirinst^.Defines = irreg
                    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

                    lirinst^.Source2 = srcreg
                    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

                    LirInsertInstructionBefore (
                        head, // beforeinst
                        lirinst, // inst
                    )
                END
            END
        END

        IF count >= 4 THEN
            scratchoff += 4
        END

        count += 1

        IF arg THEN
            arg = arg^.Next
        END
    END

    // Now generate the epilogue. The epilogue is:
    //
    //  MOV { their output reg or stack location }, { all OUT parameters }
    //  MOV lr, [SP + OFF]
    //  MOV { all allocated callee saved regs }, [SP + OFF]
    //  ADDI SP, SP, { frame size }
    //  RET

    //  MOV { their output reg or stack location }, { all OUT parameters }

    arg = functype^.Body.Function.ArgListHead

    count = 0
    scratchoff = offset

    WHILE arg DO
        IF arg^.InOut != ARG_OUT THEN
            arg = arg^.Next

            CONTINUE
        END

        symbol := arg^.Symbol

        irvar := CAST symbol^.IrContext TO ^IrVariable

        // If the refcount for this OUT parameter is only 1, then it was never
        // referenced in the function body. Don't try to output it or we will
        // choke since the regalloc didn't give it a machine register.

        irreg := LirGetRegister ( irvar )

        IF irreg^.Type != LIR_VIRTUAL_REG THEN
            IF irreg^.Type == LIR_MACHINE_REG AND
                count < 3 AND
                irreg^.MachineRegister == XR_A2 - count THEN

                // Oh it's already there, nvm.
            
            ELSE
                srcreg : ^LirRegister = NULLPTR

                IF irreg^.Type == LIR_SPILLED_REG THEN
                    // Have to generate a stack load.

                    lirinst := XrCreateInstruction (
                        LIR_MACH_INST, // type
                        XR_MOV_LOAD, // machtype
                    )

                    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

                    IF count < 3 THEN
                        lirinst^.Defines = &XrArg[2 - count]

                    ELSE
                        srcreg = &XrTmps[0]
                        lirinst^.Defines = srcreg
                    END

                    XrFillForStackAccess (
                        &XrTmps[1], // tmp
                        NULLPTR, // beforeinst
                        irfunc^.LirTail, // afterinst
                        lirinst, // lirinst
                        LirGetSpillOffset ( irfunc, irreg ), // off
                        FALSE, // insert
                    )

                    LirInsertInstructionAfter (
                        irfunc^.LirTail, // afterinst
                        lirinst, // inst
                    )

                ELSE
                    srcreg = irreg
                END

                IF count < 3 THEN
                    IF srcreg THEN
                        lirinst := XrCreateInstruction (
                            LIR_MACH_INST, // type
                            XR_MOV_REG, // machtype
                        )

                        lirinst^.Defines = &XrArg[2 - count]

                        lirinst^.Body.Machine.Xr.Op1.AccessType =
                            XR_ACCESS_REGISTER

                        lirinst^.Source2 = srcreg

                        lirinst^.Body.Machine.Xr.Op2.AccessType =
                            XR_ACCESS_REGISTER

                        LirInsertInstructionAfter (
                            irfunc^.LirTail, // afterinst
                            lirinst, // inst
                        )
                    END

                ELSE
                    // Have to generate a stack store.

                    lirinst := XrCreateInstruction (
                        LIR_MACH_INST, // type
                        XR_MOV_STORE, // machtype
                    )

                    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
                    lirinst^.Source1 = srcreg

                    XrFillForStackAccess (
                        &XrTmps[1], // tmp
                        NULLPTR, // beforeinst
                        irfunc^.LirTail, // afterinst
                        lirinst, // lirinst
                        scratchoff, // off
                        FALSE, // insert
                    )

                    LirInsertInstructionAfter (
                        irfunc^.LirTail, // afterinst
                        lirinst, // inst
                    )
                END
            END
        END

        IF count >= 3 THEN
            scratchoff += 4
        END

        count += 1

        arg = arg^.Next
    END

    //  MOV lr, [SP + OFF]

    IF irfunc^.CallCount THEN
        offset -= 4

        lirinst := XrCreateInstruction (
            LIR_MACH_INST, // type
            XR_MOV_LOAD, // machtype
        )

        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

        lirinst^.Defines = &XrLr

        XrFillForStackAccess (
            &XrTmps[0], // tmp
            NULLPTR, // beforeinst
            irfunc^.LirTail, // afterinst
            lirinst, // lirinst
            offset, // off
            FALSE, // insert
        )

        LirInsertInstructionAfter (
            irfunc^.LirTail, // afterinst
            lirinst, // inst
        )
    END

    //  MOV { all allocated callee saved regs }, [SP + OFF]

    WHILE i > XR_S0 DO
        i -= 1

        IF regmap[i] THEN
            offset -= 4

            lirinst := XrCreateInstruction (
                LIR_MACH_INST, // type
                XR_MOV_LOAD, // machtype
            )

            lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

            lirinst^.Defines = &XrCalleeSaved[i - XR_S0]

            XrFillForStackAccess (
                &XrTmps[0], // tmp
                NULLPTR, // beforeinst
                irfunc^.LirTail, // afterinst
                lirinst, // lirinst
                offset, // off
                FALSE, // insert
            )

            LirInsertInstructionAfter (
                irfunc^.LirTail, // afterinst
                lirinst, // inst
            )
        END
    END

    //  ADDI SP, SP, { frame size }

    IF framesize THEN
        inst := XrCreateInstruction (
            LIR_MACH_INST, // type
            XR_INST_NULL, // machtype
        )

        inst^.Defines = &XrSp
        inst^.Source2 = &XrSp
        
        inst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
        inst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

        IF framesize < 65536 THEN
            inst^.MachineInstruction = XR_ADDI

            inst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
            inst^.Body.Machine.Xr.Op3.Constant = framesize

        ELSE
            inst^.MachineInstruction = XR_ADD

            XrGenerateConstant (
                &XrTmps[0], // tmp
                framesize, // const
                irfunc^.LirTail, // afterinst
                NULLPTR, // beforeinst
            )

            inst^.Source3 = &XrTmps[0]

            inst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER
        END

        LirInsertInstructionAfter (
            irfunc^.LirTail, // afterinst
            inst, // inst
        )
    END

    // RET

    inst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_RET, // machtype
    )

    LirInsertInstructionAfter (
        irfunc^.LirTail, // afterinst
        inst, // inst
    )
END

FN XrEmitRegister (
    IN reg : ^LirRegister,
)

    IF reg^.Type == LIR_SPILLED_REG THEN
        XrAsmInsertString ( "SPILLED" )
        XrAsmInsertNumber ( CAST reg TO UWORD )

    ELSEIF reg^.Type == LIR_VIRTUAL_REG THEN
        XrAsmInsertString ( "VIRTUAL" )
        XrAsmInsertNumber ( CAST reg TO UWORD )

    ELSE
        XrAsmInsertString ( XrRegisterNames[reg^.MachineRegister] )
    END
END

FN XrEmitOperand (
    IN operand : ^LirXrOperand,
    IN reg : ^LirRegister,
)

    IF operand^.AccessType == XR_ACCESS_IMM THEN
        XrAsmInsertNumber ( operand^.Constant )

    ELSEIF operand^.AccessType == XR_ACCESS_REGISTER THEN
        XrEmitRegister ( reg )

    ELSEIF operand^.AccessType == XR_ACCESS_ZERO THEN
        XrAsmInsertString ( "zero" )

    ELSEIF operand^.AccessType == XR_ACCESS_IMM_STRING THEN
        string := CAST operand^.Constant TO ^LexInternedString

        XrAsmEmitString ( string )

    ELSEIF operand^.AccessType == XR_ACCESS_IMM_NAME THEN
        symbol := CAST operand^.Constant TO ^LexSymbol

        XrAsmInsertString ( symbol^.Name )
    END
END

XrNextBranchNumber := 0

FN XrEmitInstruction (
    IN lirinst : ^LirInstruction,
)

    IF lirinst^.Type == LIR_MACH_INST OR
        lirinst^.Type == LIR_CALL OR
        lirinst^.Type == LIR_BRANCH THEN

        XrAsmInsertString ( "    " )

        XrAsmInsertString ( XrInstructionNames[lirinst^.MachineInstruction] )

        XrAsmInsertString ( " " )

        reg1 := lirinst^.Defines

        IF NOT reg1 THEN
            reg1 = lirinst^.Source1
        END

        reg2 := lirinst^.Source2
        reg3 := lirinst^.Source3

        IF lirinst^.Type == LIR_BRANCH THEN
            IF reg1 THEN
                XrEmitRegister ( reg1 )
                XrAsmInsertString ( ", " )
            END

            num := lirinst^.TypeBody.Branch.Label^.Body.Label.Number

            IF num == 0xFFFFFFFF THEN
                num = XrNextBranchNumber
                lirinst^.TypeBody.Branch.Label^.Body.Label.Number = num

                XrNextBranchNumber += 1
            END

            XrAsmInsertString ( ".L" )
            XrAsmInsertNumber ( num )

        ELSEIF lirinst^.MachineInstruction == XR_MOV_LOAD OR
            lirinst^.MachineInstruction == XR_MOV_STORE OR
            lirinst^.MachineInstruction == XR_MOV_LOAD_INLINED OR
            lirinst^.MachineInstruction == XR_MOV_STORE_INLINED THEN

            IF lirinst^.MachineInstruction == XR_MOV_LOAD OR
                lirinst^.MachineInstruction == XR_MOV_LOAD_INLINED THEN

                XrEmitRegister ( reg1 )
                XrAsmInsertString ( ", " )
            END

            XrAsmInsertString ( XrBitsNames[lirinst^.Body.Machine.Xr.BitSize] )

            XrAsmInsertString ( " [" )

            IF lirinst^.MachineInstruction == XR_MOV_LOAD OR
                lirinst^.MachineInstruction == XR_MOV_STORE THEN

                XrEmitRegister ( reg2 )

                IF lirinst^.Body.Machine.Xr.Op3.AccessType == XR_ACCESS_IMM AND
                    lirinst^.Body.Machine.Xr.Op3.Constant THEN

                    XrAsmInsertString ( " + " )
                    XrAsmInsertNumber ( lirinst^.Body.Machine.Xr.Op3.Constant )
                
                ELSEIF lirinst^.Body.Machine.Xr.Op3.AccessType ==
                    XR_ACCESS_REGISTER THEN

                    XrAsmInsertString ( " + " )
                    XrEmitRegister ( reg3 )

                    IF lirinst^.Body.Machine.Xr.ShiftAmount THEN
                        XrAsmInsertString ( " " )

                        XrAsmInsertString (
                        XrShiftTypeNames[lirinst^.Body.Machine.Xr.ShiftType] )

                        XrAsmInsertString ( " " )

                        XrAsmInsertNumber (
                            lirinst^.Body.Machine.Xr.ShiftAmount )
                    END
                END

            ELSE
                symbol :=
                    CAST lirinst^.Body.Machine.Xr.Op2.Constant TO ^LexSymbol

                XrAsmInsertString ( symbol^.Name )
            END

            XrAsmInsertString ( "]" )

            IF lirinst^.MachineInstruction == XR_MOV_STORE OR
                lirinst^.MachineInstruction == XR_MOV_STORE_INLINED THEN

                XrAsmInsertString ( ", " )

                IF lirinst^.Source1 THEN
                    XrEmitRegister ( lirinst^.Source1 )

                ELSE
                    XrAsmInsertNumber ( lirinst^.Body.Machine.Xr.Op1.Constant )
                END

                IF lirinst^.MachineInstruction == XR_MOV_STORE_INLINED THEN
                    XrAsmInsertString ( ", tmp=" )
                    XrEmitRegister ( lirinst^.Source3 )
                END
            END

        ELSE
            commatime := FALSE

            IF lirinst^.Body.Machine.Xr.Op1.AccessType != XR_ACCESS_NONE THEN
                XrEmitOperand (
                    &lirinst^.Body.Machine.Xr.Op1, // operand
                    reg1, // reg
                )

                commatime = TRUE
            END

            IF lirinst^.Body.Machine.Xr.Op2.AccessType != XR_ACCESS_NONE THEN
                IF commatime THEN
                    XrAsmInsertString ( ", " )
                END

                XrEmitOperand (
                    &lirinst^.Body.Machine.Xr.Op2, // operand
                    reg2, // reg
                )

                commatime = TRUE
            END

            IF lirinst^.Body.Machine.Xr.Op3.AccessType != XR_ACCESS_NONE THEN
                IF commatime THEN
                    XrAsmInsertString ( ", " )
                END

                XrEmitOperand (
                    &lirinst^.Body.Machine.Xr.Op3, // operand
                    reg3, // reg
                )

                IF lirinst^.Body.Machine.Xr.ShiftAmount THEN
                    XrAsmInsertString ( " " )

                    XrAsmInsertString (
                    XrShiftTypeNames[lirinst^.Body.Machine.Xr.ShiftType] )

                    XrAsmInsertString ( " " )

                    XrAsmInsertNumber (
                        lirinst^.Body.Machine.Xr.ShiftAmount )
                END
            END
        END

        XrAsmInsertString ( "\n" )

    ELSEIF lirinst^.Type == LIR_LABEL THEN
        num := lirinst^.Body.Label.Number

        IF num == 0xFFFFFFFF THEN
            num = XrNextBranchNumber
            lirinst^.Body.Label.Number = num

            XrNextBranchNumber += 1
        END

        XrAsmInsertString ( ".L" )
        XrAsmInsertNumber ( num )
        XrAsmInsertString ( ":\n" )

    ELSEIF lirinst^.Type == LIR_INSERTASM THEN
        XrAsmInsertString ( "    " )

        XrAsmInsertString (
            lirinst^.Body.InsertAsm.String^.DynamicBuffer.Buffer )
        
        XrAsmInsertString ( "\n" )

    ELSEIF lirinst^.Type == LIR_JUNK THEN
        // Do nothing

    ELSE
        TlInternalError ( "Xr: Weird LIR type", lirinst^.Type, 0, 0 )
    END
END

FN (JklIsUnconditionalF) XrIsUnconditional (
    IN inst : ^LirInstruction,
) : UBYTE

    RETURN inst^.MachineInstruction == XR_B
END

FN XrElideUselessJump (
    IN inst : ^LirInstruction,
) : UWORD

    // Check if this branch instruction is followed by both its true and false
    // label. We walk along each label until we reach the first non-label
    // instruction so that we catch all the cases.

    next := inst^.Next

    WHILE next AND next^.Type == LIR_LABEL DO
        IF inst^.TypeBody.Branch.Label == next THEN
            next^.Body.Label.References -= 1

            RETURN TRUE
        END

        next = next^.Next
    END

    RETURN FALSE
END

FN (AsmEmitF) XrEmitFunction (
    IN funcsym : ^LexSymbol,
)

    // Emit the final assembly language for a function.

    irfunc := CAST funcsym^.InitialValue TO ^IrFunction

    inst := irfunc^.LirHead

    dead := FALSE

    WHILE inst DO
        IF inst^.Type == LIR_LABEL THEN
            IF NOT inst^.Body.Label.References THEN
                inst = inst^.Next

                CONTINUE

            ELSE
                dead = FALSE
            END

        ELSEIF dead THEN
            inst = inst^.Next

            CONTINUE

        ELSEIF inst^.Type == LIR_BRANCH THEN
            IF XrElideUselessJump ( inst ) THEN
                inst = inst^.Next

                CONTINUE
            END

            IF inst^.MachineInstruction == XR_B THEN
                dead = TRUE
            END
        END

        XrEmitInstruction ( inst )

        inst = inst^.Next
    END
END

XrAsmEmitter : AsmEmitterRecord = {
    [EmitFunc] = &XrEmitFunction,
}

FN (JklValueNumberF) XrValueNumber (
    IN constant : UWORD,
) : UBYTE

    // Return whether to value number this constant.
    // Doing this too much could create too many callee-saved registers if the
    // constant is live over a function call. Doing it too little will
    // recompute large constants too much.

    // We rarely have to generate constants on XR/17032, and when we do, we'd
    // better reuse them.

    RETURN constant > 0xFFFF
END

FN (JklTargetF) XrCompile ()
    
    // Compile the program for the XR/17032 architecture.

    XrTmps[0].Type = LIR_PREALLOCATED_REG
    XrTmps[0].MachineRegister = XR_T3

    XrTmps[1].Type = LIR_PREALLOCATED_REG
    XrTmps[1].MachineRegister = XR_T4

    XrTmps[2].Type = LIR_PREALLOCATED_REG
    XrTmps[2].MachineRegister = XR_T5

    XrSp.Type = LIR_PREALLOCATED_REG
    XrSp.MachineRegister = XR_SP

    XrLr.Type = LIR_PREALLOCATED_REG
    XrLr.MachineRegister = XR_LR

    XrZero.Type = LIR_PREALLOCATED_REG
    XrZero.MachineRegister = XR_ZERO

    i := 0

    WHILE i < (XR_S17 - XR_S0 + 1) DO
        XrCalleeSaved[i].Type = LIR_PREALLOCATED_REG
        XrCalleeSaved[i].MachineRegister = XR_S0 + i

        i += 1
    END

    i = 0

    WHILE i < (XR_A3 - XR_A0 + 1) DO
        XrArg[i].Type = LIR_PREALLOCATED_REG
        XrArg[i].MachineRegister = XR_A0 + i

        i += 1
    END

    // Perform instruction selection on each function.

    funcsym := PrsFunctionListHead

    WHILE funcsym DO
        // Calculate the scratch area size.

        irfunc := CAST funcsym^.InitialValue TO ^IrFunction

        inscratch := 0

        IF irfunc^.MaximumInCount > 4 THEN
            inscratch = (irfunc^.MaximumInCount - 4) * 4
        END

        outscratch := 0

        IF irfunc^.MaximumOutCount > 3 THEN
            outscratch = (irfunc^.MaximumOutCount - 3) * 4
        END

        IF inscratch > outscratch THEN
            irfunc^.ScratchAreaSize = inscratch
        
        ELSE
            irfunc^.ScratchAreaSize = outscratch
        END

        LirSelectForFunction ( funcsym )

        funcsym = funcsym^.NextFunction
    END

    // Do regalloc over the low level IR (LIR).

    funcsym = PrsFunctionListHead

    WHILE funcsym DO
        // Apply hints to the formal parameters.

        irfunc := CAST funcsym^.InitialValue TO ^IrFunction

        LirCurrentFunction = irfunc

        XrHintFunction ( funcsym, irfunc )

        // Do regalloc.

        LirAllocateRegistersForFunction ( funcsym )

        // Generate spill code.

        XrGenerateSpills ( irfunc )

        // Generate the prologue and epilogue.

        XrGenerateAbiStuff ( funcsym, irfunc )

        // Perform peephole pass.

        LirPeepholeForFunction ( irfunc )

        funcsym = funcsym^.NextFunction
    END

    // Emit the final assembly language.

    XrAsmEmit (
        &XrAsmEmitter, // emitter
    )
END