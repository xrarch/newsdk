//
// Implements the fox32 code generator.
//

#INCLUDE "<inc>/Target.hjk"
#INCLUDE "<inc>/XrSdkAsm.hjk"

#MACRO FoxSetIfUnknown ( inst ) [
    IF (inst)^.Body.Machine.Fox.BitSize == FOX_BITS_UNKNOWN THEN
        (inst)^.Body.Machine.Fox.BitSize = FOX_BITS_32
    END
]

// FORWARD
EXTERN FN (JklTargetF) FoxCompile ()

// FORWARD
EXTERN FN (JklValueNumberF) FoxValueNumber (
    IN constant : UWORD,
) : UBYTE

// FORWARD
EXTERN FN (JklIsUnconditionalF) FoxIsUnconditional (
    IN inst : ^LirInstruction,
) : UBYTE

// FORWARD
EXTERN FoxLirInfo : LirTargetInfoRecord

PUBLIC FoxTargetInfo : JklTargetInfoRecord = {
    [Name] = "fox32",
    [EntryFunc] = &FoxCompile,
    [ValueNumberConstantFunc] = &FoxValueNumber,
    [IsUnconditionalFunc] = &FoxIsUnconditional,
    [FoldStackAddr] = TRUE,
    [LirInfo] = &FoxLirInfo,
    [ConstantMask] = 0xFFFFFFFF,
    [PointerMask] = 0xFFFFFFFF,
    [StackAlignment] = 4,
    [PointerAlignment] = 4,
    [PointerSize] = 4,
    [CodeAlignment] = 1,
    [LargestPrimitive] = PRIM_TYPE_ULONG,
    [LargestSignedPrimitive] = PRIM_TYPE_LONG,
    [SupportedTypes] = {
        [PRIM_TYPE_VOID] = TRUE,
        [PRIM_TYPE_UBYTE] = TRUE,
        [PRIM_TYPE_UINT] = TRUE,
        [PRIM_TYPE_ULONG] = TRUE,
        [PRIM_TYPE_UQUAD] = FALSE,
        [PRIM_TYPE_BYTE] = TRUE,
        [PRIM_TYPE_INT] = TRUE,
        [PRIM_TYPE_LONG] = TRUE,
        [PRIM_TYPE_QUAD] = FALSE,
    },
    [PrimitiveAlignment] = {
        [PRIM_TYPE_VOID] = 1,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
    [PrimitiveSize] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
}

ENUM FoxInstructionTypes : UBYTE
    FOX_ADD,
    FOX_MUL,
    FOX_AND,
    FOX_SLA,
    FOX_SRA,
    FOX_BSE,
    FOX_CMP,
    FOX_JMP,
    FOX_RJMP,
    FOX_PUSH,
    FOX_INC,
    FOX_OR,
    FOX_IMUL,
    FOX_SRL,
    FOX_BCL,
    FOX_MOV,
    FOX_CALL,
    FOX_RCALL,
    FOX_POP,
    FOX_BRK,
    FOX_SUB,
    FOX_DIV,
    FOX_XOR,
    FOX_ROL,
    FOX_ROR,
    FOX_BTS,
    FOX_MOVZ,
    FOX_RET,
    FOX_DEC,
    FOX_REM,
    FOX_NOT,
    FOX_IDIV,
    FOX_IREM,
    FOX_ICMP,

    FOX_MAX,
END

ENUM FoxConditionTypes : UBYTE
    FOX_COND_ALWAYS,
    FOX_COND_IFZ,
    FOX_COND_IFNZ,
    FOX_COND_IFLT,
    FOX_COND_IFGTEQ,
    FOX_COND_IFGT,
    FOX_COND_IFLTEQ,

    FOX_COND_MAX,
END

ENUM FoxBits : UBYTE
    FOX_BITS_8,
    FOX_BITS_16,
    FOX_BITS_32,

    FOX_BITS_MAX,

    FOX_BITS_UNKNOWN,
END

ENUM FoxAccessType : UBYTE
    FOX_ACCESS_NONE,
    FOX_ACCESS_REGISTER,
    FOX_ACCESS_REG_PTR,
    FOX_ACCESS_IMM,
    FOX_ACCESS_IMM_NAME,
    FOX_ACCESS_IMM_PTR,
    FOX_ACCESS_IMM_PTR_NAME,
    FOX_ACCESS_IMM_STRING,
    FOX_ACCESS_IMM_LABEL,
END

ENUM FoxRegisters : UBYTE
    FOX_NULL,

    FOX_T0,
    FOX_T1,
    FOX_T2,
    FOX_T3,
    FOX_T4,
    FOX_T5,
    FOX_T6,
    FOX_A0,
    FOX_A1,
    FOX_A2,
    FOX_A3,
    FOX_S0,
    FOX_S1,
    FOX_S2,
    FOX_S3,
    FOX_S4,
    FOX_S5,
    FOX_S6,
    FOX_S7,
    FOX_S8,
    FOX_S9,
    FOX_S10,
    FOX_S11,
    FOX_S12,
    FOX_S13,
    FOX_S14,
    FOX_S15,
    FOX_S16,
    FOX_S17,
    FOX_AT,

    FOX_R31,
    FOX_SP,
    FOX_FP,

    FOX_REG_MAX,
END

FoxRegisterNames : ^UBYTE[FOX_REG_MAX] = {
    [FOX_T0] = "t0",
    [FOX_T1] = "t1",
    [FOX_T2] = "t2",
    [FOX_T3] = "t3",
    [FOX_T4] = "t4",
    [FOX_T5] = "t5",
    [FOX_T6] = "t6",
    [FOX_A0] = "a0",
    [FOX_A1] = "a1",
    [FOX_A2] = "a2",
    [FOX_A3] = "a3",
    [FOX_S0] = "s0",
    [FOX_S1] = "s1",
    [FOX_S2] = "s2",
    [FOX_S3] = "s3",
    [FOX_S4] = "s4",
    [FOX_S5] = "s5",
    [FOX_S6] = "s6",
    [FOX_S7] = "s7",
    [FOX_S8] = "s8",
    [FOX_S9] = "s9",
    [FOX_S10] = "s10",
    [FOX_S11] = "s11",
    [FOX_S12] = "s12",
    [FOX_S13] = "s13",
    [FOX_S14] = "s14",
    [FOX_S15] = "s15",
    [FOX_S16] = "s16",
    [FOX_S17] = "s17",
    [FOX_AT] = "at",
    [FOX_R31] = "r31",
    [FOX_SP] = "sp",
    [FOX_FP] = "fp",
}

FoxInstructionNames : ^UBYTE[FOX_MAX] = {
    [FOX_ADD] = "add",
    [FOX_MUL] = "mul",
    [FOX_AND] = "and",
    [FOX_SLA] = "sla",
    [FOX_SRA] = "sra",
    [FOX_BSE] = "bse",
    [FOX_CMP] = "cmp",
    [FOX_RJMP] = "rjmp",
    [FOX_PUSH] = "push",
    [FOX_INC] = "inc",
    [FOX_OR] = "or",
    [FOX_IMUL] = "imul",
    [FOX_SRL] = "srl",
    [FOX_BCL] = "bcl",
    [FOX_MOV] = "mov",
    [FOX_CALL] = "call",
    [FOX_POP] = "pop",
    [FOX_BRK] = "brk",
    [FOX_SUB] = "sub",
    [FOX_DIV] = "div",
    [FOX_XOR] = "xor",
    [FOX_ROL] = "rol",
    [FOX_ROR] = "ror",
    [FOX_BTS] = "bts",
    [FOX_MOVZ] = "movz",
    [FOX_RET] = "ret",
    [FOX_DEC] = "dec",
    [FOX_REM] = "rem",
    [FOX_NOT] = "not",
    [FOX_IDIV] = "idiv",
    [FOX_IREM] = "irem",
    [FOX_ICMP] = "icmp",
}

FoxConditionNames : ^UBYTE[FOX_COND_MAX] = {
    [FOX_COND_ALWAYS] = "",
    [FOX_COND_IFZ] = "ifz ",
    [FOX_COND_IFNZ] = "ifnz ",
    [FOX_COND_IFLT] = "iflt ",
    [FOX_COND_IFGTEQ] = "ifgteq ",
    [FOX_COND_IFGT] = "ifgt ",
    [FOX_COND_IFLTEQ] = "iflteq ",
}

FoxBitsNames : ^UBYTE[FOX_BITS_MAX] = {
    [FOX_BITS_8] = ".8",
    [FOX_BITS_16] = ".16",
    [FOX_BITS_32] = "",
}

FoxPrimTypeToBits : UBYTE[PRIM_TYPE_MAX] = {
    [PRIM_TYPE_BYTE] = FOX_BITS_8,
    [PRIM_TYPE_INT] = FOX_BITS_16,
    [PRIM_TYPE_LONG] = FOX_BITS_32,

    [PRIM_TYPE_UBYTE] = FOX_BITS_8,
    [PRIM_TYPE_UINT] = FOX_BITS_16,
    [PRIM_TYPE_ULONG] = FOX_BITS_32,

    [PRIM_TYPE_POINTER] = FOX_BITS_32,
}

FoxIrInstToCondition : UBYTE[IR_MAX] = {
    [IR_BRANCH_EQUALS] = FOX_COND_IFZ,
    [IR_BRANCH_NOT_EQUALS] = FOX_COND_IFNZ,

    [IR_BRANCH_LESS_THAN] = FOX_COND_IFLT,
    [IR_BRANCH_GREATER_THAN] = FOX_COND_IFGT,
    [IR_BRANCH_LTEQ] = FOX_COND_IFLTEQ,
    [IR_BRANCH_GTEQ] = FOX_COND_IFGTEQ,

    [IR_BRANCH_LESS_THAN_SIGNED] = FOX_COND_IFLT,
    [IR_BRANCH_GREATER_THAN_SIGNED] = FOX_COND_IFGT,
    [IR_BRANCH_LTEQ_SIGNED] = FOX_COND_IFLTEQ,
    [IR_BRANCH_GTEQ_SIGNED] = FOX_COND_IFGTEQ,

    [IR_COMPARE_EQUALS] = FOX_COND_IFZ,
    [IR_COMPARE_NOT_EQUALS] = FOX_COND_IFNZ,

    [IR_COMPARE_LESS_THAN] = FOX_COND_IFLT,
    [IR_COMPARE_GREATER_THAN] = FOX_COND_IFGT,
    [IR_COMPARE_LTEQ] = FOX_COND_IFLTEQ,
    [IR_COMPARE_GTEQ] = FOX_COND_IFGTEQ,

    [IR_COMPARE_LESS_THAN_SIGNED] = FOX_COND_IFLT,
    [IR_COMPARE_GREATER_THAN_SIGNED] = FOX_COND_IFGT,
    [IR_COMPARE_LTEQ_SIGNED] = FOX_COND_IFLTEQ,
    [IR_COMPARE_GTEQ_SIGNED] = FOX_COND_IFGTEQ,
}

FoxIrInstToFoxOp : FoxInstructionTypes[IR_MAX] = {
    [IR_BIT_AND] = FOX_AND,
    [IR_BIT_OR] = FOX_OR,
    [IR_ADD] = FOX_ADD,
    [IR_SUBTRACT] = FOX_SUB,
    [IR_DIVIDE] = FOX_DIV,
    [IR_MULTIPLY] = FOX_MUL,
    [IR_MODULO] = FOX_REM,
    [IR_BIT_XOR] = FOX_XOR,
    [IR_LEFT_SHIFT] = FOX_SLA,
    [IR_RIGHT_SHIFT] = FOX_SRL,
    [IR_RIGHT_SHIFT_SIGNED] = FOX_SRA,
    [IR_DIVIDE_SIGNED] = FOX_IDIV,
}

FoxPrimTypeToSignShift : UBYTE[PRIM_TYPE_MAX] = {
    [PRIM_TYPE_INT] = 16,
    [PRIM_TYPE_BYTE] = 24,
}

FoxTmps : LirRegister[2]
FoxTmpAt : LirRegister
FoxSp : LirRegister
FoxFp : LirRegister
FoxCalleeSaved : LirRegister[FOX_S17 - FOX_S0 + 1]
FoxArg : LirRegister[FOX_A3 - FOX_A0 + 1]

FN FoxFillOperandForAccess (
    IN lirinst : ^LirInstruction,
    IN operand : ^LirFoxOperand,
    IN inst : ^IrInstruction,
    IN load : UBYTE,
) : ^LirRegister

    // Caller should have made sure the instruction is the right width,
    // otherwise an intermediate access is required.

    lirinst^.Body.Machine.Fox.BitSize =
        FoxPrimTypeToBits[inst^.Body.LoadStore.Type]

    src2 := inst^.Source1

    inst2 := src2^.DefinedBy

    IF NOT inst2 THEN
        // Not a temporary, just trust this named local.

        operand^.AccessType = FOX_ACCESS_REG_PTR
        operand^.Constant = 0

        RETURN LirGetRegister ( src2 )
    END

    IF inst2^.Type == IR_STACK_ADDR THEN
        // It's on the stack frame, this is an SP + OFF. 

        symbol := inst2^.Body.Addr.Symbol

        off := inst2^.Body.Addr.Offset + IrGetStackOffset (
            LirCurrentFunction, // func
            symbol, // symbol
        ) + LirCurrentFunction^.ScratchAreaSize

        IF off < 256 THEN
            // Great! We can do this directly.

            operand^.AccessType = FOX_ACCESS_REG_PTR
            operand^.Constant = off

            spreg := &FoxSp

            RETURN spreg
        END

    ELSEIF inst2^.Type == IR_ADDR THEN
        // Gotta be a named imm.

        IF src2^.Opt.Dve.References <= 4 THEN
            operand^.AccessType = FOX_ACCESS_IMM_PTR_NAME
            operand^.Constant = CAST inst2^.Body.Addr.Symbol TO UWORD

            RETURN NULLPTR
        END

    ELSEIF inst2^.Type == IR_CONSTANT THEN
        // Numeric imm.

        operand^.AccessType = FOX_ACCESS_IMM_PTR
        operand^.Constant = inst2^.Body.Constant.Constant

        RETURN NULLPTR

    ELSEIF inst2^.Type == IR_ADD THEN
        // If this is plus a constant less than 256, we can do an
        // offsetted load. We don't have to check for a constant in the
        // left side because the simplification pass moved them all to
        // the right side.

        src3 := inst2^.Source2

        inst3 := src3^.DefinedBy

        IF inst3 AND
            inst3^.Type == IR_CONSTANT AND
            inst3^.Body.Constant.Constant < 256 THEN

            // Neat! Get the register for the left side.

            // Fill in the LIR instruction.

            operand^.AccessType = FOX_ACCESS_REG_PTR
            operand^.Constant = inst3^.Body.Constant.Constant

            RETURN LirSelectOrGetRegister ( inst2^.Source1 )
        END
    END

    // In any load case not covered above, select.

    operand^.AccessType = FOX_ACCESS_REG_PTR
    operand^.Constant = 0

    RETURN LirSelect ( inst2 )
END

FN FoxFillOperand (
    IN lirinst : ^LirInstruction,
    IN operand : ^LirFoxOperand,
    IN var : ^IrVariable,
    IN allowimm : UWORD,
) : ^LirRegister

    // Fill the source fields of the instruction appropriately.
    // Caller should make sure the BitSize field was set on the LIR instruction.

    // Fox32 allows these source modes on all instructions:
    //
    // REG [REG] [REG + OFF] IMM

    inst := var^.DefinedBy

    IF NOT inst THEN
        // It's a named local.

        operand^.AccessType = FOX_ACCESS_REGISTER

        RETURN LirGetRegister ( var )
    END

    bitsize := lirinst^.Body.Machine.Fox.BitSize

    // Var is a temporary. Check for cases.

    IF inst^.Type == IR_LOAD THEN
        // It's one of the load ones.

        // We can only select over this if the load width matches, and if the
        // access is either unsigned or 32 bits.

        IF var^.Opt.Dve.References == 1 THEN
            IF (bitsize == FOX_BITS_UNKNOWN OR
                bitsize == FoxPrimTypeToBits[inst^.Body.LoadStore.Type]) AND
                ((inst^.Body.LoadStore.Type > PRIM_TYPE_UNSIGNED AND
                inst^.Body.LoadStore.Type < PRIM_TYPE_UNSIGNED_MAX) OR
                inst^.Body.LoadStore.Type == PRIM_TYPE_LONG) THEN

                RETURN FoxFillOperandForAccess (
                    lirinst, // lirinst
                    operand, // operand
                    inst, // inst
                    TRUE, // load
                )
            END
        END

    ELSEIF inst^.Type == IR_STRING_ADDR THEN
        // This will get resolved to a label pointing to a string during
        // code emission.

        IF allowimm AND var^.Opt.Dve.References <= 4 THEN
            operand^.AccessType = FOX_ACCESS_IMM_STRING
            operand^.Constant = CAST inst^.Body.String.String TO UWORD

            RETURN NULLPTR
        END

    ELSEIF inst^.Type == IR_ADDR THEN
        // Gotta be a named imm.

        IF allowimm AND var^.Opt.Dve.References <= 4 THEN
            operand^.AccessType = FOX_ACCESS_IMM_NAME
            operand^.Constant = CAST inst^.Body.Addr.Symbol TO UWORD

            RETURN NULLPTR
        END

    ELSEIF inst^.Type == IR_CONSTANT THEN
        // Gotta be a numeric imm.

        IF allowimm THEN
            operand^.AccessType = FOX_ACCESS_IMM
            operand^.Constant = inst^.Body.Constant.Constant

            RETURN NULLPTR
        END
    END

    // If we got here we've decided to use reg.

    operand^.AccessType = FOX_ACCESS_REGISTER

    RETURN LirSelect ( inst )
END

FN (LirSelectF) FoxSelectLoad (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a fox32 mem-to-reg MOVZ instruction.

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOVZ, // machtype
    )

    lirinst^.Defines = defreg

    lirinst^.Source2 = FoxFillOperandForAccess (
        lirinst, // lirinst
        &lirinst^.Body.Machine.Fox.Op2, // operand
        inst, // inst
        TRUE, // load
    )

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS

    LirInsertInstructionTail ( lirinst )

    // If this was a signed type, less than 32 bits, make sure to sign extend.

    IF inst^.Body.LoadStore.Type == PRIM_TYPE_BYTE OR
        inst^.Body.LoadStore.Type == PRIM_TYPE_INT THEN

        // Generate a left shift and then an arithmetic right shift.

        lirinst = LirCreateInstruction (
            LIR_MACH_INST, // type
            FOX_SLA, // machtype
        )

        lirinst^.Defines = defreg
        lirinst^.Source1 = defreg

        lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
        lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS

        lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
        lirinst^.Body.Machine.Fox.Op2.Constant =
            FoxPrimTypeToSignShift[inst^.Body.LoadStore.Type]

        lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

        LirInsertInstructionTail ( lirinst )

        lirinst = LirCreateInstruction (
            LIR_MACH_INST, // type
            FOX_SRA, // machtype
        )

        lirinst^.Defines = defreg
        lirinst^.Source1 = defreg

        lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
        lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS

        lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
        lirinst^.Body.Machine.Fox.Op2.Constant =
            FoxPrimTypeToSignShift[inst^.Body.LoadStore.Type]

        lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

        LirInsertInstructionTail ( lirinst )
    END

    RETURN defreg
END

FN (LirSelectF) FoxSelectAddr (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a fox32 imm-to-reg MOV instruction.

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOVZ, // machtype
    )

    lirinst^.Defines = defreg

    IF inst^.Type == IR_ADDR THEN
        lirinst^.Body.Machine.Fox.Op2.Constant =
            CAST inst^.Body.Addr.Symbol TO UWORD
    
        lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM_NAME

        lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    ELSEIF inst^.Type == IR_STRING_ADDR THEN
        // This will get resolved to a label pointing to a string during
        // code emission.

        lirinst^.Body.Machine.Fox.Op2.Constant =
            CAST inst^.Body.String.String TO UWORD

        lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM_STRING

        lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32
    
    ELSEIF inst^.Type == IR_CONSTANT THEN
        lirinst^.Body.Machine.Fox.Op2.Constant = inst^.Body.Constant.Constant

        lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM

        IF inst^.Body.Constant.Constant < 0x100 THEN
            lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_8

        ELSEIF inst^.Body.Constant.Constant < 0x10000 THEN
            lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_16

        ELSE
            lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32
        END
    END

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) FoxSelectStackAddr (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a MOV instruction from SP to a temporary. Then generate an add
    // instruction to create the stack address.

    symbol := inst^.Body.Addr.Symbol

    off := IrGetStackOffset (
        LirCurrentFunction, // func
        symbol, // symbol
    ) + inst^.Body.Addr.Offset + LirCurrentFunction^.ScratchAreaSize

    IF off == 0 AND inst^.Defines^.DefinedBy THEN
        // Just return the SP register.

        RETURN &FoxSp
    END

    defreg := LirGetRegister ( inst^.Defines )

    movinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOV, // machtype
    )

    movinst^.Defines = defreg
    movinst^.Source2 = &FoxSp

    movinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    movinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REGISTER
    movinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    movinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( movinst )

    IF off THEN
        addinst := LirCreateInstruction (
            LIR_MACH_INST, // type
            FOX_ADD, // machtype
        )

        // Note that for the sake of regalloc we put the defined register as
        // both used and defined here (because that's the sitch -- fox32 can
        // only add onto a register), but in the final assembly it will just be
        //
        //  add defreg, IMM
        //
        // We put an actual source register in Source2 instead.

        addinst^.Defines = defreg
        addinst^.Source1 = defreg

        addinst^.Body.Machine.Fox.Op2.Constant = off
        addinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
        addinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
        addinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
        addinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

        LirInsertInstructionTail ( addinst )
    END

    RETURN defreg
END

FN (LirSelectF) FoxSelectMove (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Select the most appropriate instruction.

    def := inst^.Defines
    src := inst^.Source1
    srcreg : ^LirRegister

    IF src^.DefinedBy THEN
        // The source is a temporary.

        IF src^.Opt.Dve.References == 1 THEN
            // This is the only reference to the temporary, so don't bother
            // sharing; twiddle its defining instruction to define us and then
            // generate that instead.

            src^.DefinedBy^.Defines = def

            RETURN LirSelect ( src^.DefinedBy )
        END

        srcreg = LirSelect ( src^.DefinedBy )

    ELSE
        srcreg = LirGetRegister ( src )
    END

    // Generate a fox32 reg-to-reg MOV instruction.

    defreg := LirGetRegister ( def )

    lirinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOV, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Source2 = srcreg

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirMoveHint ( defreg, srcreg )

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN FoxGeneratePreallocatedMov (
    IN srcreg : ^LirRegister,
    IN machreg : ^LirRegister,
    IN from : UBYTE,
) : ^LirRegister

    // Hint.

    srcreg^.Hint = machreg^.MachineRegister

    // Generate MOV to preallocated reg.

    movinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOV, // machtype
    )

    IF from THEN
        movinst^.Source2 = machreg
        movinst^.Defines = srcreg

    ELSE
        movinst^.Defines = machreg
        movinst^.Source2 = srcreg
    END

    movinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    movinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REGISTER
    movinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    movinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( movinst )

    IF from THEN
        RETURN srcreg

    ELSE
        RETURN machreg
    END
END

FN FoxGenerateStackAddress (
    IN tmp : ^LirRegister,
    IN beforeinst : ^LirInstruction,
    IN afterinst : ^LirInstruction,
    IN off : ULONG,
    OUT newoff : ULONG,
) : ^LirRegister

    newoff = off

    IF off >= 256 THEN
        // Generate an add instruction to compute the stack address.

        destreg : ^LirRegister = NULLPTR

        IF tmp THEN
            destreg = tmp

        ELSE
            destreg = LirCreateRegister ()
        END

        movinst := LirCreateInstruction (
            LIR_MACH_INST, // type
            FOX_MOV, // machtype
        )

        movinst^.Defines = destreg

        movinst^.Source2 = &FoxSp

        movinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
        movinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REGISTER
        movinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
        movinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

        IF beforeinst THEN
            LirInsertInstructionBefore (
                beforeinst, // beforeinst
                movinst, // inst
            )

        ELSEIF afterinst THEN
            LirInsertInstructionAfter (
                afterinst, // afterinst
                movinst, // inst
            )

        ELSE
            LirInsertInstructionTail ( movinst )
        END

        addinst := LirCreateInstruction (
            LIR_MACH_INST, // type
            FOX_ADD, // machtype
        )

        addinst^.Defines = destreg
        addinst^.Source1 = destreg

        addinst^.Body.Machine.Fox.Op2.Constant = off
        addinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
        addinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
        addinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
        addinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

        IF beforeinst THEN
            LirInsertInstructionBefore (
                beforeinst, // beforeinst
                addinst, // inst
            )

        ELSEIF afterinst THEN
            LirInsertInstructionAfter (
                movinst, // afterinst
                addinst, // inst
            )

        ELSE
            LirInsertInstructionTail ( addinst )
        END
    
        newoff = 0

        RETURN destreg

    ELSE
        RETURN &FoxSp
    END
END

FN FoxGenerateStoreToStack (
    IN srcreg : ^LirRegister,
    IN srcvar : ^IrVariable,
    IN off : ULONG,
)

    destreg := FoxGenerateStackAddress (
        NULLPTR, // tmp
        NULLPTR, // beforeinst
        NULLPTR, // afterinst
        off, // off
        OUT off, // OUT newoff
    )

    lirinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOV, // machtype
    )

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REG_PTR
    lirinst^.Body.Machine.Fox.Op1.Constant = off
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    lirinst^.Source1 = destreg

    IF srcreg THEN
        lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REGISTER
        lirinst^.Source2 = srcreg

    ELSE
        lirinst^.Source2 = FoxFillOperand (
            lirinst, // lirinst
            &lirinst^.Body.Machine.Fox.Op2, // operand
            srcvar, // var
            TRUE, // allowimm
        )
    END

    LirInsertInstructionTail ( lirinst )
END

FN FoxGenerateLoadFromStack (
    IN defreg : ^LirRegister,
    IN off : ULONG,
)

    srcreg := FoxGenerateStackAddress (
        NULLPTR, // tmp
        NULLPTR, // beforeinst
        NULLPTR, // afterinst
        off, // off
        OUT off, // OUT newoff
    )

    lirinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOVZ, // machtype
    )

    lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REG_PTR
    lirinst^.Body.Machine.Fox.Op2.Constant = off
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    lirinst^.Source2 = srcreg

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Defines = defreg

    LirInsertInstructionTail ( lirinst )
END

FN (LirSelectF) FoxSelectReturn (
    IN inst : ^IrInstruction,
) : ^LirRegister

    retval : ^LirRegister = NULLPTR

    IF inst^.Source1 THEN
        srcreg := LirSelectOrGetRegister ( inst^.Source1 )

        retval = FoxGeneratePreallocatedMov (
            srcreg, // srcreg
            &FoxArg[FOX_A3 - FOX_A0], // machreg
            FALSE, // from
        )
    END

    // Add an unconditional branch to the epilogue.

    lirinst := LirCreateInstruction (
        LIR_BRANCH, // type
        FOX_RJMP, // machtype
    )

    lirinst^.Source2 = retval

    lirinst^.TypeBody.Branch.Label =
        LirGetLabel ( LirCurrentFunction^.EpilogueLabel )

    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( lirinst )

    RETURN NULLPTR
END

FN FoxGenerateFalseBranch (
    IN inst : ^IrInstruction,
)

    IF inst^.Body.Branch.FalseLabel == inst^.Next THEN
        // The false label is the fall-through, don't generate the false branch.

        LEAVE
    END

    // Generate the false branch.

    jmpinst := LirCreateInstruction (
        LIR_BRANCH, // type
        FOX_RJMP, // machtype
    )

    jmpinst^.TypeBody.Branch.Label = LirGetLabel ( inst^.Body.Branch.FalseLabel )
    jmpinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    jmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( jmpinst )
END

FN (LirSelectF) FoxSelectZeroBranch (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF IrIsUselessBranch ( inst ) THEN
        RETURN NULLPTR
    END

    // Output CMP with IMM 0 and then IFNZ JMP.

    cmpinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_CMP, // machtype
    )

    cmpinst^.Body.Machine.Fox.Op2.Constant = 0
    cmpinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
    cmpinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    cmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_UNKNOWN

    cmpinst^.Source1 = FoxFillOperand (
        cmpinst, // lirinst
        &cmpinst^.Body.Machine.Fox.Op1, // operand
        inst^.Source1, // var
        FALSE, // allowimm
    )

    FoxSetIfUnknown ( cmpinst )

    LirInsertInstructionTail ( cmpinst )

    jmpinst := LirCreateInstruction (
        LIR_BRANCH, // type
        FOX_RJMP, // machtype
    )

    jmpinst^.TypeBody.Branch.Label = LirGetLabel ( inst^.Body.Branch.TrueLabel )

    IF inst^.Type == IR_BRANCH_NONZERO THEN
        jmpinst^.Body.Machine.Fox.Condition = FOX_COND_IFNZ

    ELSE
        jmpinst^.Body.Machine.Fox.Condition = FOX_COND_IFZ
    END

    jmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( jmpinst )

    // Generate an unconditional branch to the false label if required.

    FoxGenerateFalseBranch ( inst )

    RETURN NULLPTR
END

FN (LirSelectF) FoxSelectBranch (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF IrIsUselessBranch ( inst ) THEN
        RETURN NULLPTR
    END

    // Output CMP and then JMP.

    cmptype := FOX_CMP

    IF inst^.Type > IR_BRANCH_SIGNED_LOW_NUMBER AND
        inst^.Type < IR_BRANCH_SIGNED_HIGH_NUMBER THEN

        cmptype = FOX_ICMP
    END

    cmpinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        cmptype, // machtype
    )

    cmpinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    cmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    cmpinst^.Source1 = FoxFillOperand (
        cmpinst, // lirinst
        &cmpinst^.Body.Machine.Fox.Op1, // operand
        inst^.Source1, // var
        FALSE, // allowimm
    )

    cmpinst^.Source2 = FoxFillOperand (
        cmpinst, // lirinst
        &cmpinst^.Body.Machine.Fox.Op2, // operand
        inst^.Source2, // var
        TRUE, // allowimm
    )

    LirInsertInstructionTail ( cmpinst )

    jmpinst := LirCreateInstruction (
        LIR_BRANCH, // type
        FOX_RJMP, // machtype
    )

    jmpinst^.TypeBody.Branch.Label = LirGetLabel ( inst^.Body.Branch.TrueLabel )
    jmpinst^.Body.Machine.Fox.Condition = FoxIrInstToCondition[inst^.Type]
    jmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( jmpinst )

    // Generate an unconditional branch to the false label if required.

    FoxGenerateFalseBranch ( inst )

    RETURN NULLPTR
END

FN (LirSelectF) FoxSelectJump (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF inst^.Body.Jump.Label == inst^.Next THEN
        // Don't generate the jump; allow fall-through.

        RETURN NULLPTR
    END

    jmpinst := LirCreateInstruction (
        LIR_BRANCH, // type
        FOX_RJMP, // machtype
    )

    jmpinst^.TypeBody.Branch.Label = LirGetLabel ( inst^.Body.Jump.Label )
    jmpinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    jmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( jmpinst )

    RETURN NULLPTR
END

FN (LirSelectF) FoxSelectCall (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // We generate the call instruction and all of its arguments.

    callinst := LirCreateInstruction (
        LIR_CALL, // type
        FOX_CALL, // machtype
    )

    defreg : ^LirRegister = NULLPTR

    IF inst^.Defines THEN
        defreg = LirGetRegister ( inst^.Defines )

        // Hint the return value to machine reg a3 since that is what it is
        // passed back in.

        defreg^.Hint = FOX_A3
    END

    callinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    callinst^.Body.Machine.Fox.BitSize = FOX_BITS_32
    callinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_NONE

    // Now fill the call.

    callinst^.Source1 = FoxFillOperand (
        callinst, // lirinst
        &callinst^.Body.Machine.Fox.Op1, // operand
        inst^.Source1, // var
        TRUE, // allowimm
    )

    // First generate all of the arguments.

    arglisttail : ^LirArgument = NULLPTR
    callinst^.TypeBody.Call.ArgListHead = NULLPTR

    arg := inst^.Body.Call.ArgListHead
    count := 0
    stackoff := 0

    WHILE arg DO
        lirarg : ^LirArgument

        status := TlBumpAlloc (
            SIZEOF LirArgument, // bytes
            OUT lirarg, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate LIR argument", 0, 0, 0 )
        END

        IF count < 4 THEN
            lirarg^.Register = LirSelectOrGetRegister ( arg^.Variable )

        ELSE
            FoxGenerateStoreToStack (
                NULLPTR, // srcreg
                arg^.Variable, // srcvar
                stackoff, // off
            )

            stackoff += 4
        END

        lirarg^.Next = NULLPTR

        IF arglisttail THEN
            arglisttail^.Next = lirarg

        ELSE
            callinst^.TypeBody.Call.ArgListHead = lirarg
        END

        arglisttail = lirarg

        count += 1

        arg = arg^.Next
    END

    // Finally, generate MOVs to A0-A3.

    lirarg := callinst^.TypeBody.Call.ArgListHead
    count = 0

    WHILE lirarg DO
        IF count >= 4 THEN
            BREAK
        END

        FoxGeneratePreallocatedMov (
            lirarg^.Register, // reg
            &FoxArg[count], // machreg
            FALSE, // from
        )

        count += 1
        lirarg = lirarg^.Next
    END

    // Now insert the CALL instruction.

    LirInsertInstructionTail ( callinst )

    // Now generate a mov from A3 to the destination.

    IF defreg THEN
        FoxGeneratePreallocatedMov (
            defreg, // reg
            &FoxArg[FOX_A3 - FOX_A0], // machreg
            TRUE, // from
        )
    END

    outlisttail : ^LirArgument = NULLPTR
    callinst^.TypeBody.Call.OutListHead = NULLPTR

    arg = inst^.Body.Call.OutListHead
    count = 0

    stackoff = 0

    WHILE arg DO
        status := TlBumpAlloc (
            SIZEOF LirArgument, // bytes
            OUT lirarg, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate LIR argument", 0, 0, 0 )
        END

        IF arg^.Variable^.Opt.Dve.References != 0 THEN
            lirarg^.Register = LirGetRegister ( arg^.Variable )

            IF count < 3 THEN
                // First three OUT values are hinted to a0-a2 since they're
                // passed to the caller in those registers. a3 is the primary
                // return value. We allocate them "backwards" in the hope that
                // leaving the lower ones free will help keep the IN arguments
                // in the other regs.

                FoxGeneratePreallocatedMov (
                    lirarg^.Register, // reg
                    &FoxArg[2 - count], // machreg
                    TRUE, // from
                )
            
            ELSE
                FoxGenerateLoadFromStack (
                    lirarg^.Register, // defreg
                    stackoff, // off
                )
            END
        END

        IF count >= 3 THEN
            stackoff += 4
        END

        lirarg^.Next = NULLPTR

        IF outlisttail THEN
            outlisttail^.Next = lirarg

        ELSE
            callinst^.TypeBody.Call.OutListHead = lirarg
        END

        outlisttail = lirarg

        count += 1

        arg = arg^.Next
    END

    RETURN defreg
END

FN (LirSelectF) FoxSelectStore (
    IN inst : ^IrInstruction,
) : ^LirRegister

    lirinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOV, // machtype
    )

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_UNKNOWN

    lirinst^.Source1 = FoxFillOperandForAccess (
        lirinst, // lirinst
        &lirinst^.Body.Machine.Fox.Op1, // operand
        inst, // inst
        FALSE, // load
    )

    lirinst^.Source2 = FoxFillOperand (
        lirinst, // lirinst
        &lirinst^.Body.Machine.Fox.Op2, // operand
        inst^.Source2, // var
        TRUE, // allowimm
    )

    LirInsertInstructionTail ( lirinst )

    RETURN NULLPTR
END

FN (LirSelectF) FoxSelectCompare (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Output:
    //
    //  MOVZ.8 DEF, 0
    //  CMP A, B
    //  IF[COND] MOVZ.8 DEF, 1

    defreg := LirGetRegister ( inst^.Defines )

    falsemovinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOVZ, // machtype
    )

    falsemovinst^.Defines = defreg
    falsemovinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER

    falsemovinst^.Body.Machine.Fox.Op2.Constant = 0
    falsemovinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
    falsemovinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    falsemovinst^.Body.Machine.Fox.BitSize = FOX_BITS_8

    LirInsertInstructionTail ( falsemovinst )

    cmptype := FOX_CMP

    IF inst^.Type > IR_COMPARE_SIGNED_LOW_NUMBER AND
        inst^.Type < IR_COMPARE_SIGNED_HIGH_NUMBER THEN

        cmptype = FOX_ICMP
    END

    cmpinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        cmptype, // machtype
    )

    cmpinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    cmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    cmpinst^.Source1 = FoxFillOperand (
        cmpinst, // lirinst
        &cmpinst^.Body.Machine.Fox.Op1, // operand
        inst^.Source1, // var
        FALSE, // allowimm
    )

    cmpinst^.Source2 = FoxFillOperand (
        cmpinst, // lirinst
        &cmpinst^.Body.Machine.Fox.Op2, // operand
        inst^.Source2, // var
        TRUE, // allowimm
    )

    LirInsertInstructionTail ( cmpinst )

    movinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOVZ, // machtype
    )

    movinst^.Defines = defreg
    movinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER

    movinst^.Body.Machine.Fox.Op2.Constant = 1
    movinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
    movinst^.Body.Machine.Fox.Condition = FoxIrInstToCondition[inst^.Type]
    movinst^.Body.Machine.Fox.BitSize = FOX_BITS_8

    LirInsertInstructionTail ( movinst )

    RETURN defreg
END

FN (LirSelectF) FoxSelectNot (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Output:
    //
    //  MOVZ.8 DEF, 0
    //  CMP A, 0
    //  IFZ MOVZ.8 DEF, 1

    defreg := LirGetRegister ( inst^.Defines )

    falsemovinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOVZ, // machtype
    )

    falsemovinst^.Defines = defreg
    falsemovinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER

    falsemovinst^.Body.Machine.Fox.Op2.Constant = 0
    falsemovinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
    falsemovinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    falsemovinst^.Body.Machine.Fox.BitSize = FOX_BITS_8

    LirInsertInstructionTail ( falsemovinst )

    cmpinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_CMP, // machtype
    )

    cmpinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    cmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_32
    cmpinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
    cmpinst^.Body.Machine.Fox.Op2.Constant = 0

    cmpinst^.Source1 = FoxFillOperand (
        cmpinst, // lirinst
        &cmpinst^.Body.Machine.Fox.Op1, // operand
        inst^.Source1, // var
        FALSE, // allowimm
    )

    LirInsertInstructionTail ( cmpinst )

    movinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOVZ, // machtype
    )

    movinst^.Defines = defreg
    movinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER

    movinst^.Body.Machine.Fox.Op2.Constant = 1
    movinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
    movinst^.Body.Machine.Fox.Condition = FOX_COND_IFZ
    movinst^.Body.Machine.Fox.BitSize = FOX_BITS_8

    LirInsertInstructionTail ( movinst )

    RETURN defreg
END

FN FoxGenerateArithmeticMove (
    IN inst : ^IrInstruction,
    OUT newtemp : UWORD,
) : ^LirRegister

    // Generate a move into the temporary if required.

    newtemp = FALSE

    src := inst^.Source1
    defineinst := src^.DefinedBy

    IF defineinst AND
        src^.Opt.Dve.References == 1 AND
        defineinst^.Type != IR_STACK_ADDR AND
        inst^.Defines != inst^.Source2 THEN

        // Only we use this temporary, so twiddle it to define our defreg and
        // select it.

        // We don't do this if it's IR_STACK_ADDR because that performs an
        // optimization where it returns SP directly if the object offset is 0,
        // which could result in our caller modifying SP... which is bad.

        defineinst^.Defines = inst^.Defines

        RETURN LirSelect ( defineinst )
    END

    defreg : ^LirRegister

    IF inst^.Defines == inst^.Source2 THEN
        defreg = LirCreateRegister ()
        newtemp = TRUE

    ELSE
        defreg = LirGetRegister ( inst^.Defines )
    END

    srcreg := LirGetRegister ( inst^.Source1 )

    IF defreg == srcreg THEN
        RETURN defreg
    END

    movinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOV, // machtype
    )

    movinst^.Defines = defreg

    srcreg = FoxFillOperand (
        movinst, // lirinst
        &movinst^.Body.Machine.Fox.Op2, // operand
        inst^.Source1, // var
        TRUE, // allowimm
    )

    movinst^.Source2 = srcreg

    movinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    movinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    movinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    IF srcreg THEN
        LirMoveHint ( defreg, srcreg )
    END

    LirInsertInstructionTail ( movinst )

    RETURN defreg
END

FN (LirSelectF) FoxSelectBitNot (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Output:
    //
    //  MOV DEF, A
    //  NOT DEF

    newtemp : UWORD

    defreg := FoxGenerateArithmeticMove (
        inst, // inst
        OUT newtemp, // newtemp
    )

    lirinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_NOT, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Source1 = defreg

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_NONE
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) FoxSelectArithmetic (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Output:
    //
    //  MOV DEF, A
    //  ARITH DEF, B

    IF inst^.Defines == inst^.Source2 AND
        IrCommutativity[inst^.Type] THEN

        // Try to avoid the creation of a temporary by swapping Source1 and
        // Source2 so that Source2 no longer matches Defines.

        tmp := inst^.Source1
        inst^.Source1 = inst^.Source2
        inst^.Source2 = tmp
    END

    newtemp : UWORD

    defreg := FoxGenerateArithmeticMove (
        inst, // inst
        OUT newtemp, // newtemp
    )

    machtype := FoxIrInstToFoxOp[inst^.Type]

    lirinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        machtype, // machtype
    )

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    lirinst^.Defines = defreg
    lirinst^.Source1 = defreg

    lirinst^.Source2 = FoxFillOperand (
        lirinst, // lirinst
        &lirinst^.Body.Machine.Fox.Op2, // operand
        inst^.Source2, // var
        TRUE, // allowimm
    )

    IF lirinst^.Body.Machine.Fox.Op2.AccessType == FOX_ACCESS_IMM THEN
        constant := lirinst^.Body.Machine.Fox.Op2.Constant

        IF machtype == FOX_ADD THEN
            // Check if it can be turned into one of the fancy INCs.

            IF constant == 1 OR
                constant == 2 OR
                constant == 4 OR
                constant == 8 THEN

                lirinst^.MachineInstruction = FOX_INC
            END

        ELSEIF machtype == FOX_SUB THEN

            IF constant == 1 OR
                constant == 2 OR
                constant == 4 OR
                constant == 8 THEN

                lirinst^.MachineInstruction = FOX_DEC
            END
        END
    END

    LirInsertInstructionTail ( lirinst )

    IF newtemp THEN
        // Move result into real register.

        lirinst = LirCreateInstruction (
            LIR_MACH_INST, // type
            FOX_MOV, // machtype
        )

        lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
        lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REGISTER
        lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
        lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

        lirinst^.Defines = LirGetRegister ( inst^.Defines )
        lirinst^.Source2 = defreg

        LirInsertInstructionTail ( lirinst )
    END

    RETURN defreg
END

FN FoxHintFunction (
    IN funcsym : ^LexSymbol,
    IN irfunc : ^IrFunction,
)

    // Hint the first four arguments to a0-a3.

    head := irfunc^.LirHead

    functype := funcsym^.SemanticType

    arg := functype^.Body.Function.ArgListHead

    incount := 0
    outcount := 0

    WHILE arg DO
        symbol := arg^.Symbol

        irvar := CAST symbol^.IrContext TO ^IrVariable

        IF irvar THEN
            irreg := LirGetRegister ( irvar )

            IF arg^.InOut == ARG_IN AND incount < 4 THEN
                irreg^.Hint = FOX_A0 + incount

                // Create a junk node that defines this at the start of the
                // function, for regalloc purposes.

                junkinst := LirCreateInstruction (
                    LIR_JUNK, // type
                    0, // machtype
                )

                junkinst^.Defines = irreg

                junkinst^.Source1 = &FoxArg[incount]

                LirInsertInstructionBefore (
                    head, // beforeinst
                    junkinst, // inst
                )

            ELSEIF arg^.InOut == ARG_OUT AND outcount < 3 THEN
                irreg^.Hint = FOX_A2 - outcount

                // Create a junk node that defines this at the end of the
                // function, for regalloc purposes.

                junkinst := LirCreateInstruction (
                    LIR_JUNK, // type
                    0, // machtype
                )

                junkinst^.Defines = &FoxArg[2 - outcount]

                junkinst^.Source1 = irreg

                LirInsertInstructionAfter (
                    irfunc^.LirTail, // afterinst
                    junkinst, // inst
                )
            END
        END

        IF arg^.InOut == ARG_IN THEN
            incount += 1

        ELSE
            outcount += 1
        END

        arg = arg^.Next
    END

    IF functype^.Body.Function.IsVarArg THEN
        // Hint the vartable and argcount symbols.

        i := 0

        WHILE incount < 4 AND i < 2 DO
            symbol : ^LexSymbol

            IF NOT i THEN
                symbol = functype^.Body.Function.VarArgTable

            ELSE
                symbol = functype^.Body.Function.VarArgCount
            END

            irvar := CAST symbol^.IrContext TO ^IrVariable

            IF irvar THEN
                irreg := LirGetRegister ( irvar )

                irreg^.Hint = FOX_A0 + incount

                junkinst := LirCreateInstruction (
                    LIR_JUNK, // type
                    0, // machtype
                )

                junkinst^.Defines = irreg

                junkinst^.Source1 = &FoxArg[incount]

                LirInsertInstructionBefore (
                    head, // beforeinst
                    junkinst, // inst
                )
            END

            incount += 1
            i += 1
        END
    END
END

FN FoxGenerateSpillForOperand (
    IN inst : ^LirInstruction,
    IN spilledreg : ^LirRegister,
    IN operand : ^LirFoxOperand,
    IN tmp : UWORD,
    IN src : UWORD,
) : ^LirRegister

    spreg : ^LirRegister
    tmpreg := &FoxTmps[tmp]

    spilloff := LirGetSpillOffset (
        inst^.Block, // irfunc
        spilledreg, // spilledreg
    )

    IF operand^.AccessType == FOX_ACCESS_REGISTER THEN
        IF src OR inst^.Body.Machine.Fox.BitSize == FOX_BITS_32 THEN
            // Replace in-place with an [SP + OFF].

            spreg = FoxGenerateStackAddress (
                tmpreg, // tmp
                inst, // beforeinst
                NULLPTR, // afterinst
                spilloff, // off
                OUT spilloff, // OUT newoff
            )

            operand^.AccessType = FOX_ACCESS_REG_PTR
            operand^.Constant = spilloff

            RETURN spreg
        END

        // Bits aren't right and this is a destination. We have to do
        // an intermediate store of the correct width and maybe a load too.

        IF spilledreg == inst^.Source1 THEN
            spreg = FoxGenerateStackAddress (
                tmpreg, // tmp
                inst, // beforeinst
                NULLPTR, // afterinst
                spilloff, // off
                OUT spilloff, // OUT newoff
            )

            // Generate load.

            lirinst := LirCreateInstruction (
                LIR_MACH_INST, // type
                FOX_MOVZ, // machtype
            )

            lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REG_PTR
            lirinst^.Body.Machine.Fox.Op2.Constant = spilloff
            lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
            lirinst^.Body.Machine.Fox.BitSize = inst^.Body.Machine.Fox.BitSize

            lirinst^.Source2 = spreg

            lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
            lirinst^.Defines = tmpreg

            LirInsertInstructionBefore (
                inst, // beforeinst
                lirinst, // inst
            )
        END

        IF spilledreg == inst^.Defines THEN
            // Re-generate the SP offset.

            spilloff = LirGetSpillOffset (
                inst^.Block, // irfunc
                spilledreg, // spilledreg
            )

            beforeinst := inst^.Next

            othertmp := tmpreg

            IF othertmp == &FoxTmps[0] THEN
                othertmp = &FoxTmps[1]

            ELSE
                othertmp = &FoxTmps[0]
            END

            spreg = FoxGenerateStackAddress (
                othertmp, // tmp
                NULLPTR, // beforeinst
                inst, // afterinst
                spilloff, // off
                OUT spilloff, // OUT newoff
            )

            // Generate store. 

            lirinst := LirCreateInstruction (
                LIR_MACH_INST, // type
                FOX_MOV, // machtype
            )

            lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REG_PTR
            lirinst^.Body.Machine.Fox.Op1.Constant = spilloff
            lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
            lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

            lirinst^.Source1 = spreg
            lirinst^.Source2 = tmpreg

            lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REGISTER

            IF beforeinst THEN
                LirInsertInstructionBefore (
                    beforeinst, // afterinst
                    lirinst, // inst
                )

            ELSE
                LirInsertInstructionTail ( lirinst )
            END
        END

        IF spilledreg == inst^.Source1 THEN
            inst^.Body.Machine.Fox.BitSize = FOX_BITS_32
        END

        operand^.AccessType = FOX_ACCESS_REGISTER

        RETURN tmpreg
    END

    IF operand^.AccessType != FOX_ACCESS_REG_PTR THEN
        TlInternalError ( "Fox: Bad spill", 0, 0, 0 )
    END

    // We have to load the spilled reg into a temporary, then shove that
    // temporary into the instruction.

    spreg = FoxGenerateStackAddress (
        &FoxTmpAt, // tmp
        inst, // beforeinst
        NULLPTR, // afterinst
        spilloff, // off
        OUT spilloff, // OUT newoff
    )

    lirinst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOVZ, // machtype
    )

    lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REG_PTR
    lirinst^.Body.Machine.Fox.Op2.Constant = spilloff
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    lirinst^.Source2 = spreg

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Defines = tmpreg

    LirInsertInstructionBefore (
        inst, // beforeinst
        lirinst, // inst
    )

    RETURN tmpreg
END

FN FoxGenerateSpills (
    IN irfunc : ^IrFunction,
)

    // Iterate the regalloc'd LIR to generate spill code.
    // We use three permanently reserved temporaries: T5, T6, and AT, which were
    // previously excluded from regalloc decisions. T5 and T6 are used to hold
    // spilled registers, of which there can be at most two per instruction. AT
    // is used in the case that the spill location for a register is outside the
    // readily accessible stack and needs to be calculated.
    //
    // Whenever the spilled register is a direct register operand, we can
    // replace it with the [SP + OFF] in-place. Otherwise, it must be an
    // indirect memory access. In that case, we load it into a temporary and
    // then replace the spilled reg with the temporary in-place.
    //
    // These are the replacement cases (not counting when off > 256):
    //
    //  SPILL, R                     ->  [SP + OFF], R
    //
    //  R, SPILL                     ->  R, [SP + OFF]
    //
    //  SPILL, SPILL                 ->  [SP + OFF], [SP + OFF]
    //
    //  [SPILL + X], R               ->  T5 = [SP + OFF]
    //                               ->  [T5 + X], R
    //
    //  R, [SPILL + X]               ->  T5 = [SP + OFF]
    //                                   R, [T5 + X]
    //
    //  [SPILL + X], [SPILL + X]     ->  T5 = [SP + OFF]
    //                                   T6 = [SP + OFF]
    //                                   [T5 + X], [T6 + X]

    // Remember to elide moves that are from a register to itself; these
    // appeared after regalloc! We don't elide useless jumps here because there
    // are still opportunities for them to appear. We do that at code emission
    // time instead.

    inst := irfunc^.LirHead

    WHILE inst DO
        def := inst^.Defines
        src1 := inst^.Source1
        src2 := inst^.Source2

        type := inst^.Type
        machinst := inst^.MachineInstruction
        access1 := inst^.Body.Machine.Fox.Op1.AccessType
        access2 := inst^.Body.Machine.Fox.Op2.AccessType

        IF type == LIR_JUNK THEN
            LirRemoveInstruction ( inst )

            inst = inst^.Next

            CONTINUE
        END

        // First check if this is a useless move. Despite the massive bundle of
        // conditions below, this is a pretty common occurrence after regalloc,
        // since we didn't know if register hinting would be successful until
        // after we generated lots of MOVs into function argument registers and
        // so on.

        IF type == LIR_MACH_INST AND
            (machinst == FOX_MOV OR machinst == FOX_MOVZ) AND
            inst^.Body.Machine.Fox.BitSize == FOX_BITS_32 AND
            access1 == FOX_ACCESS_REGISTER AND
            access2 == FOX_ACCESS_REGISTER THEN

            IF def == src2 OR
                (def^.Type == LIR_PREALLOCATED_REG OR
                def^.Type == LIR_MACHINE_REG) AND
                (src2^.Type == LIR_PREALLOCATED_REG OR
                src2^.Type == LIR_MACHINE_REG) AND
                (def^.MachineRegister == src2^.MachineRegister) THEN

                // Elide this useless move.

                LirRemoveInstruction ( inst )

                inst = inst^.Next

                CONTINUE
            END
        END

        tmp := 0

        IF def AND def^.Type == LIR_SPILLED_REG THEN
            inst^.Defines = FoxGenerateSpillForOperand (
                inst, // inst
                def, // spilledreg
                &inst^.Body.Machine.Fox.Op1, // operand
                tmp, // tmp
                FALSE, // src
            )

            tmp += 1

        ELSEIF src1 AND src1^.Type == LIR_SPILLED_REG THEN
            inst^.Source1 = FoxGenerateSpillForOperand (
                inst, // inst
                src1, // spilledreg
                &inst^.Body.Machine.Fox.Op1, // operand
                tmp, // tmp
                TRUE, // src
            )

            tmp += 1
        END

        IF src2 AND src2^.Type == LIR_SPILLED_REG THEN
            inst^.Source2 = FoxGenerateSpillForOperand (
                inst, // inst
                src2, // spilledreg
                &inst^.Body.Machine.Fox.Op2, // operand
                tmp, // tmp
                TRUE, // src
            )
        END

        inst = inst^.Next
    END
END

FN FoxGenerateAbiStuff (
    IN funcsym : ^LexSymbol,
    IN irfunc : ^IrFunction,
)

    // Generate a prologue and epilogue for the function.

    functype := funcsym^.SemanticType

    // Remember not to generate MOVs from a register to itself, we already
    // generated the spill code so there's no pass after this to get rid of
    // redundant MOVs again.

    // First generate the prologue. The prologue is:
    //
    //  PUSH FP
    //  MOV FP, SP
    //  PUSH { all allocated callee saved regs }
    //  SUB SP, { frame size }
    //  MOV { all arguments }, { their input reg or stack location }

    head := irfunc^.LirHead
    regmap := &irfunc^.RegisterAllocationStatus[0]

    //  PUSH FP

    inst := LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_PUSH, // machtype
    )

    inst^.Source1 = &FoxFp
    inst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    inst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_NONE
    inst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    inst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionBefore (
        head, // beforeinst
        inst, // inst
    )

    //  MOV FP, SP

    inst = LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_MOV, // machtype
    )

    inst^.Defines = &FoxFp
    inst^.Source2 = &FoxSp

    inst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    inst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REGISTER
    inst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    inst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionBefore (
        head, // beforeinst
        inst, // inst
    )

    //  PUSH { all allocated callee saved regs }

    i := FOX_S0

    // stackoff tracks offset from SP to caller's scratch area.

    stackoff := 8

    WHILE i <= FOX_S17 DO
        IF regmap[i] THEN
            inst = LirCreateInstruction (
                LIR_MACH_INST, // type
                FOX_PUSH, // machtype
            )

            inst^.Source1 = &FoxCalleeSaved[i - FOX_S0]

            inst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
            inst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_NONE
            inst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
            inst^.Body.Machine.Fox.BitSize = FOX_BITS_32

            LirInsertInstructionBefore (
                head, // beforeinst
                inst, // inst
            )

            stackoff += 4
        END

        i += 1
    END

    //  SUB SP, { frame size }

    framesize := irfunc^.StackFrameSize + irfunc^.ScratchAreaSize

    IF framesize THEN
        inst = LirCreateInstruction (
            LIR_MACH_INST, // type
            FOX_SUB, // machtype
        )

        inst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
        inst^.Body.Machine.Fox.Op2.Constant = framesize
        inst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
        inst^.Body.Machine.Fox.BitSize = FOX_BITS_32

        inst^.Defines = &FoxSp
        inst^.Source1 = &FoxSp

        inst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER

        LirInsertInstructionBefore (
            head, // beforeinst
            inst, // inst
        )
    END

    //  MOV { all arguments }, { their input reg or stack location }

    arg := functype^.Body.Function.ArgListHead
    count := 0

    scratchoff := stackoff + framesize
    varargextras := 0

    IF functype^.Body.Function.IsVarArg THEN
        varargextras = 2
    END

    WHILE TRUE DO
        symbol : ^LexSymbol

        IF arg THEN
            IF arg^.InOut != ARG_IN THEN
                arg = arg^.Next

                CONTINUE
            END

            symbol = arg^.Symbol

        ELSEIF NOT varargextras THEN
            BREAK

        ELSE
            IF varargextras == 2 THEN
                symbol = functype^.Body.Function.VarArgTable

            ELSE
                symbol = functype^.Body.Function.VarArgCount
            END

            varargextras -= 1
        END

        irvar := CAST symbol^.IrContext TO ^IrVariable

        IF irvar AND irvar^.Opt.Dve.References THEN
            irreg := LirGetRegister ( irvar )

            // Move it from the right place.

            IF irreg^.Type == LIR_MACHINE_REG AND
                count < 4 AND
                irreg^.MachineRegister == FOX_A0 + count THEN

                // Oh it's already there, nvm.
            
            ELSE
                inst = LirCreateInstruction (
                    LIR_MACH_INST, // type
                    FOX_MOV, // machtype
                )

                inst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
                inst^.Body.Machine.Fox.BitSize = FOX_BITS_32

                IF irreg^.Type == LIR_MACHINE_REG THEN
                    // To register.

                    inst^.Defines = irreg
                    inst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER

                ELSEIF irreg^.Type == LIR_SPILLED_REG THEN
                    // To stack location.

                    off := irreg^.SpilledOffset

                    spreg := FoxGenerateStackAddress (
                        &FoxTmps[0], // tmp
                        head, // beforeinst
                        NULLPTR, // afterinst
                        off, // off
                        OUT off, // OUT newoff
                    )

                    inst^.Source1 = spreg
                    inst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REG_PTR
                    inst^.Body.Machine.Fox.Op1.Constant = off

                ELSE
                    TlInternalError ( "Unexpected reg type", irreg^.Type, 0, 0 )
                END

                IF count < 4 THEN
                    // From arg reg.

                    inst^.Source2 = &FoxArg[count]

                    inst^.Body.Machine.Fox.Op2.AccessType =
                        FOX_ACCESS_REGISTER

                ELSE
                    // From stack.

                    off := scratchoff

                    spreg := FoxGenerateStackAddress (
                        &FoxTmps[1], // tmp
                        head, // beforeinst
                        NULLPTR, // afterinst
                        off, // off
                        OUT off, // OUT newoff
                    )

                    inst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REG_PTR
                    inst^.Body.Machine.Fox.Op2.Constant = off

                    inst^.Source2 = spreg
                END

                LirInsertInstructionBefore (
                    head, // beforeinst
                    inst, // inst
                )
            END
        END

        IF count >= 4 THEN
            scratchoff += 4
        END

        count += 1

        IF arg THEN
            arg = arg^.Next
        END
    END

    // Now generate the epilogue. The epilogue is:
    //
    //  MOV { their output reg or stack location }, { all OUT parameters }
    //  ADD SP, { frame size }
    //  POP { all allocated callee saved regs, reverse order }
    //  POP FP
    //  RET

    //  MOV { their output reg or stack location }, { all OUT parameters }

    arg = functype^.Body.Function.ArgListHead

    count = 0
    scratchoff = stackoff + framesize

    WHILE arg DO
        IF arg^.InOut != ARG_OUT THEN
            arg = arg^.Next

            CONTINUE
        END

        symbol := arg^.Symbol

        irvar := CAST symbol^.IrContext TO ^IrVariable

        // If the refcount for this OUT parameter is only 1, then it was never
        // referenced in the function body. Don't try to output it or we will
        // choke since the regalloc didn't give it a machine register.

        irreg := LirGetRegister ( irvar )

        IF irreg^.Type != LIR_VIRTUAL_REG THEN
            IF irreg^.Type == LIR_MACHINE_REG AND
                count < 3 AND
                irreg^.MachineRegister == FOX_A2 - count THEN

                // Oh it's already there, nvm.
            
            ELSE
                inst = LirCreateInstruction (
                    LIR_MACH_INST, // type
                    FOX_MOV, // machtype
                )

                inst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
                inst^.Body.Machine.Fox.BitSize = FOX_BITS_32

                IF irreg^.Type == LIR_MACHINE_REG THEN
                    // From register.

                    inst^.Source2 = irreg
                    inst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REGISTER

                ELSEIF irreg^.Type == LIR_SPILLED_REG THEN
                    // From stack location.

                    off := irreg^.SpilledOffset

                    spreg := FoxGenerateStackAddress (
                        &FoxTmps[0], // tmp
                        NULLPTR, // beforeinst
                        irfunc^.LirTail, // afterinst
                        off, // off
                        OUT off, // OUT newoff
                    )

                    inst^.Source2 = spreg
                    inst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REG_PTR
                    inst^.Body.Machine.Fox.Op2.Constant = off

                ELSE
                    TlInternalError ( "Unexpected reg type", irreg^.Type, 0, 0 )
                END

                IF count < 3 THEN
                    // To arg reg.

                    inst^.Defines = &FoxArg[2 - count]

                    inst^.Body.Machine.Fox.Op1.AccessType =
                        FOX_ACCESS_REGISTER

                ELSE
                    // To stack.

                    off := scratchoff

                    spreg := FoxGenerateStackAddress (
                        &FoxTmps[1], // tmp
                        NULLPTR, // beforeinst
                        irfunc^.LirTail, // afterinst
                        off, // off
                        OUT off, // OUT newoff
                    )

                    inst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REG_PTR
                    inst^.Body.Machine.Fox.Op1.Constant = off

                    inst^.Source1 = spreg
                END

                LirInsertInstructionAfter (
                    irfunc^.LirTail, // afterinst
                    inst, // inst
                )
            END
        END

        IF count >= 3 THEN
            scratchoff += 4
        END

        count += 1

        arg = arg^.Next
    END

    //  ADD SP, { frame size }

    IF framesize THEN
        inst = LirCreateInstruction (
            LIR_MACH_INST, // type
            FOX_ADD, // machtype
        )

        inst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
        inst^.Body.Machine.Fox.Op2.Constant = framesize
        inst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
        inst^.Body.Machine.Fox.BitSize = FOX_BITS_32

        inst^.Defines = &FoxSp
        inst^.Source1 = &FoxSp

        inst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER

        LirInsertInstructionAfter (
            irfunc^.LirTail, // afterinst
            inst, // inst
        )
    END

    //  POP { all allocated callee saved regs, reverse order }

    WHILE i > FOX_S0 DO
        i -= 1

        IF regmap[i] THEN
            inst = LirCreateInstruction (
                LIR_MACH_INST, // type
                FOX_POP, // machtype
            )

            inst^.Defines = &FoxCalleeSaved[i - FOX_S0]

            inst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
            inst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_NONE
            inst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
            inst^.Body.Machine.Fox.BitSize = FOX_BITS_32

            LirInsertInstructionAfter (
                irfunc^.LirTail, // afterinst
                inst, // inst
            )
        END
    END

    //  POP FP

    inst = LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_POP, // machtype
    )

    inst^.Defines = &FoxFp
    inst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    inst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_NONE
    inst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    inst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionAfter (
        irfunc^.LirTail, // afterinst
        inst, // inst
    )

    // RET

    inst = LirCreateInstruction (
        LIR_MACH_INST, // type
        FOX_RET, // machtype
    )

    inst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    inst^.Body.Machine.Fox.BitSize = FOX_BITS_32
    inst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_NONE
    inst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_NONE

    LirInsertInstructionAfter (
        irfunc^.LirTail, // afterinst
        inst, // inst
    )
END

FoxLirInfo : LirTargetInfoRecord = {
    [SelectionTable] = {
        [IR_LOAD] = &FoxSelectLoad,
        [IR_ADDR] = &FoxSelectAddr,
        [IR_STRING_ADDR] = &FoxSelectAddr,
        [IR_STACK_ADDR] = &FoxSelectStackAddr,
        [IR_CONSTANT] = &FoxSelectAddr,
        [IR_MOVE] = &FoxSelectMove,

        [IR_RETURN] = &FoxSelectReturn,

        [IR_BRANCH_NONZERO] = &FoxSelectZeroBranch,
        [IR_BRANCH_ZERO] = &FoxSelectZeroBranch,

        [IR_BRANCH_EQUALS] = &FoxSelectBranch,
        [IR_BRANCH_NOT_EQUALS] = &FoxSelectBranch,
        [IR_BRANCH_LESS_THAN] = &FoxSelectBranch,
        [IR_BRANCH_GREATER_THAN] = &FoxSelectBranch,
        [IR_BRANCH_LTEQ] = &FoxSelectBranch,
        [IR_BRANCH_GTEQ] = &FoxSelectBranch,
        [IR_BRANCH_LESS_THAN_SIGNED] = &FoxSelectBranch,
        [IR_BRANCH_GREATER_THAN_SIGNED] = &FoxSelectBranch,
        [IR_BRANCH_LTEQ_SIGNED] = &FoxSelectBranch,
        [IR_BRANCH_GTEQ_SIGNED] = &FoxSelectBranch,
        [IR_JUMP] = &FoxSelectJump,

        [IR_CALL] = &FoxSelectCall,
        [IR_STORE] = &FoxSelectStore,

        [IR_COMPARE_EQUALS] = &FoxSelectCompare,
        [IR_COMPARE_NOT_EQUALS] = &FoxSelectCompare,
        [IR_COMPARE_LESS_THAN] = &FoxSelectCompare,
        [IR_COMPARE_GREATER_THAN] = &FoxSelectCompare,
        [IR_COMPARE_LTEQ] = &FoxSelectCompare,
        [IR_COMPARE_GTEQ] = &FoxSelectCompare,
        [IR_COMPARE_LESS_THAN_SIGNED] = &FoxSelectCompare,
        [IR_COMPARE_GREATER_THAN_SIGNED] = &FoxSelectCompare,
        [IR_COMPARE_LTEQ_SIGNED] = &FoxSelectCompare,
        [IR_COMPARE_GTEQ_SIGNED] = &FoxSelectCompare,

        [IR_NOT] = &FoxSelectNot,

        [IR_BIT_AND] = &FoxSelectArithmetic,
        [IR_BIT_OR] = &FoxSelectArithmetic,
        [IR_ADD] = &FoxSelectArithmetic,
        [IR_SUBTRACT] = &FoxSelectArithmetic,
        [IR_DIVIDE] = &FoxSelectArithmetic,
        [IR_DIVIDE_SIGNED] = &FoxSelectArithmetic,
        [IR_MODULO] = &FoxSelectArithmetic,
        [IR_BIT_XOR] = &FoxSelectArithmetic,
        [IR_LEFT_SHIFT] = &FoxSelectArithmetic,
        [IR_RIGHT_SHIFT] = &FoxSelectArithmetic,
        [IR_RIGHT_SHIFT_SIGNED] = &FoxSelectArithmetic,
        [IR_MULTIPLY] = &FoxSelectArithmetic,

        [IR_BIT_NOT] = &FoxSelectBitNot,
    },
    [RegisterAbiUsage] = {
        [FOX_T0] = LIR_REG_CALLER_SAVED,
        [FOX_T1] = LIR_REG_CALLER_SAVED,
        [FOX_T2] = LIR_REG_CALLER_SAVED,
        [FOX_T3] = LIR_REG_CALLER_SAVED,
        [FOX_T4] = LIR_REG_CALLER_SAVED,
        [FOX_A0] = LIR_REG_CALLER_SAVED,
        [FOX_A1] = LIR_REG_CALLER_SAVED,
        [FOX_A2] = LIR_REG_CALLER_SAVED,
        [FOX_A3] = LIR_REG_CALLER_SAVED,
        [FOX_S0] = LIR_REG_CALLEE_SAVED,
        [FOX_S1] = LIR_REG_CALLEE_SAVED,
        [FOX_S2] = LIR_REG_CALLEE_SAVED,
        [FOX_S3] = LIR_REG_CALLEE_SAVED,
        [FOX_S4] = LIR_REG_CALLEE_SAVED,
        [FOX_S5] = LIR_REG_CALLEE_SAVED,
        [FOX_S6] = LIR_REG_CALLEE_SAVED,
        [FOX_S7] = LIR_REG_CALLEE_SAVED,
        [FOX_S8] = LIR_REG_CALLEE_SAVED,
        [FOX_S9] = LIR_REG_CALLEE_SAVED,
        [FOX_S10] = LIR_REG_CALLEE_SAVED,
        [FOX_S11] = LIR_REG_CALLEE_SAVED,
        [FOX_S12] = LIR_REG_CALLEE_SAVED,
        [FOX_S13] = LIR_REG_CALLEE_SAVED,
        [FOX_S14] = LIR_REG_CALLEE_SAVED,
        [FOX_S15] = LIR_REG_CALLEE_SAVED,
        [FOX_S16] = LIR_REG_CALLEE_SAVED,
        [FOX_S17] = LIR_REG_CALLEE_SAVED,
        [FOX_R31] = LIR_REG_CALLER_SAVED,
    },
    [MaximumRegister] = FOX_REG_MAX,
}

FN FoxEmitOperand (
    IN reg : ^LirRegister,
    IN operand : ^LirFoxOperand,
)

    IF operand^.AccessType == FOX_ACCESS_REG_PTR OR
        operand^.AccessType == FOX_ACCESS_IMM_PTR OR
        operand^.AccessType == FOX_ACCESS_IMM_PTR_NAME THEN

        XrAsmInsertString ( "[" )
    END

    IF operand^.AccessType == FOX_ACCESS_REGISTER OR
        operand^.AccessType == FOX_ACCESS_REG_PTR THEN

        IF reg^.Type != LIR_PREALLOCATED_REG AND
            reg^.Type != LIR_MACHINE_REG THEN

            TlInternalError ( "Fox: Weird reg type", reg^.Type, 0, 0 )
        END

        XrAsmInsertString ( FoxRegisterNames[reg^.MachineRegister] )

        IF operand^.AccessType == FOX_ACCESS_REG_PTR AND
            operand^.Constant THEN

            XrAsmInsertString ( " + " )
            XrAsmInsertNumber ( operand^.Constant )
        END
    
    ELSEIF operand^.AccessType == FOX_ACCESS_IMM_PTR OR
        operand^.AccessType == FOX_ACCESS_IMM THEN

        XrAsmInsertNumber ( operand^.Constant & 0xFFFFFFFF )
    
    ELSEIF operand^.AccessType == FOX_ACCESS_IMM_STRING THEN
        string := CAST operand^.Constant TO ^LexInternedString

        XrAsmEmitString ( string )

    ELSEIF operand^.AccessType == FOX_ACCESS_IMM_PTR_NAME OR
        operand^.AccessType == FOX_ACCESS_IMM_NAME THEN

        symbol := CAST operand^.Constant TO ^LexSymbol

        XrAsmInsertString ( symbol^.Name )
    END

    IF operand^.AccessType == FOX_ACCESS_REG_PTR OR
        operand^.AccessType == FOX_ACCESS_IMM_PTR OR
        operand^.AccessType == FOX_ACCESS_IMM_PTR_NAME THEN

        XrAsmInsertString ( "]" )
    END
END

FoxNextBranchNumber := 0

FN FoxEmitInstruction (
    IN lirinst : ^LirInstruction,
)

    IF lirinst^.Type == LIR_MACH_INST OR
        lirinst^.Type == LIR_CALL OR
        lirinst^.Type == LIR_BRANCH OR
        lirinst^.Type == LIR_RETURN THEN

        XrAsmInsertString ( "    " )

        XrAsmInsertString (
            FoxConditionNames[lirinst^.Body.Machine.Fox.Condition] )

        XrAsmInsertString ( FoxInstructionNames[lirinst^.MachineInstruction] )

        XrAsmInsertString ( FoxBitsNames[lirinst^.Body.Machine.Fox.BitSize] )

        XrAsmInsertString ( " " )

        IF lirinst^.Type == LIR_BRANCH THEN
            num := lirinst^.TypeBody.Branch.Label^.Body.Label.Number

            IF num == 0xFFFFFFFF THEN
                num = FoxNextBranchNumber
                lirinst^.TypeBody.Branch.Label^.Body.Label.Number = num

                FoxNextBranchNumber += 1
            END

            XrAsmInsertString ( ".L" )
            XrAsmInsertNumber ( num )

        ELSE
            reg1 := lirinst^.Defines

            IF NOT reg1 THEN
                reg1 = lirinst^.Source1
            END

            reg2 := lirinst^.Source2

            IF lirinst^.Body.Machine.Fox.Op1.AccessType != FOX_ACCESS_NONE THEN
                FoxEmitOperand (
                    reg1, // reg
                    &lirinst^.Body.Machine.Fox.Op1, // operand
                )
            END

            IF lirinst^.Body.Machine.Fox.Op2.AccessType != FOX_ACCESS_NONE THEN
                XrAsmInsertString ( ", " )

                FoxEmitOperand (
                    reg2, // reg
                    &lirinst^.Body.Machine.Fox.Op2, // operand
                )
            END
        END

        XrAsmInsertString ( "\n" )

    ELSEIF lirinst^.Type == LIR_LABEL THEN
        num := lirinst^.Body.Label.Number

        IF num == 0xFFFFFFFF THEN
            num = FoxNextBranchNumber
            lirinst^.Body.Label.Number = num

            FoxNextBranchNumber += 1
        END

        XrAsmInsertString ( ".L" )
        XrAsmInsertNumber ( num )
        XrAsmInsertString ( ":\n" )

    ELSEIF lirinst^.Type == LIR_INSERTASM THEN
        XrAsmInsertString ( "    " )

        XrAsmInsertString (
            lirinst^.Body.InsertAsm.String^.DynamicBuffer.Buffer )
        
        XrAsmInsertString ( "\n" )

    ELSE
        TlInternalError ( "Fox: Weird LIR type", lirinst^.Type, 0, 0 )
    END
END

FN (JklIsUnconditionalF) FoxIsUnconditional (
    IN inst : ^LirInstruction,
) : UBYTE

    RETURN (inst^.MachineInstruction == FOX_RJMP OR
        inst^.MachineInstruction == FOX_JMP) AND
        inst^.Body.Machine.Fox.Condition == FOX_COND_ALWAYS
END

FN FoxElideUselessJump (
    IN inst : ^LirInstruction,
) : UWORD

    // Check if this branch instruction is followed by both its true and false
    // label. We walk along each label until we reach the first non-label
    // instruction so that we catch all the cases.

    next := inst^.Next

    WHILE next AND next^.Type == LIR_LABEL DO
        IF inst^.TypeBody.Branch.Label == next THEN
            next^.Body.Label.References -= 1

            RETURN TRUE
        END

        next = next^.Next
    END

    RETURN FALSE
END

FN (AsmEmitF) FoxEmitFunction (
    IN funcsym : ^LexSymbol,
)

    // Emit the final assembly language for a function.

    irfunc := CAST funcsym^.InitialValue TO ^IrFunction

    inst := irfunc^.LirHead

    dead := FALSE

    WHILE inst DO
        IF inst^.Type == LIR_LABEL THEN
            IF NOT inst^.Body.Label.References THEN
                inst = inst^.Next

                CONTINUE

            ELSE
                dead = FALSE
            END

        ELSEIF dead THEN
            inst = inst^.Next

            CONTINUE

        ELSEIF inst^.Type == LIR_BRANCH THEN
            IF FoxElideUselessJump ( inst ) THEN
                inst = inst^.Next

                CONTINUE
            END

            IF (inst^.MachineInstruction == FOX_RJMP OR
                inst^.MachineInstruction == FOX_JMP) AND
                inst^.Body.Machine.Fox.Condition == FOX_COND_ALWAYS THEN

                dead = TRUE
            END
        END

        FoxEmitInstruction ( inst )

        inst = inst^.Next
    END
END

FoxAsmEmitter : AsmEmitterRecord = {
    [EmitFunc] = &FoxEmitFunction,
}

FN (JklValueNumberF) FoxValueNumber (
    IN constant : UWORD,
) : UBYTE

    // Return whether to value number this constant.
    // Doing this too much could create too many callee-saved registers if the
    // constant is live over a function call. Doing it too little will
    // recompute large constants too much.

    // Never value number constants on fox32 since we can always fit them into
    // the instruction.

    RETURN FALSE
END

FN (JklTargetF) FoxCompile ()
    
    // Compile the program for the fox32 architecture.

    FoxTmps[0].Type = LIR_PREALLOCATED_REG
    FoxTmps[0].MachineRegister = FOX_T5

    FoxTmps[1].Type = LIR_PREALLOCATED_REG
    FoxTmps[1].MachineRegister = FOX_T6

    FoxTmpAt.Type = LIR_PREALLOCATED_REG
    FoxTmpAt.MachineRegister = FOX_AT

    FoxSp.Type = LIR_PREALLOCATED_REG
    FoxSp.MachineRegister = FOX_SP

    FoxFp.Type = LIR_PREALLOCATED_REG
    FoxFp.MachineRegister = FOX_FP

    i := 0

    WHILE i < (FOX_S17 - FOX_S0 + 1) DO
        FoxCalleeSaved[i].Type = LIR_PREALLOCATED_REG
        FoxCalleeSaved[i].MachineRegister = FOX_S0 + i

        i += 1
    END

    i = 0

    WHILE i < (FOX_A3 - FOX_A0 + 1) DO
        FoxArg[i].Type = LIR_PREALLOCATED_REG
        FoxArg[i].MachineRegister = FOX_A0 + i

        i += 1
    END

    // Perform instruction selection on each function.

    funcsym := PrsFunctionListHead

    WHILE funcsym DO
        // Calculate the scratch area size.

        irfunc := CAST funcsym^.InitialValue TO ^IrFunction

        inscratch := 0

        IF irfunc^.MaximumInCount > 4 THEN
            inscratch = (irfunc^.MaximumInCount - 4) * 4
        END

        outscratch := 0

        IF irfunc^.MaximumOutCount > 3 THEN
            outscratch = (irfunc^.MaximumOutCount - 3) * 4
        END

        IF inscratch > outscratch THEN
            irfunc^.ScratchAreaSize = inscratch
        
        ELSE
            irfunc^.ScratchAreaSize = outscratch
        END

        LirSelectForFunction ( funcsym )

        funcsym = funcsym^.NextFunction
    END

    // Do regalloc over the low level IR (LIR).

    funcsym = PrsFunctionListHead

    WHILE funcsym DO
        // Apply hints to the formal parameters.

        irfunc := CAST funcsym^.InitialValue TO ^IrFunction

        LirCurrentFunction = irfunc

        FoxHintFunction ( funcsym, irfunc )

        // Do regalloc.

        LirAllocateRegistersForFunction ( funcsym )

        // Generate spill code.

        FoxGenerateSpills ( irfunc )

        // Generate the prologue and epilogue.

        FoxGenerateAbiStuff ( funcsym, irfunc )

        // Peephole optimize the LIR.

        LirPeepholeForFunction ( irfunc )

        funcsym = funcsym^.NextFunction
    END

    // Emit the final assembly language.

    XrAsmEmit (
        &FoxAsmEmitter, // emitter
    )
END