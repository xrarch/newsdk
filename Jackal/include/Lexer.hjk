#INCLUDE "<inc>/Frontend.hjk"

ENUM LexTokenType : UBYTE
    TOKEN_ANY,

    TOKEN_STATEMENT, // subtype is a statement type
    TOKEN_PTYPE, // subtype is a primitive type
    TOKEN_OPER, // subtype is operator type
    TOKEN_VALUE, // some kind of primitive value (NULL, NULLPTR, TRUE, FALSE)
    TOKEN_ARGSPEC, // argument specifier (IN, OUT)
    TOKEN_DECL, // declarator
    TOKEN_OTHER, // anything else (THEN, DO, )
    TOKEN_ASSIGN, // assignment operators
    TOKEN_TERMINATOR, // block terminators (ELSE, ELSEIF, END)

    TOKEN_RPAREN,
    TOKEN_RBRACKET,
    TOKEN_COLON,
    TOKEN_LBRACE,
    TOKEN_RBRACE,
    TOKEN_COMMA,
    TOKEN_SIZEOF,
    TOKEN_OFFSETOF,

    TOKEN_IDENTIFIER, // payload is a symbol table entry pointer
    TOKEN_STRING, // payload is a pointer to a LexStringContents structure
    TOKEN_NUMBER, // payload is the number value

    TOKEN_VIRTUAL,

    TOKEN_EOF,
    TOKEN_TYPE_MAX, // MUST be at the end
END

ENUM LexTokenSubtype : UBYTE
    TOKEN_SUBTYPE_ANY,

    TOKEN_AND,         // operator
    TOKEN_BREAK,       // statement
    TOKEN_BYTE,        // type
    TOKEN_CAST,        // operator
    TOKEN_CONTAINEROF, // operator
    TOKEN_CONTINUE,    // statement
    TOKEN_DO,          // other
    TOKEN_ELSE,        // terminator
    TOKEN_ELSEIF,      // terminator
    TOKEN_END,         // terminator
    TOKEN_ENUM,        // declarator
    TOKEN_EXTERN,      // declarator
    TOKEN_FALSE,       // value
    TOKEN_FN,          // declarator
    TOKEN_FNPTR,       // declarator
    TOKEN_GOTO,        // statement
    TOKEN_IF,          // statement
    TOKEN_IN,          // argspec
    TOKEN_INT,         // type
    TOKEN_LEAVE,       // statement
    TOKEN_LONG,        // type
    TOKEN_NOT,         // operator
    TOKEN_NULLPTR,     // value
    TOKEN_OR,          // operator
    TOKEN_OUT,         // argspec
    TOKEN_PACKED,      // other
    TOKEN_PUBLIC,      // declarator
    TOKEN_RETURN,      // statement
    TOKEN_SIZEOFVALUE, // operator
    TOKEN_STRUCT,      // declarator
    TOKEN_THEN,        // other
    TOKEN_TO,          // other
    TOKEN_TRUE,        // value
    TOKEN_TYPE,        // declarator
    TOKEN_UBYTE,       // type
    TOKEN_UINT,        // type
    TOKEN_ULONG,       // type
    TOKEN_UNION,       // declarator
    TOKEN_VOID,        // type
    TOKEN_WHILE,       // statement
    TOKEN_BARRIER,     // statement
    TOKEN_INSERTASM,   // statement
    TOKEN_NOTHING,     // statement
    TOKEN_EXPORT,      // declarator
    TOKEN_PRIVATE,     // declarator
    TOKEN_UQUAD,       // type
    TOKEN_QUAD,        // type
    TOKEN_ROR,         // operator

    TOKEN_UWORD,       // type
    TOKEN_WORD,        // type

    TOKEN_EQUIV,       // operator
    TOKEN_NOTEQUIV,    // operator
    TOKEN_BITAND,      // operator
    TOKEN_BITOR,       // operator
    TOKEN_LESSTHAN,    // operator
    TOKEN_GREATERTHAN, // operator
    TOKEN_LTEQ,        // operator
    TOKEN_GTEQ,        // operator
    TOKEN_PLUS,        // operator
    TOKEN_MINUS,       // operator
    TOKEN_DIVIDE,      // operator
    TOKEN_MODULO,      // operator
    TOKEN_DOT,         // operator
    TOKEN_LABEL,       // statement
    TOKEN_BITXOR,      // operator
    TOKEN_LEFTSHIFT,   // operator
    TOKEN_RIGHTSHIFT,  // operator
    TOKEN_BITNOT,      // operator
    TOKEN_MUL,         // operator
    TOKEN_VARARG,      // argspec

    TOKEN_LBRACKET,    // operator
    TOKEN_CARET,       // operator
    TOKEN_LPAREN,      // operator

    TOKEN_EQUALS,      // assign
    TOKEN_PLUSEQUALS,  // assign
    TOKEN_MINUSEQUALS, // assign
    TOKEN_MULEQUALS,   // assign
    TOKEN_DIVEQUALS,   // assign
    TOKEN_MODEQUALS,   // assign
    TOKEN_ANDEQUALS,   // assign
    TOKEN_OREQUALS,    // assign
    TOKEN_XOREQUALS,   // assign
    TOKEN_LSHEQUALS,   // assign
    TOKEN_RSHEQUALS,   // assign

    TOKEN_ADDROF, // virtual (to distinguish from bitwise AND)

    TOKEN_IDENTIFIER_NEW,
    TOKEN_IDENTIFIER_FOUND,

    TOKEN_SUBTYPE_MAX, // MUST be at the end of the token subtypes
END

ENUM LexSymbolType : UBYTE
    SYM_UNINITIALIZED,
    SYM_VAR,
    SYM_LABEL,
    SYM_TYPE,
    SYM_CONSTANT,

    // The "forward" types signify a symbol that has been used before it was
    // defined, in a context where it was okay to do so. In fact, it's okay to
    // never declare these as long as they weren't referenced in the source
    // program.

    SYM_FORWARD_LABEL,
    SYM_FORWARD_TYPE,
END

#INCLUDE "../../Cf/CfLexer.hjk"

STRUCT LexSymbol
    Entry : TlHashTableEntry, // MUST be at the beginning
    Name : ^UBYTE,

    Section : ^LexSection,

    // Parser private stuff in a symbol.

    Next : ^LexSymbol,
    Prev : ^LexSymbol,

    NextFunction : ^LexSymbol,

    Value : UWORD,

    // Unfortunately the initial value has to be a void pointer; it's actually a
    // pointer to an AST node, or in the case of a function, an IR block.

    InitialValue : ^VOID,

    SemanticType : ^LexSemanticType,

    IrContext : ^VOID,
    StackOffset : UWORD,

    TrgContext : ^VOID,

    Flags : ULONG,
    Type : LexSymbolType,
    StackAllocated : UBYTE,
    ParameterType : UBYTE,
END

ENUM LexSemanticSubtype : UBYTE
    TYPE_PRIMITIVE,
    TYPE_ARRAY,
    TYPE_POINTER,
    TYPE_NAMED,
    TYPE_FUNCTION,
    TYPE_COMPOUND,
END

STRUCT LexSemanticTypePrimitiveBody
    Type : JklPrimitiveType,
    Inducible : UBYTE,
END

STRUCT LexSemanticTypeArrayBody
    // The base points to the "underlying type". I.e., "array of [base]".

    Base : ^LexSemanticType,
    Bound : UWORD,
    ElementSize : UWORD,
    HasBound : UBYTE,

    // This "parent" link is only used at type parsing time.

    Parent : ^LexSemanticType,
END

STRUCT LexSemanticTypePointerBody
    // The base points to the "underlying type". I.e., "pointer to [base]".

    Base : ^LexSemanticType,
END

STRUCT LexSemanticTypeNamedBody
    // The type is named, so it has an associated symbol.

    Symbol : ^LexSymbol,
END

ENUM LexFunctionArgumentTypes : UBYTE
    ARG_NULL,
    ARG_IN,
    ARG_OUT,
END

STRUCT LexFunctionArgument
    Next : ^LexFunctionArgument,

    Token : LexToken,

    Symbol : ^LexSymbol,
    InOut : LexFunctionArgumentTypes,
END

STRUCT LexSemanticTypeFunctionBody
    // The type is a function, so it has an argument list and a return type.

    ArgListHead : ^LexFunctionArgument,
    ReturnType : ^LexSemanticType,
    FuncScope : ^TlSymbolTable,
    FnPtrType : ^LexSemanticType,
    VarArgTable : ^LexSymbol,
    VarArgCount : ^LexSymbol,
    VarTable : ^LexSymbol,
    BodyBlock : ^VOID, // actually a PrsBlock
    ArgCount : ULONG,
    IsVarArg : UBYTE,
    IsFnPtr : UBYTE,
END

STRUCT LexSemanticTypeCompoundBody
    FieldScope : ^TlSymbolTable,

    IsPacked : UBYTE,
END

UNION LexSemanticTypeBody
    Primitive : LexSemanticTypePrimitiveBody,
    Array : LexSemanticTypeArrayBody,
    Pointer : LexSemanticTypePointerBody,
    Named : LexSemanticTypeNamedBody,
    Function : LexSemanticTypeFunctionBody,
    Compound : LexSemanticTypeCompoundBody,
END

STRUCT LexSemanticType
    Body : LexSemanticTypeBody,
    Size : UWORD,
    Subtype : LexSemanticSubtype,
    MinimumAlignment : UBYTE,
    CachedIsDeclarable : UBYTE,
    CachedIsValue : UBYTE,
END

STRUCT LexAsmBlock
    Next : ^LexAsmBlock,
    Section : ^LexSection,

    Token : LexToken,
    Contents : TlDynamicBuffer,
END

STRUCT LexSectionStackElement
    Prev : ^LexSectionStackElement,
    Section : ^LexSection,
END

STRUCT LexSection
    Entry : TlHashTableEntry, // MUST be at the beginning
    Name : UBYTE[LEX_DIRECTIVE_MAX],
    Next : ^LexSection,

    InternedStringHashTable : TlHashTable,

    // Include a context word for the code generator.

    ForwardDynamicBuffer : TlDynamicBuffer,
    DynamicBuffer : TlDynamicBuffer,

    CodeGenContext : ^VOID,
END

EXTERN FN LexLookupSection (
    IN name : ^UBYTE,
) : ^LexSection

EXTERN FN LexPushSection (
    IN section : ^LexSection,
)

EXTERN FN LexPopSection () : UBYTE

EXTERN LexNextSymbolSection : ^LexSection
EXTERN LexCurrentSection : ^LexSection
EXTERN LexSectionListHead : ^LexSection

EXTERN LexDefaultSection : LexSection
EXTERN LexTextSection : LexSection
EXTERN LexDataSection : LexSection
EXTERN LexBssSection : LexSection

EXTERN LexCurrentFunctionSymbol : ^LexSymbol
EXTERN LexAsmBlockListHead : ^LexAsmBlock

EXTERN FN LexInitializeSectionStuff ()